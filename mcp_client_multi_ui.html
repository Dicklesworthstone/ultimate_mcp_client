<!DOCTYPE html>
<html lang="en" data-theme="corporate">
<!-- Changed default theme -->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate MCP Client UI (Multi-Provider)</title>
    <!-- Updated title -->
    <!-- Favicon -->
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ”Œ</text></svg>">
    <!-- Changed Icon -->
    <!-- FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- Animate.css -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    <!-- Tippy.js CSS -->
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/animations/scale.css" />
    <!-- highlight.js Theme -->
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/atom-one-dark.min.css"
        id="hljs-theme-dark" media="(prefers-color-scheme: dark)">
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/atom-one-light.min.css"
        id="hljs-theme-light" media="(prefers-color-scheme: light)">
    <!-- DaisyUI -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/daisyui/4.4.19/full.min.css" rel="stylesheet" type="text/css" />
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: { sans: ['Montserrat', 'sans-serif'], },
                }
            }
        }
    </script>
    <!-- Tabulator CSS -->
    <link href="https://cdn.jsdelivr.net/npm/tabulator-tables@6.3.1/dist/css/tabulator_modern.min.css" rel="stylesheet">
    <!-- Tabulator JS -->
    <script type="text/javascript"
        src="https://cdn.jsdelivr.net/npm/tabulator-tables@6.3.1/dist/js/tabulator.min.js"></script>
    <!-- JS Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.6/Sortable.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/dist/tippy.umd.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/dist/tippy.min.css">
    <script src="https://cdn.jsdelivr.net/npm/marked@15.0.11/lib/marked.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.2.5/dist/purify.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns@4.1.0/cdn.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/pickr.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/themes/classic.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mousetrap/1.6.5/mousetrap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/3.0.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/@alpinejs/collapse@3.x.x/dist/cdn.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.14.9/dist/cdn.min.js"></script>
    <script>
        // Marked configuration (restore from old code)
        const markedRenderer = new marked.Renderer(); // Use 'const' or 'let'

        // --- START: Copy the exact .code override from the OLD CODE ---
        markedRenderer.code = (code, language, isEscaped) => {
            const lang = hljs.getLanguage(language) ? language : 'plaintext';
            let codeToHighlight = ''; // Initialize
            let originalCodeForCopy = code; // Preserve original for copy button if possible

            if (typeof code === 'string') {
                codeToHighlight = code;
                originalCodeForCopy = code; // It's already a string
            } else if (code && typeof code === 'object' && typeof code.text === 'string') {
                // If it's an object with a text property (like from the log)
                codeToHighlight = code.text;
                originalCodeForCopy = code.text; // Use the extracted text for copy too
            } else {
                // Fallback: attempt stringification if it's not a string or the expected object structure
                console.warn("Marked 'code' received unexpected type, attempting stringification:", code);
                codeToHighlight = String(code); // This might result in [object Object]
                originalCodeForCopy = codeToHighlight; // Copy the stringified version
            }

            try {
                const highlightedCode = hljs.highlight(codeToHighlight, { language: lang, ignoreIllegals: true }).value;
                // Use originalCodeForCopy for the copy button to get the best representation
                // Assuming createCopyButton is globally available or defined here.
                const copyButtonHtml = createCopyButton(originalCodeForCopy);
                // Wrap in a div for positioning context and add hljs class for styling
                return `<div class="relative group"><pre><code class="hljs language-${lang}">${highlightedCode}</code></pre>${copyButtonHtml}</div>`;
            } catch (e) {
                console.error("Highlighting error:", e);
                // Fallback: Ensure code is stringified before sanitizing if error occurred
                const safeCode = DOMPurify.sanitize(codeToHighlight); // Sanitize the extracted/stringified code
                return `<div class="relative group"><pre><code class="hljs language-${lang}">${safeCode}</code></pre>${createCopyButton(safeCode)}</div>`;
            }
        };

        // Set Marked options using the custom renderer
        marked.setOptions({
            renderer: markedRenderer, // Make sure this uses the renderer defined above
            breaks: true, // Convert single newlines to <br>
            gfm: true, // Enable GitHub Flavored Markdown
        });
        console.log("Global Marked options set with custom renderer."); // Updated log

        const createCopyButton = (codeToCopy, type = 'code') => {
            try {
                // Use a different event dispatch mechanism compatible with Alpine listening globally
                const encodedCode = btoa(encodeURIComponent(JSON.stringify(codeToCopy))); // ENSURE encodeURIComponent is used
                const buttonText = type === 'result' ? 'Copy Result' : 'Copy';
                return `<button class="copy-code-btn" x-data="{ copied: false }" @click.stop="document.body.dispatchEvent(new CustomEvent('copy-clipboard', { detail: '${encodedCode}' })); copied = true; setTimeout(() => copied = false, 1500)">
                     <i class="fas mr-1" :class="copied ? 'fa-check text-success' : 'fa-copy'"></i> <span x-text="copied ? 'Copied!' : '${buttonText}'"></span>
                 </button>`;
            } catch (e) {
                console.error("Error creating copy button data:", e);
                return '<!-- copy error -->';
            }
        };
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --sidebar-width: 30rem;
            --mobile-sidebar-width: 85vw;
            --header-height: 56px;
            --bottom-input-height: 80px;
            --system-status-height: 28px;
        }

        .sidebar {
            width: var(--sidebar-width);
            transition: transform 0.25s ease-in-out;
        }

        @media (max-width: 768px) {
            .sidebar {
                width: var(--mobile-sidebar-width);
                position: fixed;
                left: 0;
                top: var(--header-height);
                bottom: 0;
                z-index: 40;
                transform: translateX(-100%);
            }

            .sidebar.open {
                transform: translateX(0);
                box-shadow: 4px 0 15px rgba(0, 0, 0, 0.2);
            }

            .sidebar-overlay {
                position: fixed;
                inset: 0;
                background-color: rgba(0, 0, 0, 0.5);
                z-index: 30;
                backdrop-filter: blur(2px);
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.25s ease-in-out;
            }

            .sidebar-overlay.open {
                opacity: 1;
                pointer-events: auto;
            }
        }

        .chat-messages::-webkit-scrollbar,
        .sidebar ::-webkit-scrollbar {
            width: 6px;
        }

        main.flex-1.flex.flex-col.h-full {
            padding-left: 1rem !important;
        }

        @media (min-width: 768px) {
            main.flex-1.flex.flex-col.h-full {
                padding-left: 1.5rem !important;
            }
        }

        .chat-messages::-webkit-scrollbar-track,
        .sidebar ::-webkit-scrollbar-track {
            background: hsl(var(--b2) / 0.5);
        }

        .chat-messages::-webkit-scrollbar-thumb,
        .sidebar ::-webkit-scrollbar-thumb {
            background: hsl(var(--bc) / 0.5);
            border-radius: 3px;
        }

        .chat-messages::-webkit-scrollbar-thumb:hover,
        .sidebar ::-webkit-scrollbar-thumb:hover {
            background: hsl(var(--p) / 1);
        }

        dialog {
            z-index: 50;
        }

        .fa-fw {
            width: 1.25em;
        }

        .tippy-box {
            font-size: 0.8rem;
            max-width: 300px !important;
        }

        .docstring-section {
            margin-bottom: 1.5rem;
            background-color: hsl(var(--b1));
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid hsl(var(--b3) / 0.5);
            box-shadow: 0 1px 3px hsla(var(--bc) / 0.1);
        }

        .docstring-section:last-child {
            margin-bottom: 0;
        }

        .docstring-section h4 {
            color: hsl(var(--p));
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            border-bottom: 1px solid hsl(var(--b3) / 0.5);
            padding-bottom: 0.5rem;
        }

        .docstring-section h4::before {
            content: '';
            display: block;
            width: 4px;
            height: 1.25rem;
            margin-right: 0.5rem;
            background-color: hsl(var(--p));
            border-radius: 2px;
        }

        .docstring-section .font-mono.text-info {
            padding: 0.15rem 0.4rem;
            background-color: hsl(var(--p) / 0.1);
            border: 1px solid hsl(var(--p) / 0.2);
            border-radius: 0.25rem;
            font-size: 0.85rem;
            font-weight: 600;
            color: hsl(var(--p));
        }

        .docstring-section p {
            line-height: 1.6;
            font-size: 0.95rem;
            margin-bottom: 0.75rem;
        }

        .docstring-section pre {
            margin: 0.75rem 0;
            border-radius: 0.5rem;
            max-height: 300px;
            overflow-y: auto;
            background-color: hsl(var(--n) / 0.8) !important;
            border: 1px solid hsl(var(--n) / 0.3);
        }

        .docstring-section pre code.hljs {
            padding: 1rem;
            font-size: 0.9rem;
            line-height: 1.5;
            color: hsl(var(--nc)) !important;
            background-color: transparent !important;
        }

        .docstring-section p strong:first-child {
            color: hsl(var(--p));
            font-weight: 600;
        }

        .docstring-section pre::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .docstring-section pre::-webkit-scrollbar-track {
            background: hsl(var(--n) / 0.3);
            border-radius: 0 0 0.5rem 0;
        }

        .docstring-section pre::-webkit-scrollbar-thumb {
            background: hsl(var(--p) / 0.5);
            border-radius: 4px;
        }

        .docstring-section pre::-webkit-scrollbar-thumb:hover {
            background: hsl(var(--p) / 0.7);
        }

        .copy-code-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: hsl(var(--b1) / 0.6);
            color: hsl(var(--bc) / 0.8);
            border: none;
            padding: 0.2rem 0.4rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.7rem;
            opacity: 0;
            transition: opacity 0.2s ease-in-out, background-color 0.2s, color 0.2s;
            z-index: 10;
        }

        pre:hover .copy-code-btn,
        .copy-code-btn:focus {
            opacity: 1;
        }

        div:hover>.copy-code-btn,
        .tool-code-block-wrapper:hover .copy-code-btn {
            opacity: 1;
        }

        .copy-code-btn:hover {
            background-color: hsl(var(--b3) / 0.8);
            color: hsl(var(--bc) / 1);
        }

        .chat-bubble {
            max-width: 90%;
            overflow-wrap: break-word;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: box-shadow 0.2s ease-in-out;
        }

        .chat-bubble:hover {
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
        }

        .chat-bubble.prose {
            font-size: 0.95rem;
            --tw-prose-code: hsl(var(--ac));
            --tw-prose-pre-bg: hsl(var(--n) / 0.7);
            --tw-prose-pre-code: hsl(var(--nc));
        }

        .chat-bubble.prose h1,
        .chat-bubble.prose h2,
        .chat-bubble.prose h3 {
            margin-top: 0.8em;
            margin-bottom: 0.4em;
        }

        .chat-bubble.prose p {
            margin-top: 0.5em;
            margin-bottom: 0.5em;
        }

        .chat-bubble.prose ul,
        .chat-bubble.prose ol {
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            padding-left: 1.2em;
        }

        .chat-bubble.prose pre,
        .chat-bubble.prose div.relative.group>pre {
            position: relative;
            border-radius: 0.375rem;
            padding: 0.75rem 1rem;
            white-space: pre-wrap;
            word-break: break-all;
            max-height: 400px;
            overflow-y: auto;
            background-color: var(--tw-prose-pre-bg) !important;
            color: var(--tw-prose-pre-code) !important;
        }

        .chat-bubble.prose pre code.hljs,
        .chat-bubble.prose div.relative.group>pre code.hljs {
            background-color: transparent !important;
            color: inherit;
            padding: 0;
        }

        .chat-bubble.prose code:not(pre *) {
            color: var(--tw-prose-code);
            background-color: hsl(var(--b2));
            padding: 0.1em 0.3em;
            border-radius: 0.25rem;
            font-size: 0.85rem;
        }

        .chat-bubble {
            --min-contrast-ratio: 4.5;
            color: hsl(var(--bc) / 0.95);
        }

        .chat-bubble.chat-bubble-primary {
            color: hsl(var(--pc) / 0.95);
        }

        .chat-bubble.bg-neutral {
            color: hsl(var(--nc) / 0.95);
        }

        .dropdown-content {
            color: hsl(var(--bc));
            border: 1px solid hsl(var(--b3) / 0.2);
        }

        .streaming-status {
            color: hsl(var(--nc) / 0.6);
            font-style: italic;
            font-size: 0.75rem;
            margin-top: 0.2rem;
            text-align: right;
        }

        .sidebar-list-item {
            transition: background-color 0.15s ease-in-out, opacity 0.2s ease-in-out, filter 0.15s ease-in-out; /* Add filter to transition */
            border: 1px solid transparent;
            /* Ensure items have a base background to filter */
            /* background-color: hsl(var(--b1)); /* Or whatever their default is - often inherited or set by card class */
        }

        .sidebar-list-item:hover {
            /* REMOVE this line: */
            /* background-color: hsl(var(--b2) / 0.8); */

            /* ADD this line: */
            filter: brightness(0.95); /* Adjust 0.95 (5% darker) to 0.9 (10% darker) etc. as needed */

            /* Keep this line if you like the border effect */
            border-color: hsl(var(--b3) / 0.3);
        }

        /* ADD this new rule to handle the branch list items */
        #branch-list li > div:hover {
            /* Override Tailwind's hover:bg-base-300/80 background change */
            background-color: initial; /* Prevent explicit background color change */
            filter: brightness(0.95); /* Apply the same relative darkening */
        }

        #branch-list li > div.bg-primary\/10:hover { /* Corrected escape for / */
             /* It already has a background, just apply filter */
             filter: brightness(0.9); /* Make active hover slightly more noticeable */
        }

        .loading-overlay {
            position: fixed;
            inset: 0;
            background-color: hsl(var(--b1) / 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .tippy-box[data-theme^='light'] .tippy-arrow {
            color: #333;
        }

        .tippy-box[data-theme^='dark'] .tippy-arrow {
            color: #eee;
        }

        .tippy-box[data-theme="light"] {
            background-color: #333;
            color: white;
        }

        .tippy-box[data-theme="dark"] {
            background-color: #eee;
            color: black;
        }

        #branch-list ul {
            padding-left: 0;
            list-style: none;
        }

        #branch-list li {
            padding-left: var(--indent-level, 0em);
        }

        .chat-bubble.bg-info {
            background-color: hsl(var(--in) / 0.2) !important;
            color: hsl(var(--bc)) !important;
            border: 1px solid hsl(var(--in) / 0.3) !important;
        }

        .chat-image .bg-info {
            background-color: hsl(var(--in)) !important;
            color: hsl(var(--inc)) !important;
        }

        .chat-image .avatar .w-8 {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chat-image .avatar .w-8 i {
            line-height: 1;
            display: block;
        }

        .chat-image.avatar i {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translateX(-50%) translateY(-50%);
            font-size: 1rem;
        }

        .tabulator {
            border: 1px solid hsl(var(--b3) / 0.4);
            background-color: hsl(var(--b1));
            color: hsl(var(--bc));
            border-radius: var(--rounded-box, 0.5rem);
            font-size: 0.75rem;
            overflow: hidden;
        }

        .tabulator .tabulator-header {
            background-color: hsl(var(--b2));
            border-bottom: 1px solid hsl(var(--b3) / 0.4);
            color: hsl(var(--bc));
            font-weight: 600;
        }

        .tabulator .tabulator-header .tabulator-col {
            background-color: inherit;
        }

        .tabulator .tabulator-header .tabulator-col .tabulator-header-filter input,
        .tabulator .tabulator-header .tabulator-col .tabulator-header-filter select {
            background-color: hsl(var(--b1));
            border: 1px solid hsl(var(--b3) / 0.5);
            border-radius: var(--rounded-input, 0.25rem);
            padding: 0.1rem 0.4rem;
            font-size: 0.7rem;
            color: hsl(var(--bc));
            margin-top: 2px;
        }

        .tabulator .tabulator-tableholder .tabulator-table {
            background-color: hsl(var(--b1));
            color: hsl(var(--bc));
        }

        .tabulator .tabulator-row {
            background-color: hsl(var(--b1));
            color: hsl(var(--bc));
            border-bottom: 1px solid hsl(var(--b3) / 0.2) !important;
            min-height: 28px;
        }

        .tabulator .tabulator-row.tabulator-row-odd {
            background-color: hsl(var(--b2) / 0.4);
        }

        .tabulator .tabulator-row:hover {
            background-color: hsl(var(--b3) / 0.3);
        }

        .tabulator .tabulator-placeholder {
            display: flex;
            justify-content: center;
            align-items: center;
            color: hsl(var(--bc) / 0.5);
            font-style: italic;
            background-color: hsl(var(--b1) / 0.7);
            width: 100%;
            min-height: 60px;
        }

        .tabulator .tabulator-placeholder span {
            color: inherit;
            font-style: inherit;
            background-color: transparent;
        }

        .tabulator .tabulator-row .tabulator-cell button.btn-xs {
            padding-left: 0.4rem;
            padding-right: 0.4rem;
            min-height: 1.2rem;
            height: 1.2rem;
            line-height: 1;
        }

        .tabulator .tabulator-row .tabulator-cell i.fas {
            font-size: 0.7rem;
            margin-right: 0 !important;
        }

        .message-date-divider {
            display: flex;
            align-items: center;
            margin: 1rem 0;
            color: hsl(var(--bc) / 0.6);
            font-size: 0.8rem;
            position: relative;
        }

        .message-date-divider::before,
        .message-date-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background-color: hsl(var(--bc) / 0.2);
        }

        .message-date-divider span {
            padding: 0 0.75rem;
            background-color: hsl(var(--b2));
            border-radius: 1rem;
            padding: 0.2rem 0.75rem;
            font-weight: 500;
        }

        .chat.compact-mode .chat-bubble {
            padding: 0.5rem 0.75rem;
            margin-bottom: 0.25rem;
        }

        .chat.compact-mode .chat-header {
            font-size: 0.7rem;
            margin-bottom: 0;
        }

        .chat.compact-mode .chat-image .avatar .w-8 {
            width: 1.5rem !important;
            height: 1.5rem !important;
        }

        .theme-preview {
            border-radius: 0.5rem;
            overflow: hidden;
            border: 1px solid hsl(var(--b3) / 0.3);
            position: relative;
            cursor: pointer;
            transition: transform 0.2s ease, border-color 0.2s ease;
            display: grid;
        }

        .theme-preview:hover {
            transform: translateY(-2px);
            border-color: hsl(var(--p));
        }

        .theme-preview.active {
            border: 2px solid hsl(var(--p));
        }

        .color-picker-container {
            margin-bottom: 1rem;
        }

        .color-preview {
            width: 100%;
            height: 3rem;
            border-radius: 0.5rem;
            margin-top: 0.5rem;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 0.25rem;
            overflow: hidden;
        }

        .system-status-bar {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            height: var(--system-status-height);
            background-color: hsl(var(--b3));
            border-top: 1px solid hsl(var(--b3) / 0.5);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 0.75rem;
            font-size: 0.7rem;
            color: hsl(var(--bc) / 0.7);
            z-index: 20;
            transition: transform 0.3s ease-in-out;
        }

        .system-status-bar.hidden {
            transform: translateY(var(--system-status-height));
        }

        .system-status-bar .status-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-bar-active .chat-messages {
            margin-bottom: var(--system-status-height);
        }

        .bookmark-indicator {
            position: absolute;
            top: -0.5rem;
            right: 0.5rem;
            color: hsl(var(--wa));
            font-size: 1rem;
            filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
            z-index: 1;
            opacity: 0.9;
        }

        .conversation-tag {
            display: inline-flex;
            align-items: center;
            padding: 0.1rem 0.5rem;
            border-radius: 1rem;
            font-size: 0.65rem;
            font-weight: 600;
            margin-right: 0.25rem;
            margin-bottom: 0.25rem;
            background-color: hsl(var(--p) / 0.2);
            color: hsl(var(--p));
            cursor: pointer;
            transition: all 0.15s ease;
            white-space: nowrap;
        }

        .conversation-tag:hover {
            background-color: hsl(var(--p) / 0.3);
        }

        .conversation-tag i {
            margin-right: 0.25rem;
        }

        .keyboard-shortcuts-panel {
            max-width: 500px;
            width: 100%;
        }

        .keyboard-shortcut-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid hsl(var(--b3) / 0.2);
        }

        .keyboard-shortcut-item:last-child {
            border-bottom: none;
        }

        .keyboard-shortcut-keys {
            display: flex;
            gap: 0.25rem;
        }

        .keyboard-shortcut-key {
            background-color: hsl(var(--b2));
            border: 1px solid hsl(var(--b3));
            border-radius: 0.25rem;
            padding: 0.1rem 0.4rem;
            font-size: 0.7rem;
            font-family: monospace;
            min-width: 1.8rem;
            text-align: center;
            box-shadow: 0 2px 0 hsl(var(--b3));
        }

        .virtual-scroll-container {
            overflow-y: auto;
            position: relative;
            height: 100%;
        }

        .virtual-scroll-content {
            position: absolute;
            width: 100%;
        }

        .message-search-container {
            position: sticky;
            top: 0;
            z-index: 20;
            background-color: hsl(var(--b1));
            padding: 0.5rem;
            border-bottom: 1px solid hsl(var(--b3) / 0.2);
            margin-bottom: 0.5rem;
            display: flex;
            gap: 0.5rem;
            transform: translateY(-100%);
            transition: transform 0.3s ease;
        }

        .message-search-container.active {
            transform: translateY(0);
        }

        .status-bar-active main {
            padding-bottom: var(--system-status-height);
        }

        .search-result-highlight {
            background-color: hsl(var(--wa) / 0.3);
            border-radius: 0.15rem;
            padding: 0.05rem 0.1rem;
        }

        .favorites-container,
        .recent-tools-container {
            margin-bottom: 1rem;
        }

        .tool-card {
            padding: 0.5rem;
            border-radius: 0.5rem;
            background-color: hsl(var(--b2) / 0.5);
            border: 1px solid hsl(var(--b3) / 0.3);
            margin-bottom: 0.5rem;
            transition: all 0.2s ease;
        }

        .tool-card:hover {
            background-color: hsl(var(--b2));
            border-color: hsl(var(--p) / 0.3);
            transform: translateY(-1px);
        }

        .tool-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.25rem;
        }

        .tool-card-name {
            font-weight: 600;
            font-size: 0.8rem;
        }

        .tool-card-server {
            font-size: 0.65rem;
            opacity: 0.7;
        }

        .tool-card-actions {
            display: flex;
            gap: 0.25rem;
        }

        .dashboard-container {
            padding: 1rem;
        }

        .dashboard-card {
            background-color: hsl(var(--b1));
            border-radius: 0.5rem;
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 1rem;
            color: hsl(var(--bc));
            border: 1px solid hsl(var(--b3) / 0.3);
        }

        .dashboard-card .table {
            color: hsl(var(--bc) / 0.8);
            border-collapse: separate;
            border-spacing: 0;
            width: 100%;
        }

        .dashboard-card .table th {
            background-color: hsl(var(--b2));
            color: hsl(var(--bc) / 0.9);
            font-weight: 600;
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid hsl(var(--b3) / 0.3);
        }

        .dashboard-card .table td {
            padding: 0.5rem;
            border-bottom: 1px solid hsl(var(--b3) / 0.2);
        }

        .dashboard-card .table tr:hover {
            background-color: hsl(var(--b2) / 0.5);
        }

        .dashboard-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid hsl(var(--b3) / 0.2);
            padding-bottom: 0.5rem;
        }

        .dashboard-card-title {
            font-weight: 600;
            font-size: 1rem;
            color: hsl(var(--bc) / 0.9);
        }

        .dashboard-card-content {
            font-size: 0.9rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 1rem;
        }

        .stat-item {
            text-align: center;
            padding: 0.5rem;
            background-color: hsl(var(--b2) / 0.7);
            border-radius: 0.5rem;
            border: 1px solid hsl(var(--b3) / 0.3);
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: hsl(var(--p));
            margin-bottom: 0.25rem;
        }

        .stat-label {
            font-size: 0.7rem;
            color: hsl(var(--bc) / 0.8);
            font-weight: 500;
        }

        .badge.badge-success {
            background-color: hsl(var(--su) / 0.8);
            color: hsl(var(--suc));
        }

        .badge.badge-warning {
            background-color: hsl(var(--wa) / 0.8);
            color: hsl(var(--wac));
        }

        .badge.badge-error {
            background-color: hsl(var(--er) / 0.8);
            color: hsl(var(--erc));
        }

        .draggable {
            cursor: grab;
        }

        .draggable:active {
            cursor: grabbing;
        }

        .drop-zone {
            border: 2px dashed hsl(var(--b3) / 0.5);
            border-radius: 0.5rem;
            padding: 1rem;
            text-align: center;
            transition: all 0.2s ease;
        }

        .drop-zone.drag-over {
            border-color: hsl(var(--p));
            background-color: hsl(var(--p) / 0.1);
        }

        .comparison-view {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            overflow: auto;
        }

        .comparison-branch {
            border: 1px solid hsl(var(--b3) / 0.3);
            border-radius: 0.5rem;
            background-color: hsl(var(--b2) / 0.5);
            padding: 0.5rem;
            max-height: 80vh;
            overflow: auto;
        }

        .comparison-header {
            font-weight: 600;
            padding-bottom: 0.5rem;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid hsl(var(--b3) / 0.2);
            position: sticky;
            top: 0;
            background-color: inherit;
            z-index: 10;
        }

        .template-item {
            border: 1px solid hsl(var(--b3) / 0.3);
            border-radius: 0.5rem;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .template-item:hover {
            border-color: hsl(var(--p));
            background-color: hsl(var(--b2));
        }

        .template-name {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .template-description {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .tool-content-wrapper {
            position: relative;
            border: 1px solid hsl(var(--b3) / 0.4);
            border-radius: var(--rounded-md, 0.375rem);
            margin-top: 0.5rem;
            overflow: hidden;
        }

        .chat-bubble .tool-content-wrapper>pre {
            background-color: hsl(var(--b2) / 0.7) !important;
            color: hsl(var(--bc)) !important;
            padding: 0.6rem 0.85rem !important;
            margin: 0 !important;
            border: none !important;
            border-radius: 0 !important;
            white-space: pre-wrap !important;
            word-break: break-all !important;
            display: block;
        }

        .chat-bubble .tool-content-wrapper>pre>code.hljs {
            background-color: transparent !important;
            color: inherit !important;
            padding: 0 !important;
            margin: 0 !important;
            display: block;
        }

        .chat-bubble .tool-content-wrapper>pre.tool-data-raw-text {
            font-family: var(--font-mono, monospace);
            font-size: 0.8rem;
            color: hsl(var(--bc) / 0.85) !important;
        }

        .tool-content-wrapper .copy-code-btn {
            top: 0.3rem;
            right: 0.3rem;
            background-color: hsl(var(--b3) / 0.6);
            color: hsl(var(--bc) / 0.9);
            border: 1px solid hsl(var(--b3) / 0.4);
            z-index: 11;
        }

        .tool-content-wrapper .copy-code-btn:hover {
            background-color: hsl(var(--b3) / 0.8);
            color: hsl(var(--bc));
        }

        .chat-bubble details>summary {
            background-color: hsl(var(--b1)/0.4);
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            transition: background-color 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
        }

        .chat-bubble details>summary:hover {
            background-color: hsl(var(--b2)/0.6);
        }

        [data-theme] .not-prose .bg-gray-800,
        [data-theme] .not-prose .bg-gray-900 {
            background-color: #1f2937 !important;
            color: #f3f4f6 !important;
        }

        [data-theme] .not-prose .bg-indigo-700 {
            background-color: #4338ca !important;
            color: #ffffff !important;
        }

        [data-theme] .not-prose .text-gray-100,
        [data-theme] .not-prose .text-gray-200,
        [data-theme] .not-prose .text-gray-300 {
            color: #f3f4f6 !important;
        }

        .prose-invert {
            --tw-prose-body: rgb(229 231 235);
            --tw-prose-headings: rgb(255 255 255);
            --tw-prose-lead: rgb(209 213 219);
            --tw-prose-links: rgb(147 197 253);
            --tw-prose-bold: rgb(255 255 255);
            --tw-prose-counters: rgb(209 213 219);
            --tw-prose-bullets: rgb(156 163 175);
            --tw-prose-hr: rgb(75 85 99);
            --tw-prose-quotes: rgb(243 244 246);
            --tw-prose-quote-borders: rgb(75 85 99);
            --tw-prose-captions: rgb(156 163 175);
            --tw-prose-code: rgb(255 255 255);
            --tw-prose-pre-code: rgb(229 231 235);
            --tw-prose-pre-bg: rgb(31 41 55);
            --tw-prose-th-borders: rgb(75 85 99);
            --tw-prose-td-borders: rgb(55 65 81);
        }

        .not-prose .prose-invert h1,
        .not-prose .prose-invert h2,
        .not-prose .prose-invert h3,
        .not-prose .prose-invert h4 {
            color: rgb(255 255 255);
            margin-top: 1rem;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .not-prose .prose-invert h1 {
            font-size: 1.5rem;
            line-height: 2rem;
        }

        .not-prose .prose-invert h2 {
            font-size: 1.25rem;
            line-height: 1.75rem;
        }

        .not-prose .prose-invert h3 {
            font-size: 1.125rem;
            line-height: 1.5rem;
        }

        .not-prose .prose-invert a {
            color: rgb(147 197 253);
            text-decoration: underline;
        }

        .not-prose .prose-invert strong {
            color: rgb(255 255 255);
            font-weight: 600;
        }

        .not-prose .prose-invert ol,
        .not-prose .prose-invert ul {
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
            padding-left: 1.25rem;
        }

        .not-prose .prose-invert li {
            margin-top: 0.25rem;
            margin-bottom: 0.25rem;
        }

        .not-prose .prose-invert pre {
            background-color: rgb(31 41 55);
            color: rgb(229 231 235);
            overflow-x: auto;
            font-size: 0.875rem;
            line-height: 1.5;
            margin: 0.5rem 0;
            padding: 0.75rem;
            border-radius: 0.375rem;
        }

        .not-prose .prose-invert code {
            color: rgb(255 255 255);
            background-color: rgba(255, 255, 255, 0.1);
            padding: 0.125rem 0.25rem;
            border-radius: 0.25rem;
            font-size: 0.875em;
        }

        .not-prose .prose-invert pre code {
            background-color: transparent;
            padding: 0;
            font-size: inherit;
            border-radius: 0;
        }

        .not-prose .prose-invert table {
            width: 100%;
            margin-top: 1rem;
            margin-bottom: 1rem;
            border-collapse: collapse;
        }

        .not-prose .prose-invert th {
            background-color: rgba(55, 65, 81, 0.5);
            font-weight: 600;
            text-align: left;
            padding: 0.5rem;
            font-size: 0.875rem;
        }

        .not-prose .prose-invert td {
            padding: 0.5rem;
            border: 1px solid rgb(55, 65, 81);
            font-size: 0.875rem;
        }

        .not-prose .prose-invert tr:nth-child(even) {
            background-color: rgba(55, 65, 81, 0.2);
        }

        .tool-result-container {
            margin-top: 1rem;
            margin-bottom: 1rem;
            border-radius: 0.5rem;
            overflow: hidden;
            border: 1px solid rgba(165, 180, 252, 0.3);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.05);
            background-color: #111827;
            color-scheme: dark;
        }

        .tool-result-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            background-image: linear-gradient(to right, #4338ca, #4f46e5);
            color: white;
        }

        .tool-result-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 500;
        }

        .tool-result-icon {
            width: 1.25rem;
            height: 1.25rem;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }

        .tool-result-actions {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tool-result-content {
            padding: 1rem;
            margin-top: 1rem;
            margin-bottom: 1rem;
            background-color: #111827;
            color: #f3f4f6;
        }

        .tool-markdown {
            color: #f3f4f6;
            margin-left: 0;
            margin-right: 0;
        }

        .tool-markdown h1,
        .tool-markdown h2,
        .tool-markdown h3,
        .tool-markdown h4 {
            color: white;
            font-weight: 600;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }

        .tool-markdown h1 {
            font-size: 1.25rem;
            border-bottom: 1px solid #374151;
            padding-bottom: 0.25rem;
        }

        .tool-markdown h2 {
            font-size: 1.125rem;
        }

        .tool-markdown h3 {
            font-size: 1rem;
        }

        .tool-markdown p {
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .tool-markdown a {
            color: #60a5fa;
        }

        .tool-markdown a:hover {
            text-decoration: underline;
        }

        .tool-markdown ul,
        .tool-markdown ol {
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
            padding-left: 1.25rem;
        }

        .tool-markdown li {
            margin-top: 0.25rem;
            margin-bottom: 0.25rem;
        }

        .tool-markdown blockquote {
            padding-left: 1rem;
            border-left: 4px solid #4b5563;
            color: #d1d5db;
            font-style: italic;
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .tool-markdown code {
            background-color: #1f2937;
            padding-left: 0.25rem;
            padding-right: 0.25rem;
            padding-top: 0.125rem;
            padding-bottom: 0.125rem;
            border-radius: 0.25rem;
            color: #93c5fd;
        }

        .tool-markdown pre {
            background-color: #1f2937;
            padding: 0.75rem;
            border-radius: 0.375rem;
            overflow-x: auto;
            margin-top: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .tool-markdown pre code {
            background-color: transparent;
            padding: 0;
            color: #f3f4f6;
        }

        .tool-markdown table {
            width: 100%;
            margin-top: 0.75rem;
            margin-bottom: 0.75rem;
            border-collapse: collapse;
        }

        .tool-markdown th {
            background-color: #1f2937;
            text-align: left;
            padding: 0.5rem;
            border: 1px solid #374151;
        }

        .tool-markdown td {
            padding: 0.5rem;
            border: 1px solid #374151;
        }

        .tool-markdown tr:nth-child(even) {
            background-color: rgba(31, 41, 55, 0.5);
        }

        .tool-code-container {
            overflow: hidden;
            border-radius: 0.375rem;
            border: 1px solid #374151;
        }

        .tool-code-title {
            background-color: #1f2937;
            color: #d1d5db;
            font-size: 0.875rem;
            font-weight: 500;
            padding-left: 0.75rem;
            padding-right: 0.75rem;
            padding-top: 0.375rem;
            padding-bottom: 0.375rem;
            border-bottom: 1px solid #374151;
        }

        .tool-code-block-wrapper {
            position: relative;
        }

        .tool-code-block {
            font-size: 0.875rem;
            overflow-x: auto;
            background-color: #1f2937;
            padding: 0.75rem;
            max-height: 24rem;
            margin: 0;
        }

        .tool-plain-text {
            font-size: 0.875rem;
            padding: 0.75rem;
            background-color: #1f2937;
            border-radius: 0.375rem;
            white-space: pre-wrap;
            max-height: 20rem;
            overflow: auto;
        }

        .tool-model-card {
            margin-bottom: 1rem;
            border-radius: 0.375rem;
            overflow: hidden;
            border: 1px solid #374151;
            background-color: rgba(31, 41, 55, 0.5);
        }

        .tool-model-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem;
            border-bottom: 1px solid #374151;
        }

        .tool-model-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tool-model-provider {
            font-size: 0.75rem;
            font-weight: 600;
        }

        .tool-model-name {
            font-size: 0.75rem;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            color: #d1d5db;
        }

        .tool-model-index {
            font-size: 0.75rem;
            color: #9ca3af;
        }

        .tool-model-content {
            padding: 0.75rem;
            background-color: rgba(31, 41, 55, 0.3);
        }

        .tool-model-text {
            white-space: pre-wrap;
            font-size: 0.875rem;
            color: #e5e7eb;
        }

        .tool-model-metrics {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.25rem;
            padding: 0.5rem;
            background-color: rgba(31, 41, 55, 0.7);
            border-top: 1px solid #374151;
        }

        .tool-metric {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            border-radius: 0.25rem;
            background-color: rgba(55, 65, 81, 0.3);
        }

        .tool-metric-icon {
            color: #d1d5db;
            opacity: 0.8;
            font-size: 0.875rem;
        }

        .tool-metric-value {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-weight: 500;
            font-size: 0.875rem;
        }

        .tool-metric-label {
            font-size: 0.75rem;
            color: #9ca3af;
        }

        .tool-stats-dashboard {
            border: 1px solid #374151;
            border-radius: 0.375rem;
            overflow: hidden;
            background-color: rgba(31, 41, 55, 0.3);
        }

        .tool-stats-header {
            background-image: linear-gradient(to right, rgba(30, 64, 175, 0.7), rgba(79, 70, 229, 0.7));
            padding: 0.5rem;
        }

        .tool-stats-title {
            font-size: 0.875rem;
            font-weight: 500;
            color: white;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tool-stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
            padding: 0.75rem;
        }

        @media (min-width: 640px) {
            .tool-stats-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (min-width: 768px) {
            .tool-stats-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        .tool-stat-card {
            background-color: rgba(55, 65, 81, 0.3);
            border-radius: 0.25rem;
            padding: 0.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .tool-stat-icon {
            color: #d1d5db;
            opacity: 0.7;
        }

        .tool-stat-value {
            font-weight: 500;
            font-size: 0.875rem;
        }

        .tool-stat-label {
            font-size: 0.75rem;
            color: #9ca3af;
        }

        .tool-comparison {
            border: 1px solid #374151;
            border-radius: 0.375rem;
            overflow: hidden;
            background-color: rgba(31, 41, 55, 0.3);
        }

        .tool-comparison-header {
            background-image: linear-gradient(to right, rgba(6, 95, 70, 0.7), rgba(13, 148, 136, 0.7));
            padding: 0.5rem;
        }

        .tool-comparison-title {
            font-size: 0.875rem;
            font-weight: 500;
            color: white;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tool-comparison-table-wrapper {
            padding: 0.5rem;
            overflow-x: auto;
        }

        .tool-comparison-table {
            width: 100%;
            font-size: 0.875rem;
            border-collapse: collapse;
        }

        .tool-comparison-table th {
            text-align: left;
            padding: 0.5rem;
            background-color: rgba(55, 65, 81, 0.4);
            border-bottom: 1px solid #4b5563;
        }

        .tool-comparison-table td {
            padding: 0.5rem;
            border-bottom: 1px solid rgba(55, 65, 81, 0.5);
        }

        .tool-comparison-table tr:hover {
            background-color: rgba(55, 65, 81, 0.2);
        }

        .tool-badge {
            display: inline-flex;
            align-items: center;
            padding-left: 0.5rem;
            padding-right: 0.5rem;
            padding-top: 0.125rem;
            padding-bottom: 0.125rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .tool-badge-success {
            background-color: rgba(6, 78, 59, 0.6);
            color: #a7f3d0;
            border: 1px solid rgba(5, 150, 105, 0.3);
        }

        .tool-badge-error {
            background-color: rgba(127, 29, 29, 0.6);
            color: #fecaca;
            border: 1px solid rgba(185, 28, 28, 0.3);
        }

        .tool-badge-warning {
            background-color: rgba(120, 53, 15, 0.6);
            color: #fde68a;
            border: 1px solid rgba(146, 64, 14, 0.3);
        }

        .tool-badge-info {
            background-color: rgba(30, 58, 138, 0.6);
            color: #bfdbfe;
            border: 1px solid rgba(37, 99, 235, 0.3);
        }

        .tool-badge-default {
            background-color: rgba(55, 65, 81, 0.6);
            color: #e5e7eb;
            border: 1px solid rgba(75, 85, 99, 0.3);
        }

        .tool-message {
            padding: 0.75rem;
            background-color: #1f2937;
            border-radius: 0.375rem;
            color: #e5e7eb;
        }

        .tool-content-title {
            font-size: 1.125rem;
            font-weight: 500;
            color: white;
            margin-bottom: 0.5rem;
        }

        .tool-section-title {
            font-size: 1rem;
            font-weight: 500;
            color: white;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }

        .copy-code-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: rgba(55, 65, 81, 0.8);
            color: #d1d5db;
            padding-left: 0.5rem;
            padding-right: 0.5rem;
            padding-top: 0.25rem;
            padding-bottom: 0.25rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            transition-property: opacity;
            transition-duration: 200ms;
            opacity: 0;
            border: 1px solid rgba(75, 85, 99, 0.5);
        }

        .copy-code-btn:hover {
            color: white;
            background-color: #374151;
        }

        .copy-code-btn:focus {
            opacity: 1;
            outline: none;
        }

        .tool-code-block-wrapper:hover .copy-code-btn {
            opacity: 1;
        }

        .tool-model-card[data-provider="openai"] .tool-model-header,
        .tool-model-card[data-provider="gpt"] .tool-model-header {
            background-image: linear-gradient(to right, rgba(6, 78, 59, 0.8), rgba(13, 148, 136, 0.8));
        }

        .tool-model-card[data-provider="anthropic"] .tool-model-header,
        .tool-model-card[data-provider="claude"] .tool-model-header {
            background-image: linear-gradient(to right, rgba(126, 34, 206, 0.8), rgba(217, 70, 239, 0.8));
        }

        .tool-model-card[data-provider="google"] .tool-model-header,
        .tool-model-card[data-provider="gemini"] .tool-model-header {
            background-image: linear-gradient(to right, rgba(30, 64, 175, 0.8), rgba(8, 145, 178, 0.8));
        }

        .tool-model-card[data-provider="deepseek"] .tool-model-header {
            background-image: linear-gradient(to right, rgba(146, 64, 14, 0.8), rgba(234, 88, 12, 0.8));
        }

        .tool-model-card[data-provider="mistral"] .tool-model-header {
            background-image: linear-gradient(to right, rgba(79, 70, 229, 0.8), rgba(139, 92, 246, 0.8));
        }

        .tool-model-card[data-provider="grok"] .tool-model-header {
            background-image: linear-gradient(to right, #1da1f2, #00acee);
        }

        .tool-model-card[data-provider="groq"] .tool-model-header {
            background-image: linear-gradient(to right, #ff4c4c, #ff7b7b);
        }

        .tool-model-card[data-provider="cerebras"] .tool-model-header {
            background-image: linear-gradient(to right, #808080, #a0a0a0);
        }

        .tool-model-card[data-provider="openrouter"] .tool-model-header {
            background-image: linear-gradient(to right, #4f46e5, #a855f7);
        }

        [data-theme] .tool-result-container,
        [data-theme] .tool-markdown,
        [data-theme] .tool-code-block,
        [data-theme] .tool-model-card,
        [data-theme] .tool-stats-dashboard,
        [data-theme] .tool-comparison {
            color-scheme: dark !important;
            color: #f3f4f6 !important;
        }

        [data-theme] .tool-result-content {
            background-color: #111827 !important;
        }

        .markdown-content * {
            color: white !important;
        }

        .markdown-content pre,
        .markdown-content code {
            background-color: rgba(0, 0, 0, 0.3) !important;
            color: white !important;
        }

        .markdown-content a {
            color: #38bdf8 !important;
        }

        .bg-gray-800 .prose * {
            color: white !important;
        }

        .bg-gray-800 p,
        .bg-gray-800 span,
        .bg-gray-800 div,
        .bg-gray-800 h1,
        .bg-gray-800 h2,
        .bg-gray-800 h3,
        .bg-gray-800 h4,
        .bg-gray-800 h5,
        .bg-gray-800 h6,
        .bg-gray-800 li {
            color: white !important;
        }

        .provider-result-card .card-body pre {
            background-color: transparent !important;
            color: #e5e7eb !important;
            padding: 0 !important;
            margin: 0 !important;
            border: none !important;
            border-radius: 0 !important;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace !important;
        }

        .provider-result-card .card-body pre code.hljs {
            background-color: transparent !important;
            color: inherit !important;
            padding: 0.75rem !important;
        }

        .provider-result-card .card-body p,
        .provider-result-card .card-body li,
        .provider-result-card .card-body span {
            color: #e5e7eb !important;
        }

        .chat-messages {
            /* Add this line */
            overflow-x: hidden;
        }

        /* General Tabulator styling for Agent Plan Table */
        #agent-current-plan-table .tabulator-header {
            background-color: hsl(var(--b2) / 0.7); /* Lighter header */
            border-bottom: 1px solid hsl(var(--b3) / 0.4);
            font-size: 0.7rem; /* Smaller header font */
            font-weight: 500;
        }
        #agent-current-plan-table .tabulator-col-title {
            padding: 0.3rem 0.5rem; /* Adjust header cell padding */
        }
        #agent-current-plan-table .tabulator-row .tabulator-cell {
            padding: 0.25rem 0.5rem; /* Adjust data cell padding */
            font-size: 0.7rem; /* Smaller cell font */
            line-height: 1.3;
            border-right: 1px solid hsl(var(--b1) / 0.5); /* Subtle vertical cell borders */
        }
        #agent-current-plan-table .tabulator-row .tabulator-cell:last-child {
            border-right: none;
        }
        #agent-current-plan-table .tabulator-placeholder {
            font-size: 0.75rem;
            padding: 1rem;
        }
        /* Specific styling for the description column in agent plan to allow wrapping */
        #agent-current-plan-table .tabulator-cell[tabulator-field="description"] {
            white-space: normal !important; /* Allow text wrapping */
            max-width: 300px; /* Or whatever max width fits your layout */
            overflow-wrap: break-word;
        }

        [x-cloak] {
            display: none;
        }
    </style>
</head>

<body class="h-screen flex flex-col bg-base-300/30" x-data="mcpClientUI" x-cloak
    @copy-clipboard.window="copyToClipboard($event.detail)">
    <div class="sidebar-overlay md:hidden" :class="{ 'open': isSidebarOpen }" @click="toggleSidebar(false)"></div>
    <!-- Header -->
    <header
        class="bg-base-100 shadow-md p-2 flex justify-between items-center flex-shrink-0 border-b border-base-300/50 h-14 z-20">
        <!-- Left Side -->
        <div class="flex items-center">
            <button class="btn btn-square btn-ghost btn-sm md:hidden mr-2" @click="toggleSidebar()">
                <i class="fas fa-bars"></i>
            </button>
            <h1 class="text-xl font-bold flex items-center gap-2 text-base-content">
                <i class="fas fa-plug text-primary animate-pulse"></i> Ultimate MCP Client
            </h1>
        </div>
        <!-- Right Side -->
        <div class="flex items-center gap-2 text-base-content/80">
            <!-- Tool Data Toggle -->
            <div class="form-control flex-row items-center gap-1 mr-2"
                data-tippy-content="Show/Hide Tool Result Messages">
                <span class="label-text text-xs mr-1">Tool Data</span>
                <input type="checkbox" class="toggle toggle-xs toggle-success" x-model="uiSettings.showToolDataMessages"
                    @change="saveUiSetting('showToolDataMessages', $event.target.checked)">
            </div>
            <!-- Server/Tool Count -->
            <div class="tooltip tooltip-bottom" data-tip="Servers">
                <i class="fas fa-server fa-fw"></i> <span x-text="`${connectedServersCount}/${servers.length}`"></span>
            </div>
            <div class="tooltip tooltip-bottom" data-tip="Tools">
                <i class="fas fa-tools fa-fw"></i> <span x-text="tools.length"></span>
            </div>

<!-- MODEL PICKER ----------------------------------------------------------->
<div x-data="{search:''}" class="dropdown dropdown-end">
    <!-- Trigger -->
    <label tabindex="0"
           class="btn btn-ghost btn-xs h-7 px-2 gap-1.5"
           data-tippy-content="Select Model">
      <i :class="getProviderIcon(currentModel) || 'fas fa-cogs'"
         class="fas fa-fw text-primary"></i>
      <span x-text="getFormattedModelName(currentModel)"
            class="text-xs font-medium text-base-content"></span>
      <i class="fas fa-chevron-down text-xs opacity-50"></i>
    </label>
  
    <!-- Sheet -->
    <div tabindex="0"
         class="dropdown-content w-[500px] mt-1 rounded-lg overflow-hidden
                bg-base-100 border border-base-300/30 shadow-lg z-[20] p-0">
  
      <!-- Search bar -->
      <div class="sticky top-0 z-20 bg-base-200 p-3 border-b border-base-300/50">
        <div class="relative">
          <input x-model="search" type="text" placeholder="Search modelsâ€¦"
                 class="input input-sm input-bordered w-full pr-8"
                 @keydown.stop>
          <button x-show="search"
                  @click="search=''"
                  class="absolute right-2 top-1/2 -translate-y-1/2
                         text-base-content/60 hover:text-error">
            <i class="fas fa-times"></i>
          </button>
        </div>
      </div>
  
      <!-- Providers / models -->
      <div class="max-h-[400px] overflow-y-auto">
        <template x-for="providerName in Object.keys(modelsByProvider).sort()" :key="providerName">
          <div x-data="{open:true}">
            <!-- Provider header -->
            <button @click="open=!open"
                    class="w-full flex items-center gap-2 px-4 py-2.5
                           bg-base-200 sticky top-0 z-10 border-b border-base-300/50
                           text-base-content">
              <i :class="getProviderIcon(providerName) || 'fas fa-server'"
                 class="fas text-lg"></i>
              <span class="flex-1 text-sm font-bold tracking-wide"
                    x-text="providerName.toUpperCase()"></span>
              <i :class="open ? 'fas fa-minus' : 'fas fa-plus'"
                 class="fas text-xs opacity-60"></i>
            </button>
  
            <!-- Model grid -->
            <div x-show="open" x-collapse class="grid grid-cols-2 gap-2 p-2">
              <template x-for="modelInfo in modelsByProvider[providerName]" :key="modelInfo.name">
                <button
                  x-show="!search
                          || modelInfo.name.toLowerCase().includes(search.toLowerCase())
                          || getFormattedModelName(modelInfo.name).toLowerCase().includes(search.toLowerCase())"
                  @click="setModel(modelInfo.name); if ($el.closest('.dropdown')) $el.closest('.dropdown').removeAttribute('open'); if (document.activeElement) document.activeElement.blur();"
                  :class="{
                    'bg-primary/10 text-primary shadow-sm font-medium':
                        modelInfo.name===currentModel,
                    'hover:bg-base-200 hover:shadow-sm':
                        modelInfo.name!==currentModel && modelInfo.is_active,
                    'opacity-50 cursor-not-allowed': !modelInfo.is_active
                  }"
                  class="flex items-center gap-2 py-2 px-3 rounded-md
                         transition-all text-base-content">
                  <span class="truncate text-sm flex-1"
                        x-text="getFormattedModelName(modelInfo.name)"></span>
                  <i x-show="modelInfo.name===currentModel"
                     class="fas fa-check text-primary text-xs"></i>
                  <span x-show="!modelInfo.is_active"
                        class="badge badge-xs badge-outline badge-warning">Inactive</span>
                </button>
              </template>
            </div>
          </div>
        </template>
      </div>
  
      <!-- Custom model -->
      <div class="bg-base-200 p-3 border-t border-base-300">
        <div class="relative">
          <input x-ref="custom"
                 :value="currentModel"
                 type="text"
                 placeholder="Enter custom model IDâ€¦"
                 class="input input-sm input-bordered w-full pr-8 text-base-content"
                 @keyup.enter="setCustomModel($refs.custom.value); if ($el.closest('.dropdown')) $el.closest('.dropdown').removeAttribute('open'); if (document.activeElement) document.activeElement.blur();"
          <button @click="setCustomModel($refs.custom.value); if ($el.closest('.dropdown')) $el.closest('.dropdown').removeAttribute('open'); if (document.activeElement) document.activeElement.blur();"
                  class="absolute right-2 top-1/2 -translate-y-1/2
                         text-base-content/50 hover:text-primary">
            <i class="fas fa-check text-xs"></i>
          </button>
        </div>
      </div>
    </div>
  </div>
  
            <!-- WS Status & Settings Icons -->
            <div class="tooltip tooltip-bottom" :data-tip="wsStatus">
                <i class="fas fa-circle text-xs transition-colors duration-500"
                    :class="{ 'text-success animate-pulse': wsConnected, 'text-warning': !wsConnected && wsConnecting, 'text-error': !wsConnected && !wsConnecting }"></i>
            </div>
            <div class="dropdown dropdown-end">
                <label tabindex="0" class="btn btn-xs btn-ghost px-1" data-tippy-content="Change Theme"> <i
                        class="fas fa-palette"></i> </label>
                <div tabindex="0"
                    class="dropdown-content z-[20] p-2 shadow bg-base-200 rounded-box w-64 max-h-96 overflow-y-auto">
                    <h3 class="font-medium text-sm mb-2">Select Theme</h3>
                    <div class="grid grid-cols-2 gap-3"> <!-- Increased gap slightly -->
                        <template x-for="theme in availableThemes" :key="theme">
                            <div class="theme-container cursor-pointer group" @click="setTheme(theme)"
                                @mouseenter="previewTheme(theme)" @mouseleave="resetPreviewTheme()">
                                <!-- Apply theme directly to preview, add height/border -->
                                <div :data-theme="theme"
                                    class="theme-preview p-2 border rounded-lg h-20 overflow-hidden transition-all duration-150 group-hover:shadow-md group-hover:border-primary/50"
                                    :class="{'!border-primary !border-2 shadow-lg': theme === currentTheme}">
                                    <!-- Sample content reflecting theme -->
                                    <div class="flex items-center justify-between mb-1">
                                        <span class="text-xs font-bold text-primary" x-text="theme"></span>
                                        <div class="badge badge-secondary badge-xs">Hi!</div>
                                    </div>
                                    <div class="space-y-1">
                                        <button class="btn btn-xs btn-primary w-full">Primary</button>
                                        <p class="text-xs text-base-content truncate">Sample text content.</p>
                                    </div>
                                </div>
                                <!-- Removed the separate theme name div below -->
                            </div>
                        </template>
                    </div>
                    <!-- The 'or' divider and custom theme <details> should be removed as per step 2 -->
                </div>
            </div>
            <button class="btn btn-xs btn-ghost px-1" @click="activeTab = 'config'" data-tippy-content="Settings"> <i
                    class="fas fa-cog"></i> </button>
            <button class="btn btn-xs btn-ghost px-1" @click="showKeyboardShortcutsModal = true"
                data-tippy-content="Keyboard Shortcuts"> <i class="fas fa-keyboard"></i> </button>
        </div>
    </header>
    <!-- Main Content Area -->
    <div class="flex flex-1 overflow-hidden">
        <aside class="sidebar bg-base-100 flex flex-col h-full border-r border-base-300/50 shadow-lg flex-shrink-0"
            :class="{'open': isSidebarOpen}">
            <!-- Tabs -->
            <div role="tablist" class="tabs tabs-bordered tabs-lg flex-shrink-0">
                <a role="tab" class="tab flex-1"
                    :class="{ 'tab-active font-semibold !border-primary text-primary': activeTab === 'servers' }"
                    @click="activeTab = 'servers'" data-tippy-content="Servers"><i class="fas fa-server fa-fw"></i></a>
                <a role="tab" class="tab flex-1"
                    :class="{ 'tab-active font-semibold !border-primary text-primary': activeTab === 'tools' }"
                    @click="activeTab = 'tools'" data-tippy-content="Capabilities"><i
                        class="fas fa-tools fa-fw"></i></a>
                <a role="tab" class="tab flex-1"
                    :class="{ 'tab-active font-semibold !border-primary text-primary': activeTab === 'conversation' }"
                    @click="activeTab = 'conversation'" data-tippy-content="Conversation"><i
                        class="fas fa-comments fa-fw"></i></a>
                <a role="tab" class="tab flex-1"
                    :class="{ 'tab-active font-semibold !border-primary text-primary': activeTab === 'config' }"
                    @click="activeTab = 'config'" data-tippy-content="Settings"><i class="fas fa-cog fa-fw"></i></a>
                <a role="tab" class="tab flex-1"
                    :class="{ 'tab-active font-semibold !border-primary text-primary': activeTab === 'dashboard' }"
                    @click="activeTab = 'dashboard'" data-tippy-content="Dashboard"><i
                        class="fas fa-chart-bar fa-fw"></i></a>
                <a role="tab" class="tab flex-1"
                    :class="{ 'tab-active font-semibold !border-primary text-primary': activeTab === 'agent' }"
                    @click="activeTab = 'agent'" data-tippy-content="Agent Control">
                    <i class="fas fa-robot fa-fw"></i></a>                        
            </div>
            <!-- Tab Content -->
            <div class="flex-1 p-3 overflow-y-auto space-y-5">
                <!-- Servers Tab -->
                <div x-show="activeTab === 'servers'" x-transition.opacity>
                    <!-- Header Section -->
                    <div class="flex justify-between items-center mb-3">
                        <h2 class="text-base font-semibold flex items-center"><i
                                class="fas fa-server mr-2 text-primary"></i>Servers</h2>
                        <!-- Wrap buttons in a div for grouping -->
                        <div class="flex gap-2">
                            <!-- Reload Button -->
                            <button class="btn btn-xs btn-outline btn-warning" @click="reloadAllServers()"
                                :disabled="isLoadingServers"
                                data-tippy-content="Disconnect & Reload All Configured Servers">
                                <i class="fas fa-sync" :class="{'fa-spin': isLoadingServers}"></i>
                                <!-- Icon spins when loading -->
                            </button>
                            <!-- Add Button -->
                            <button class="btn btn-xs btn-outline btn-primary" @click="showAddServerModal = true">
                                <i class="fas fa-plus mr-1"></i> Add
                            </button>
                        </div>
                    </div>
                    <!-- End Header Section -->
                    <!-- Server List Section -->
                    <div class="space-y-2.5">
                        <div x-show="isLoadingServers" class="text-center p-4"><span
                                class="loading loading-dots loading-md"></span></div>
                        <template x-for="server in servers" :key="server.name">
                            <div class="card card-compact bg-base-200/60 hover:bg-base-200 shadow-sm p-3 transition-all duration-150 ease-in-out sidebar-list-item"
                                :class="{'opacity-60': !server.enabled}">
                                <div class="flex justify-between items-center mb-1.5">
                                    <span class="font-semibold text-sm flex items-center gap-2">
                                        <i
                                            :class="server.type === 'stdio' ? 'fas fa-terminal text-accent' : 'fas fa-network-wired text-info'"></i>
                                        <span x-text="server.name"></span>
                                    </span>
                                    <div class="flex items-center gap-2">
                                        <!-- Server Status/Health Indicator -->
                                        <span class="tooltip tooltip-left text-xs"
                                            :data-tip="server.statusText || (server.isConnected ? 'Connected' : 'Disconnected')">
                                            <!-- Simple icon based on connectivity/loading -->
                                            <i :class="serverStatusIcon(server)" class="text-lg"></i>
                                        </span>
                                        <input type="checkbox" class="toggle toggle-xs toggle-success"
                                            title="Connect/Disconnect" :checked="server.isConnected"
                                            :disabled="server.isLoading || !server.enabled"
                                            @change="toggleServerConnection(server)"
                                            data-tippy-content="Connect/Disconnect" />
                                    </div>
                                </div>
                                <p class="text-xs text-base-content/60 mb-2 truncate" x-text="server.path"
                                    :data-tippy-content="server.path"></p>
                                <div class="flex justify-between items-center text-xs">
                                    <div class="flex items-center gap-2">
                                        <span data-tippy-content="Enable/Disable">
                                            <input type="checkbox" class="toggle toggle-xs" :checked="server.enabled"
                                                @change="toggleServerEnabled(server)" title="Enable/Disable" />
                                        </span>
                                        <button
                                            class="btn btn-xs btn-ghost text-info/70 hover:text-info hover:bg-info/10 p-1"
                                            @click="fetchServerDetails(server.name)" data-tippy-content="View Details">
                                            <i class="fas fa-info-circle fa-fw"></i>
                                        </button>
                                        <button
                                            class="btn btn-xs btn-ghost text-error/70 hover:text-error hover:bg-error/10 p-1"
                                            @click="removeServer(server.name)" data-tippy-content="Remove Server">
                                            <i class="fas fa-trash-alt fa-fw"></i>
                                        </button>
                                    </div>
                                    <!-- Display tool count (assuming tools are loaded) -->
                                    <span class="badge badge-outline badge-xs opacity-70"
                                        x-text="`${tools.filter(t => t.server_name === server.name).length} tools`"></span>
                                </div>
                            </div>
                        </template>
                        <div x-show="servers.length === 0 && !isLoadingServers"
                            class="text-center text-base-content/50 py-4 text-sm">No servers configured.</div>
                    </div>
                    <!-- End Server List Section -->
                    <!-- Discovery Section (INSIDE Servers Tab) -->
                    <div class="mt-6 border-t border-base-300/50 pt-4">
                        <div class="flex justify-between items-center mb-3">
                            <h3 class="text-base font-semibold flex items-center"><i
                                    class="fas fa-search-location mr-2 text-primary"></i>Discovery</h3>
                            <button class="btn btn-xs btn-outline btn-primary" @click="triggerDiscovery()"
                                :disabled="isLoadingDiscovery" :class="{'loading': isLoadingDiscovery}"
                                data-tippy-content="Scan filesystem, registry, mDNS, and ports based on settings">
                                <i class="fas fa-sync mr-1" x-show="!isLoadingDiscovery"></i> Scan Network
                            </button>
                        </div>
                        <div x-show="isLoadingDiscovery" class="text-center p-4"><span
                                class="loading loading-dots loading-sm"></span> Scanning...</div>
                        <div id="discovered-servers-table" class="mt-2 text-xs border border-base-300/30 rounded"
                            x-show="!isLoadingDiscovery && discoveredServers.length >= 0">
                            <!-- Tabulator populates this -->
                        </div>
                        <div x-show="!isLoadingDiscovery && discoveredServers.length < 0"
                            class="text-center text-base-content/40 text-xs py-3 italic">Click 'Scan Network' to find
                            servers.
                        </div>
                    </div>
                    <!-- End Discovery Section -->
                </div>
                <!-- End Servers Tab -->
                <!-- Tools Tab (Capabilities - Grouped Layout) -->
                <div x-show="activeTab === 'tools'" x-transition.opacity class="space-y-4">
                    <!-- Tab Header -->
                    <div class="flex justify-between items-center">
                        <h2 class="text-base font-semibold flex items-center"><i
                                class="fas fa-puzzle-piece mr-2 text-primary"></i>Capabilities</h2>
                        <span class="text-xs" x-text="`(${totalCapabilities} total)`"></span>
                    </div>
                    <!-- Favorites Section -->
                    <div class="favorites-container" x-show="favoriteTools.length > 0">
                        <div class="flex justify-between items-center mb-2">
                            <h3 class="text-sm font-semibold"><i class="fas fa-star text-warning mr-1"></i> Favorites
                            </h3>
                            <button class="btn btn-xs btn-ghost" @click="clearFavorites()"
                                x-show="favoriteTools.length > 0" data-tippy-content="Clear All Favorites">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                            <template x-for="tool in favoriteTools" :key="tool.name">
                                <div class="tool-card">
                                    <div class="tool-card-header">
                                        <div>
                                            <div class="tool-card-name" x-text="tool.shortName"></div>
                                            <div class="tool-card-server" x-text="tool.server_name"></div>
                                        </div>
                                        <div class="tool-card-actions">
                                            <button class="btn btn-xs btn-ghost" @click="toggleFavoriteTool(tool)">
                                                <i class="fas fa-star text-warning"></i>
                                            </button>
                                            <button class="btn btn-xs btn-ghost" @click="showToolDetails(tool)">
                                                <i class="fas fa-play"></i>
                                            </button>
                                        </div>
                                    </div>
                                    <p class="text-xs truncate" x-text="tool.description"></p>
                                </div>
                            </template>
                        </div>
                    </div>
                    <!-- Recent Tools Section -->
                    <div class="recent-tools-container" x-show="recentTools.length > 0">
                        <div class="flex justify-between items-center mb-2">
                            <h3 class="text-sm font-semibold"><i class="fas fa-history text-info mr-1"></i> Recently
                                Used
                            </h3>
                            <button class="btn btn-xs btn-ghost" @click="clearRecentTools()"
                                x-show="recentTools.length > 0" data-tippy-content="Clear Recent Tools">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                            <template x-for="tool in recentTools" :key="tool.name">
                                <div class="tool-card">
                                    <div class="tool-card-header">
                                        <div>
                                            <div class="tool-card-name" x-text="tool.shortName"></div>
                                            <div class="tool-card-server" x-text="tool.server_name"></div>
                                        </div>
                                        <div class="tool-card-actions">
                                            <button class="btn btn-xs btn-ghost" @click="toggleFavoriteTool(tool)">
                                                <i class="fas"
                                                    :class="isFavoriteTool(tool) ? 'fa-star text-warning' : 'fa-star text-base-content/30'"></i>
                                            </button>
                                            <button class="btn btn-xs btn-ghost" @click="showToolDetails(tool)">
                                                <i class="fas fa-play"></i>
                                            </button>
                                        </div>
                                    </div>
                                    <p class="text-xs opacity-70 truncate" x-text="tool.description"></p>
                                </div>
                            </template>
                        </div>
                    </div>
                    <!-- Filter Input -->
                    <div class="sticky top-0 bg-base-100 py-2 z-10 -mt-2 -mx-3 px-3">
                        <div class="relative">
                            <input type="text" placeholder="Filter by server, name, or description..."
                                class="input input-sm input-bordered w-full pr-8 text-xs"
                                x-model.debounce.300ms="capabilitySearchTerm">
                            <i class="fas fa-search absolute right-3 top-1/2 -translate-y-1/2 text-base-content/40"></i>
                        </div>
                    </div>
                    <!-- Loading Indicator -->
                    <div x-show="isLoadingTools" class="text-center p-4"><span
                            class="loading loading-dots loading-md"></span> Loading Capabilities...</div>
                    <!-- Server Group Iteration -->
                    <div x-show="!isLoadingTools && filteredServerCapabilities.length > 0" class="space-y-4">
                        <template x-for="serverGroup in filteredServerCapabilities" :key="serverGroup.serverName">
                            <div class="card card-compact bg-base-200/50 border border-base-300/30 shadow-sm">
                                <div class="card-body p-3">
                                    <!-- Server Header -->
                                    <div class="flex items-center gap-2 mb-2 border-b border-base-300/20 pb-1.5">
                                        <i :class="serverStatusIcon(getServerByName(serverGroup.serverName))"
                                            class="text-lg"
                                            :data-tippy-content="getServerByName(serverGroup.serverName)?.isConnected ? 'Connected' : 'Disconnected'"></i>
                                        <h3 class="card-title text-sm font-semibold" x-text="serverGroup.serverName">
                                        </h3>
                                        <span class="text-xs opacity-60">
                                            (<span x-text="serverGroup.tools.length"></span> <i
                                                class="fas fa-hammer fa-xs"></i>,
                                            <span x-text="serverGroup.resources.length"></span> <i
                                                class="fas fa-book fa-xs"></i>,
                                            <span x-text="serverGroup.prompts.length"></span> <i
                                                class="fas fa-lightbulb fa-xs"></i>)
                                        </span>
                                    </div>
                                    <!-- Tools Section -->
                                    <template x-if="serverGroup.tools.length > 0">
                                        <div class="collapse collapse-arrow bg-base-100/50 border border-base-300/20 rounded-md text-xs"
                                            x-data="{ open: true }">
                                            <input type="checkbox" x-model="open" class="!min-h-0 peer" />
                                            <div class="collapse-title text-xs font-medium min-h-0 py-1.5 px-3 peer-checked:bg-base-300/10 peer-checked:border-b peer-checked:border-base-300/30 cursor-pointer"
                                                @click.prevent="open = !open">
                                                <i class="fas fa-hammer fa-fw mr-1 opacity-70"></i> Tools (<span
                                                    x-text="serverGroup.tools.length"></span>)
                                            </div>
                                            <div class="collapse-content !p-0">
                                                <div class="p-2 space-y-1.5 max-h-60 overflow-y-auto">
                                                    <template x-for="tool in serverGroup.tools" :key="tool.name">
                                                        <div class="p-1.5 bg-base-100 hover:bg-primary/10 rounded cursor-pointer transition-colors sidebar-list-item"
                                                            @click="showToolDetails(tool)">
                                                            <div class="flex justify-between items-center">
                                                                <span class="font-medium truncate text-xs"
                                                                    x-text="tool.shortName"
                                                                    :data-tippy-content="tool.name"></span>
                                                                <i class="fas fa-info-circle text-info/60 hover:text-info text-xs"
                                                                    data-tippy-content="View Details & Execute"></i>
                                                            </div>
                                                            <p class="text-xs text-base-content/60 truncate mt-0.5"
                                                                x-text="tool.description"
                                                                :data-tippy-content="tool.description || 'No description'">
                                                            </p>
                                                        </div>
                                                    </template>
                                                </div>
                                            </div>
                                        </div>
                                    </template>
                                    <!-- Resources Section -->
                                    <template x-if="serverGroup.resources.length > 0">
                                        <div class="collapse collapse-arrow bg-base-100/50 border border-base-300/20 rounded-md text-xs"
                                            x-data="{ open: false }">
                                            <input type="checkbox" x-model="open" class="!min-h-0 peer" />
                                            <div class="collapse-title text-xs font-medium min-h-0 py-1.5 px-3 peer-checked:bg-base-300/10 peer-checked:border-b peer-checked:border-base-300/30 cursor-pointer"
                                                @click.prevent="open = !open">
                                                <i class="fas fa-book fa-fw mr-1 opacity-70"></i> Resources (<span
                                                    x-text="serverGroup.resources.length"></span>)
                                            </div>
                                            <div class="collapse-content !p-0">
                                                <div class="p-2 space-y-1.5 max-h-40 overflow-y-auto">
                                                    <template x-for="resource in serverGroup.resources"
                                                        :key="resource.name">
                                                        <div class="p-1.5 bg-base-100 hover:bg-secondary/10 rounded sidebar-list-item"
                                                            :data-tippy-content="resource.description || 'No description'">
                                                            <div class="font-medium truncate text-xs"
                                                                x-text="resource.shortName"></div>
                                                            <p class="text-xs text-info truncate mt-0.5"
                                                                x-text="resource.template"
                                                                :data-tippy-content="'Template/URI: ' + resource.template">
                                                            </p>
                                                        </div>
                                                    </template>
                                                </div>
                                            </div>
                                        </div>
                                    </template>
                                    <!-- Prompts Section -->
                                    <template x-if="serverGroup.prompts.length > 0">
                                        <div class="collapse collapse-arrow bg-base-100/50 border border-base-300/20 rounded-md text-xs"
                                            x-data="{ open: false }">
                                            <input type="checkbox" x-model="open" class="!min-h-0 peer" />
                                            <div class="collapse-title text-xs font-medium min-h-0 py-1.5 px-3 peer-checked:bg-base-300/10 peer-checked:border-b peer-checked:border-base-300/30 cursor-pointer"
                                                @click.prevent="open = !open">
                                                <i class="fas fa-lightbulb fa-fw mr-1 opacity-70"></i> Prompts (<span
                                                    x-text="serverGroup.prompts.length"></span>)
                                            </div>
                                            <div class="collapse-content !p-0">
                                                <div class="p-2 space-y-1.5 max-h-40 overflow-y-auto">
                                                    <template x-for="prompt in serverGroup.prompts" :key="prompt.name">
                                                        <div class="p-1.5 bg-base-100 hover:bg-accent/10 rounded cursor-pointer transition-colors sidebar-list-item"
                                                            @click="applyPrompt(prompt.name)"
                                                            data-tippy-content="Apply Prompt">
                                                            <div class="font-medium truncate text-xs"
                                                                x-text="prompt.shortName"></div>
                                                            <p class="text-xs text-base-content/60 truncate mt-0.5"
                                                                x-text="prompt.description"
                                                                :data-tippy-content="prompt.description || 'No description'">
                                                            </p>
                                                        </div>
                                                    </template>
                                                </div>
                                            </div>
                                        </div>
                                    </template>
                                </div>
                                <!-- End card-body -->
                            </div>
                            <!-- End server card -->
                        </template>
                    </div>
                    <!-- No Results Message -->
                    <div x-show="!isLoadingTools && filteredServerCapabilities.length === 0"
                        class="text-center text-base-content/50 py-6 text-sm">
                        <span x-show="!capabilitySearchTerm">No capabilities found.</span>
                        <span x-show="capabilitySearchTerm">No capabilities match filter.</span>
                    </div>
                </div>
                <!-- END Tools Tab -->
                <!-- Conversation Tab -->
                <div x-show="activeTab === 'conversation'" x-transition.opacity>
                    <h2 class="text-base font-semibold flex items-center">
                        <i class="fas fa-comments mr-2 text-primary"></i>Conversation
                    </h2>
                    <!-- View toggle buttons for conversation manager -->
                    <div class="flex gap-1 my-2">
                        <!-- Added margin -->
                        <button class="btn btn-xs btn-ghost" :class="{'btn-active': conversationView === 'branches'}"
                            @click="conversationView = 'branches'" data-tippy-content="Branch View">
                            <i class="fas fa-code-branch"></i>
                        </button>
                        <button class="btn btn-xs btn-ghost" :class="{'btn-active': conversationView === 'tags'}"
                            @click="conversationView = 'tags'" data-tippy-content="Tag View">
                            <i class="fas fa-tags"></i>
                        </button>
                        <button class="btn btn-xs btn-ghost" :class="{'btn-active': conversationView === 'search'}"
                            @click="conversationView = 'search'" data-tippy-content="Search">
                            <i class="fas fa-search"></i>
                        </button>
                        <button class="btn btn-xs btn-ghost" @click="openMessageBookmarks()"
                            data-tippy-content="Bookmarks">
                            <i class="fas fa-bookmark"></i>
                        </button>
                    </div>
                    <div class="space-y-2.5">
                        <div x-show="conversationView === 'branches'" class="space-y-2">
                            <button class="btn btn-sm btn-block btn-outline" @click="forkConversation"
                                :disabled="isLoading || currentConversation.length === 0"><i
                                    class="fas fa-code-branch mr-1.5"></i> Fork Branch</button>
                            <button class="btn btn-sm btn-block btn-outline" @click="optimizeConversation"
                                :disabled="isLoading || currentConversation.length < 2"><i
                                    class="fas fa-magic mr-1.5"></i>
                                Optimize Context</button>
                            <button class="btn btn-sm btn-block btn-outline btn-warning" @click="clearConversation"
                                :disabled="isLoading"><i class="fas fa-eraser mr-1.5"></i> Clear Context</button>
                            <div class="flex gap-2">
                                <div class="dropdown dropdown-bottom flex-1">
                                    <button class="btn btn-sm w-full btn-outline btn-info"
                                        :disabled="isLoading || !currentNodeId || (currentNodeId === 'root' && currentConversation.length === 0)"
                                        data-tippy-content="Export current branch">
                                        <i class="fas fa-file-export mr-1.5"></i> Export
                                    </button>
                                    <ul tabindex="0"
                                        class="dropdown-content z-[20] menu p-1 shadow bg-base-200 rounded-box w-52">
                                        <li><a @click="exportConversationAPI('json')">JSON Format</a></li>
                                        <li><a @click="exportConversationAPI('markdown')">Markdown Format</a></li>
                                        <li><a @click="exportConversationAPI('pdf')">PDF Format</a></li>
                                    </ul>
                                </div>
                                <label class="btn btn-sm flex-1 btn-outline btn-accent"
                                    :class="{'loading': isLoadingImport, 'btn-disabled': isLoadingImport || isLoading}"
                                    data-tippy-content="Import conversation as a new branch under current node">
                                    <i class="fas fa-file-import mr-1.5" x-show="!isLoadingImport"></i> Import
                                    <input type="file" class="hidden" accept=".json"
                                        @change="importConversationAPI($event.target.files[0])"
                                        :disabled="isLoadingImport || isLoading">
                                </label>
                            </div>
                            <!-- Branch Management -->
                            <h3 class="text-sm font-semibold pt-3 mb-1 border-t border-base-300/50 opacity-80"><i
                                    class="fas fa-network-wired mr-1.5"></i> Branches</h3>
                            <div id="branch-list" class="max-h-56 overflow-y-auto p-1 bg-base-200/60 rounded text-xs">
                                <ul class="list-none space-y-1">
                                    <!-- Recursive template for tree structure -->
                                    <template x-teleport="#branch-node-template-container">
                                        <div id="branch-node-template">
                                            <li x-data="{ open: $el.dataset.nodeid === $store.conversation.currentNodeId || ($el.dataset.nodeid === 'root' && $store.conversation.conversationNodes.length > 1) }"
                                                :style="{'--indent-level': ($el.dataset.level || 0) * 1 + 'em'}">
                                                <div @click="checkoutBranch($el.dataset.nodeid)"
                                                    class="flex items-center gap-1 cursor-pointer hover:bg-base-300/80 rounded p-1 group"
                                                    :class="{ 'bg-primary/10 text-primary font-semibold': $el.dataset.nodeid === $store.conversation.currentNodeId }">
                                                    <!-- Toggle Icon -->
                                                    <i x-show="$el.dataset.haschildren === 'true'"
                                                        class="fas fa-fw text-xs opacity-50 cursor-pointer hover:opacity-100 w-4 text-center"
                                                        :class="open ? 'fa-chevron-down' : 'fa-chevron-right'"
                                                        @click.stop="open = !open"></i>
                                                    <i x-show="$el.dataset.haschildren !== 'true'"
                                                        class="fas fa-fw fa-circle-dot text-xs w-4 opacity-40"></i>
                                                    <!-- Node Icon & Name -->
                                                    <i class="fas fa-code-branch text-xs opacity-60"
                                                        x-show="$el.dataset.level > 0"></i>
                                                    <span class="truncate"
                                                        x-text="$el.dataset.nodename || 'Unnamed'"></span>
                                                    <span class="text-base-content/50 ml-1"
                                                        x-text="$el.dataset.nodeid ? ' (...'+($el.dataset.nodeid.slice(-5))+')' : ''"></span>
                                                    <!-- Action icons -->
                                                    <div class="ml-auto flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity"
                                                        x-show="$el.dataset.nodeid !== 'root'">
                                                        <i class="fas fa-compress-alt text-xs opacity-50 hover:opacity-100 cursor-pointer"
                                                            @click.stop="showBranchComparison($el.dataset.nodeid)"
                                                            data-tippy-content="Compare with current branch"></i>
                                                        <i class="fas fa-pencil-alt text-xs opacity-50 hover:opacity-100 cursor-pointer"
                                                            @click.stop="renameBranch($el.dataset.nodeid, $el.dataset.nodename)"
                                                            data-tippy-content="Rename branch"></i>
                                                    </div>
                                                </div>
                                                <!-- Children -->
                                                <ul x-show="open" x-transition.opacity
                                                    class="mt-1 space-y-1 list-none pl-0">
                                                    <template
                                                        x-for="childId in JSON.parse($el.dataset.children || '[]')"
                                                        :key="childId">
                                                        <li
                                                            x-html="renderBranchNode(childId, parseInt($el.dataset.level || 0) + 1)">
                                                        </li>
                                                    </template>
                                                </ul>
                                            </li>
                                        </div>
                                    </template>
                                    <!-- Initial Root Render -->
                                    <li x-html="renderBranchNode('root', 0)"></li>
                                </ul>
                                <!-- No branches message -->
                                <div x-show="$store.conversation.conversationNodes.length <= 1 || ($store.conversation.conversationNodes.length === 1 && $store.conversation.conversationNodes[0].id === 'root' && !$store.conversation.conversationNodes[0].childrenIds.length)"
                                    class="text-center text-base-content/50 py-2 text-xs">No branches yet. Fork to
                                    create
                                    more.
                                </div>
                            </div>
                        </div>
                        <!-- Tag Management Section -->
                        <div x-show="conversationView === 'tags'" class="space-y-2">
                            <button class="btn btn-sm btn-block btn-outline" @click="showAddTagModal = true">
                                <i class="fas fa-plus mr-1.5"></i> Add New Tag
                            </button>
                            <div class="mt-3">
                                <h4 class="text-sm font-medium mb-2">Available Tags</h4>
                                <div class="space-y-1.5">
                                    <template x-for="tag in allTags" :key="tag.id">
                                        <div class="conversation-tag"
                                            :style="`background-color: ${tag.color}20; color: ${tag.color}`"
                                            @click="addTagToConversation(tag.id)">
                                            <i class="fas fa-tag"></i>
                                            <span x-text="tag.name"></span>
                                        </div>
                                    </template>
                                </div>
                            </div>
                            <div class="mt-3" x-show="conversationTags.length > 0">
                                <h4 class="text-sm font-medium mb-2">Tags for This Conversation</h4>
                                <div class="space-y-1.5">
                                    <template x-for="tag in conversationTags" :key="tag.id">
                                        <div class="conversation-tag"
                                            :style="`background-color: ${tag.color}20; color: ${tag.color}`">
                                            <i class="fas fa-tag"></i>
                                            <span x-text="tag.name"></span>
                                            <i class="fas fa-times ml-1 cursor-pointer"
                                                @click="removeTagFromConversation(tag.id)"></i>
                                        </div>
                                    </template>
                                </div>
                            </div>
                        </div>
                        <!-- Search Section -->
                        <div x-show="conversationView === 'search'" class="space-y-2">
                            <div class="form-control">
                                <div class="flex items-center gap-2">
                                    <input type="text" placeholder="Search all conversations..."
                                        class="input input-sm input-bordered flex-1" x-model="globalSearchQuery"
                                        @keyup.enter="performGlobalSearch()">
                                    <button class="btn btn-sm btn-primary" @click="performGlobalSearch()"
                                        :disabled="!globalSearchQuery.trim() || isSearching">
                                        <i class="fas fa-search" x-show="!isSearching"></i>
                                        <span class="loading loading-spinner loading-xs" x-show="isSearching"></span>
                                    </button>
                                </div>
                                <!-- Search options -->
                                <div class="flex flex-wrap gap-x-3 gap-y-1 mt-2 text-xs">
                                    <label class="flex items-center gap-1 cursor-pointer">
                                        <input type="checkbox" class="checkbox checkbox-xs"
                                            x-model="searchOptions.caseSensitive">
                                        <span>Case Sensitive</span>
                                    </label>
                                    <label class="flex items-center gap-1 cursor-pointer">
                                        <input type="checkbox" class="checkbox checkbox-xs"
                                            x-model="searchOptions.wholeWord">
                                        <span>Whole Word</span>
                                    </label>
                                    <label class="flex items-center gap-1 cursor-pointer">
                                        <input type="checkbox" class="checkbox checkbox-xs"
                                            x-model="searchOptions.includeSystem">
                                        <span>Include System</span>
                                    </label>
                                </div>
                            </div>
                            <!-- Search results -->
                            <div class="mt-3">
                                <div x-show="isSearching" class="text-center p-3">
                                    <span class="loading loading-dots loading-sm"></span>
                                    <p class="text-xs mt-1">Searching conversations...</p>
                                </div>
                                <div x-show="!isSearching && searchPerformed && searchResults.length === 0"
                                    class="text-center p-3 text-sm opacity-70">
                                    No results found for your search.
                                </div>
                                <div x-show="!isSearching && searchResults.length > 0"
                                    class="space-y-2 max-h-64 overflow-y-auto">
                                    <h4 class="text-sm font-medium"><i class="fas fa-search mr-1.5"></i>
                                        Search Results (<span x-text="searchResults.length"></span>)
                                    </h4>
                                    <template x-for="result in searchResults" :key="result.messageId">
                                        <div class="bg-base-200 p-2 rounded hover:bg-base-300 cursor-pointer transition-colors"
                                            @click="checkoutBranchAndScrollToMessage(result.nodeId, result.timestamp)">
                                            <div class="flex items-center justify-between text-xs mb-1">
                                                <div>
                                                    <span class="opacity-70"
                                                        x-text="formatTimestamp(result.timestamp)"></span>
                                                    <span class="badge badge-xs" :class="{
                                             'badge-primary': result.role === 'user',
                                             'badge-secondary': result.role === 'assistant',
                                             'badge-neutral': result.role === 'system'
                                             }" x-text="result.role"></span>
                                                </div>
                                                <span class="text-xs opacity-60" x-text="result.nodeName"></span>
                                            </div>
                                            <div class="text-xs"
                                                x-html="highlightSearchResult(result.content, globalSearchQuery)">
                                            </div>
                                        </div>
                                    </template>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- End Conversation Tab -->
                <!-- Config Tab -->
                <div x-show="activeTab === 'config'" x-transition.opacity>
                    <h2 class="text-base font-semibold mb-3 flex items-center"><i
                            class="fas fa-cog mr-2 text-primary"></i>Settings</h2>
                    <!-- Provider API Keys & URLs Section -->
                    <details class="mb-4 border border-base-300/20 rounded-md" open>
                        <summary
                            class="cursor-pointer select-none p-2 bg-base-200 rounded-t-md font-medium text-sm flex items-center gap-2">
                            <i class="fas fa-key"></i> Provider API Keys & Base URLs
                        </summary>
                        <div class="p-3 space-y-3 text-sm bg-base-100/50 rounded-b-md">
                            <!-- Anthropic -->
                            <div class="grid grid-cols-1 gap-2">
                                <div class="form-control">
                                    <label class="label py-1"><span class="label-text text-xs font-medium"
                                            data-tippy-content="Stored securely in your .env file or environment."><i
                                                class="fab fa-autoprefixer mr-1 text-purple-500"></i> Anthropic API
                                            Key</span></label>
                                    <input type="password" placeholder="sk-ant-..."
                                        class="input input-bordered input-sm" x-model="config.anthropicApiKey"
                                        @input.debounce.500ms="saveConfigField('anthropicApiKey', $event.target.value)">
                                </div>
                            </div>
                            <!-- OpenAI -->
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-2 border-t border-base-300/20 pt-2">
                                <div class="form-control">
                                    <label class="label py-1"><span class="label-text text-xs font-medium"><i
                                                class="fas fa-brain mr-1 text-green-500"></i> OpenAI API
                                            Key</span></label>
                                    <input type="password" placeholder="sk-..." class="input input-bordered input-sm"
                                        x-model="config.openaiApiKey"
                                        @input.debounce.500ms="saveConfigField('openaiApiKey', $event.target.value)">
                                </div>
                                <div class="form-control">
                                    <label class="label py-1"><span class="label-text text-xs font-medium">OpenAI Base
                                            URL (Optional)</span></label>
                                    <input type="url" placeholder="https://api.openai.com/v1"
                                        class="input input-bordered input-sm" x-model="config.openaiBaseUrl"
                                        @input.debounce.500ms="saveConfigField('openaiBaseUrl', $event.target.value)">
                                </div>
                            </div>
                            <!-- Gemini -->
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-2 border-t border-base-300/20 pt-2">
                                <div class="form-control">
                                    <label class="label py-1"><span class="label-text text-xs font-medium"><i
                                                class="fab fa-google mr-1 text-blue-500"></i> Gemini API
                                            Key</span></label>
                                    <input type="password" placeholder="AIza..." class="input input-bordered input-sm"
                                        x-model="config.geminiApiKey"
                                        @input.debounce.500ms="saveConfigField('geminiApiKey', $event.target.value)">
                                </div>
                                <div class="form-control">
                                    <label class="label py-1"><span class="label-text text-xs font-medium">Gemini Base
                                            URL (OpenAI Compat)</span></label>
                                    <input type="url"
                                        placeholder="https://generativelanguage.googleapis.com/v1beta/openai/"
                                        class="input input-bordered input-sm" x-model="config.geminiBaseUrl"
                                        @input.debounce.500ms="saveConfigField('geminiBaseUrl', $event.target.value)">
                                </div>
                            </div>
                            <!-- Grok -->
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-2 border-t border-base-300/20 pt-2">
                                <div class="form-control">
                                    <label class="label py-1"><span class="label-text text-xs font-medium"><i
                                                class="fas fa-bolt mr-1 text-blue-400"></i> Grok API Key</span></label>
                                    <input type="password" placeholder="gsk_..." class="input input-bordered input-sm"
                                        x-model="config.grokApiKey"
                                        @input.debounce.500ms="saveConfigField('grokApiKey', $event.target.value)">
                                </div>
                                <div class="form-control">
                                    <label class="label py-1"><span class="label-text text-xs font-medium">Grok Base
                                            URL</span></label>
                                    <input type="url" placeholder="https://api.x.ai/v1"
                                        class="input input-bordered input-sm" x-model="config.grokBaseUrl"
                                        @input.debounce.500ms="saveConfigField('grokBaseUrl', $event.target.value)">
                                </div>
                            </div>
                            <!-- DeepSeek -->
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-2 border-t border-base-300/20 pt-2">
                                <div class="form-control">
                                    <label class="label py-1"><span class="label-text text-xs font-medium"><i
                                                class="fas fa-water mr-1 text-cyan-600"></i> DeepSeek API
                                            Key</span></label>
                                    <input type="password" placeholder="sk-..." class="input input-bordered input-sm"
                                        x-model="config.deepseekApiKey"
                                        @input.debounce.500ms="saveConfigField('deepseekApiKey', $event.target.value)">
                                </div>
                                <div class="form-control">
                                    <label class="label py-1"><span class="label-text text-xs font-medium">DeepSeek Base
                                            URL</span></label>
                                    <input type="url" placeholder="https://api.deepseek.com/v1"
                                        class="input input-bordered input-sm" x-model="config.deepseekBaseUrl"
                                        @input.debounce.500ms="saveConfigField('deepseekBaseUrl', $event.target.value)">
                                </div>
                            </div>
                            <!-- Mistral -->
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-2 border-t border-base-300/20 pt-2">
                                <div class="form-control">
                                    <label class="label py-1"><span class="label-text text-xs font-medium"><i
                                                class="fas fa-wind mr-1 text-indigo-400"></i> Mistral API
                                            Key</span></label>
                                    <input type="password" placeholder="..." class="input input-bordered input-sm"
                                        x-model="config.mistralApiKey"
                                        @input.debounce.500ms="saveConfigField('mistralApiKey', $event.target.value)">
                                </div>
                                <div class="form-control">
                                    <label class="label py-1"><span class="label-text text-xs font-medium">Mistral Base
                                            URL</span></label>
                                    <input type="url" placeholder="https://api.mistral.ai/v1"
                                        class="input input-bordered input-sm" x-model="config.mistralBaseUrl"
                                        @input.debounce.500ms="saveConfigField('mistralBaseUrl', $event.target.value)">
                                </div>
                            </div>
                            <!-- Groq -->
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-2 border-t border-base-300/20 pt-2">
                                <div class="form-control">
                                    <label class="label py-1"><span class="label-text text-xs font-medium"><i
                                                class="fas fa-rocket mr-1 text-red-500"></i> Groq API Key</span></label>
                                    <input type="password" placeholder="gsk_..." class="input input-bordered input-sm"
                                        x-model="config.groqApiKey"
                                        @input.debounce.500ms="saveConfigField('groqApiKey', $event.target.value)">
                                </div>
                                <div class="form-control">
                                    <label class="label py-1"><span class="label-text text-xs font-medium">Groq Base
                                            URL</span></label>
                                    <input type="url" placeholder="https://api.groq.com/openai/v1"
                                        class="input input-bordered input-sm" x-model="config.groqBaseUrl"
                                        @input.debounce.500ms="saveConfigField('groqBaseUrl', $event.target.value)">
                                </div>
                            </div>
                            <!-- Cerebras -->
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-2 border-t border-base-300/20 pt-2">
                                <div class="form-control">
                                    <label class="label py-1"><span class="label-text text-xs font-medium"><i
                                                class="fas fa-microchip mr-1 text-gray-500"></i> Cerebras API
                                            Key</span></label>
                                    <input type="password" placeholder="..." class="input input-bordered input-sm"
                                        x-model="config.cerebrasApiKey"
                                        @input.debounce.500ms="saveConfigField('cerebrasApiKey', $event.target.value)">
                                </div>
                                <div class="form-control">
                                    <label class="label py-1"><span class="label-text text-xs font-medium">Cerebras Base
                                            URL</span></label>
                                    <input type="url" placeholder="https://api.cerebras.ai/v1"
                                        class="input input-bordered input-sm" x-model="config.cerebrasBaseUrl"
                                        @input.debounce.500ms="saveConfigField('cerebrasBaseUrl', $event.target.value)">
                                </div>
                            </div>
                            <!-- OpenRouter -->
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-2 border-t border-base-300/20 pt-2">
                                <div class="form-control">
                                    <label class="label py-1"><span class="label-text text-xs font-medium"><i
                                                class="fas fa-route mr-1 text-purple-500"></i> OpenRouter API
                                            Key</span></label>
                                    <input type="password" placeholder="sk-or-..." class="input input-bordered input-sm"
                                        x-model="config.openrouterApiKey"
                                        @input.debounce.500ms="saveConfigField('openrouterApiKey', $event.target.value)">
                                </div>
                                <div class="form-control">
                                    <label class="label py-1"><span class="label-text text-xs font-medium">OpenRouter
                                            Base URL</span></label>
                                    <input type="url" placeholder="https://openrouter.ai/api/v1"
                                        class="input input-bordered input-sm" x-model="config.openrouterBaseUrl"
                                        @input.debounce.500ms="saveConfigField('openrouterBaseUrl', $event.target.value)">
                                </div>
                            </div>
                            <p class="text-xs text-base-content/60 mt-2">Note: API Keys are stored locally in your
                                `.env` file (if found) or environment variables. Setting them here only affects the
                                current session and is not saved persistently.
                            </p>
                        </div>
                    </details>
                    <!-- LLM Settings Section -->
                    <details class="mb-4 border border-base-300/20 rounded-md" open>
                        <summary
                            class="cursor-pointer select-none p-2 bg-base-200 rounded-t-md font-medium text-sm flex items-center gap-2">
                            <i class="fas fa-brain"></i> LLM Settings
                        </summary>
                        <div class="p-3 space-y-3 text-sm bg-base-100/50 rounded-b-md">
                            <div class="form-control">
                                <label class="label py-1"><span class="label-text text-xs font-medium"
                                        data-tippy-content="Default model for new conversations">Default
                                        Model</span></label>
                                <input type="text" placeholder="e.g., gpt-4o-mini, claude-3-haiku..."
                                    class="input input-bordered input-sm" x-model="config.defaultModel"
                                    @change="saveConfigField('defaultModel', $event.target.value); setModel($event.target.value)">
                            </div>
                            <div class="form-control">
                                <label class="label py-1"><span class="label-text text-xs font-medium"
                                        data-tippy-content="Max tokens for the response">Max Tokens</span></label>
                                <input type="number" class="input input-bordered input-sm w-24"
                                    x-model.number="config.defaultMaxTokens"
                                    @input.debounce.500ms="saveConfigField('defaultMaxTokens', $event.target.value)">
                            </div>
                            <div class="form-control">
                                <label class="label py-1"><span class="label-text text-xs font-medium"
                                        data-tippy-content="Response creativity (0=deterministic, ~1=creative)">Temperature
                                        (<span class="font-mono"
                                            x-text="config.temperature?.toFixed(1)"></span>)</span></label>
                                <input type="range" min="0" max="2" step="0.1" class="range range-xs range-primary"
                                    x-model.number="config.temperature"
                                    @change="saveConfigField('temperature', $event.target.value)" />
                            </div>
                        </div>
                    </details>
                    <!-- UI & General Settings Section -->
                    <details class="mb-4 border border-base-300/20 rounded-md">
                        <summary
                            class="cursor-pointer select-none p-2 bg-base-200 rounded-t-md font-medium text-sm flex items-center gap-2">
                            <i class="fas fa-sliders-h"></i> UI & General
                        </summary>
                        <div class="p-3 space-y-3 text-sm bg-base-100/50 rounded-b-md">
                            <!-- UI Settings -->
                            <div class="grid grid-cols-2 gap-x-4">
                                <label class="cursor-pointer label justify-start gap-2 py-1"
                                    data-tippy-content="Show message timestamps">
                                    <input type="checkbox" class="toggle toggle-primary toggle-sm"
                                        x-model="uiSettings.showTimestamps"
                                        @change="saveUiSetting('showTimestamps', $event.target.checked)">
                                    <span class="label-text text-xs">Show Timestamps</span>
                                </label>
                                <label class="cursor-pointer label justify-start gap-2 py-1"
                                    data-tippy-content="Group messages by time periods">
                                    <input type="checkbox" class="toggle toggle-primary toggle-sm"
                                        x-model="uiSettings.groupMessagesByDate"
                                        @change="saveUiSetting('groupMessagesByDate', $event.target.checked)">
                                    <span class="label-text text-xs">Group by Date</span>
                                </label>
                                <label class="cursor-pointer label justify-start gap-2 py-1"
                                    data-tippy-content="Use compact message display mode">
                                    <input type="checkbox" class="toggle toggle-primary toggle-sm"
                                        x-model="uiSettings.compactMode"
                                        @change="saveUiSetting('compactMode', $event.target.checked)">
                                    <span class="label-text text-xs">Compact Mode</span>
                                </label>
                                <label class="cursor-pointer label justify-start gap-2 py-1"
                                    data-tippy-content="Show system status bar at bottom">
                                    <input type="checkbox" class="toggle toggle-primary toggle-sm"
                                        x-model="uiSettings.showStatusBar"
                                        @change="saveUiSetting('showStatusBar', $event.target.checked)">
                                    <span class="label-text text-xs">Status Bar</span>
                                </label>
                                <label class="cursor-pointer label justify-start gap-2 py-1"
                                    data-tippy-content="Use virtual scrolling for better performance">
                                    <input type="checkbox" class="toggle toggle-primary toggle-sm"
                                        x-model="uiSettings.virtualScrolling"
                                        @change="saveUiSetting('virtualScrolling', $event.target.checked)">
                                    <span class="label-text text-xs">Virtual Scrolling</span>
                                </label>
                                <label class="cursor-pointer label justify-start gap-2 py-1"
                                    data-tippy-content="Send message on Enter (disable to require Ctrl+Enter)">
                                    <input type="checkbox" class="toggle toggle-primary toggle-sm"
                                        x-model="uiSettings.sendOnEnter"
                                        @change="saveUiSetting('sendOnEnter', $event.target.checked)">
                                    <span class="label-text text-xs">Send on Enter</span>
                                </label>
                            </div>
                            <!-- Communication & Feature Flags -->
                            <div class="divider text-xs mt-3">Features</div>
                            <div class="grid grid-cols-2 gap-x-4">
                                <label class="cursor-pointer label justify-start gap-2 py-1"
                                    data-tippy-content="Cache tool results locally"><input type="checkbox"
                                        class="toggle toggle-primary toggle-sm" x-model="config.enableCaching"
                                        @change="saveConfigField('enableCaching', $event.target.checked)"><span
                                        class="label-text text-xs">Caching</span></label>
                                <label class="cursor-pointer label justify-start gap-2 py-1"
                                    data-tippy-content="Automatically look for servers at startup"><input
                                        type="checkbox" class="toggle toggle-primary toggle-sm"
                                        x-model="config.autoDiscover"
                                        @change="saveConfigField('autoDiscover', $event.target.checked)"><span
                                        class="label-text text-xs">Auto Discover</span></label>
                                <label class="cursor-pointer label justify-start gap-2 py-1"
                                    data-tippy-content="Look for servers on local network via mDNS/Zeroconf"><input
                                        type="checkbox" class="toggle toggle-primary toggle-sm"
                                        x-model="config.enableLocalDiscovery"
                                        @change="saveConfigField('enableLocalDiscovery', $event.target.checked)"><span
                                        class="label-text text-xs">mDNS</span></label>
                                <label class="cursor-pointer label justify-start gap-2 py-1"
                                    data-tippy-content="Scan local ports for SSE servers"><input type="checkbox"
                                        class="toggle toggle-primary toggle-sm" x-model="config.enablePortScanning"
                                        @change="saveConfigField('enablePortScanning', $event.target.checked)"><span
                                        class="label-text text-xs">Port Scan</span></label>
                            </div>
                            <div class="form-control">
                                <label class="label py-1"><span class="label-text text-xs font-medium"
                                        data-tippy-content="How often to refresh server status (seconds)">Dashboard
                                        Refresh (s)</span></label>
                                <input type="number" class="input input-bordered input-sm w-24"
                                    x-model.number="config.dashboardRefreshRate"
                                    @input.debounce.500ms="saveConfigField('dashboardRefreshRate', $event.target.value)"
                                    min="0.5" step="0.1">
                            </div>
                        </div>
                    </details>
                    <!-- Cache Management -->
                    <details class="mb-4 border border-base-300/20 rounded-md">
                        <summary
                            class="cursor-pointer select-none p-2 bg-base-200 rounded-t-md font-medium text-sm flex items-center gap-2">
                            <i class="fas fa-database"></i> Tool Cache Management
                        </summary>
                        <div class="p-3 space-y-3 text-sm bg-base-100/50 rounded-b-md">
                            <div class="flex flex-wrap gap-2">
                                <button class="btn btn-xs btn-outline" @click="fetchCacheData()"
                                    :disabled="isLoadingCache" :class="{'loading': isLoadingCache}"><i
                                        class="fas fa-sync mr-1" x-show="!isLoadingCache"></i> Refresh</button>
                                <button class="btn btn-xs btn-outline btn-warning" @click="cleanCacheAPI()"
                                    :disabled="isLoadingCache"><i class="fas fa-broom mr-1"></i> Clean Expired</button>
                                <button class="btn btn-xs btn-outline btn-error" @click="clearAllCacheAPI()"
                                    :disabled="isLoadingCache"><i class="fas fa-trash-alt mr-1"></i> Clear All</button>
                            </div>
                            <h3 class="text-sm font-semibold mt-2 opacity-80"><i class="fas fa-list-ul mr-1.5"></i>
                                Cached Entries
                            </h3>
                            <div x-show="isLoadingCache && cacheEntries.length === 0" class="text-center p-4"><span
                                    class="loading loading-dots loading-sm"></span> Loading Cache...</div>
                            <div id="cache-entries-table" class="text-xs border border-base-300/30 rounded mb-4"
                                x-show="!isLoadingCache"></div>
                            <h3 class="text-sm font-semibold mt-2 opacity-80"><i
                                    class="fas fa-project-diagram mr-1.5"></i> Tool Dependencies</h3>
                            <div x-show="isLoadingCache && Object.keys(cacheDependencies).length === 0"
                                class="text-center p-4"><span class="loading loading-dots loading-sm"></span> Loading
                                Dependencies...
                            </div>
                            <div id="cache-dependencies-table" class="text-xs border border-base-300/30 rounded"
                                x-show="!isLoadingCache"></div>
                        </div>
                    </details>
                    <!-- Usage Statistics -->
                    <details class="mb-4 border border-base-300/20 rounded-md">
                        <summary
                            class="cursor-pointer select-none p-2 bg-base-200 rounded-t-md font-medium text-sm flex items-center gap-2">
                            <i class="fas fa-chart-pie"></i> Usage Statistics
                        </summary>
                        <div class="p-3 space-y-3 text-sm bg-base-100/50 rounded-b-md">
                            <div class="flex items-center justify-between">
                                <div class="text-xs">
                                    <div>Input Tokens: <span x-text="tokenUsage.input_tokens?.toLocaleString() || 0"
                                            class="font-mono"></span></div>
                                    <div>Output Tokens: <span x-text="tokenUsage.output_tokens?.toLocaleString() || 0"
                                            class="font-mono"></span></div>
                                    <div>Cost: <span x-text="`$${(tokenUsage.total_cost || 0).toFixed(4)}`"
                                            class="font-mono"></span></div>
                                </div>
                                <button @click="resetUsageStats()" class="btn btn-sm btn-outline btn-warning"><i
                                        class="fas fa-eraser mr-1"></i> Reset Counter</button>
                            </div>
                        </div>
                    </details>
                    <!-- Reset Button -->
                    <button class="btn btn-xs btn-outline btn-error mt-4" @click="resetConfig"><i
                            class="fas fa-undo mr-1"></i>
                        Reset Settings to Defaults</button>
                </div>
                <!-- End Config Tab -->
                <!-- Dashboard Tab -->
                <div x-show="activeTab === 'dashboard'" x-transition.opacity>
                    <div class="flex justify-between items-center mb-3">
                        <h2 class="text-base font-semibold flex items-center">
                            <i class="fas fa-chart-bar mr-2 text-primary"></i>Dashboard
                        </h2>
                        <button class="btn btn-xs btn-outline" @click="refreshDashboardData()"
                            :disabled="isLoadingDashboard" :class="{'loading': isLoadingDashboard}">
                            <i class="fas fa-sync mr-1" x-show="!isLoadingDashboard"></i> Refresh
                        </button>
                    </div>
                    <!-- Loading indicator for dashboard -->
                    <div x-show="isLoadingDashboard" class="text-center p-4">
                        <span class="loading loading-dots loading-md"></span>
                        <p class="text-sm mt-2">Loading dashboard data...</p>
                    </div>
                    <!-- Dashboard content -->
                    <div x-show="!isLoadingDashboard" class="space-y-4">
                        <!-- Quick stats -->
                        <div class="dashboard-card">
                            <div class="dashboard-card-header">
                                <h3 class="dashboard-card-title">
                                    <i class="fas fa-chart-line mr-1.5 text-info"></i> System Overview
                                </h3>
                                <span class="text-xs opacity-70">Last updated: <span
                                        x-text="formatTimestamp(dashboardLastUpdated)"></span></span>
                            </div>
                            <div class="stats-grid dashboard-card-content">
                                <div class="stat-item">
                                    <div class="stat-value" x-text="dashboardStats.activeServers"></div>
                                    <div class="stat-label">Active Servers</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-value" x-text="dashboardStats.totalTools"></div>
                                    <div class="stat-label">Available Tools</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-value" x-text="dashboardStats.totalConversations"></div>
                                    <div class="stat-label">Conversations</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-value" x-text="dashboardStats.totalMessages"></div>
                                    <div class="stat-label">Total Messages</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-value" x-text="dashboardStats.cacheHitRate + '%'"></div>
                                    <div class="stat-label">Cache Hit Rate</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-value" x-text="dashboardStats.systemUptime"></div>
                                    <div class="stat-label">System Uptime</div>
                                </div>
                            </div>
                        </div>
                        <!-- Tool usage stats -->
                        <div class="dashboard-card">
                            <div class="dashboard-card-header">
                                <h3 class="dashboard-card-title">
                                    <i class="fas fa-tools mr-1.5 text-accent"></i> Tool Usage
                                </h3>
                                <div class="flex items-center gap-2">
                                    <select class="select select-xs select-bordered bg-base-100 text-base-content"
                                        x-model="toolUsageTimeframe">
                                        <option value="day">Last 24 Hours</option>
                                        <option value="week">Last Week</option>
                                        <option value="month">Last Month</option>
                                        <option value="all">All Time</option>
                                    </select>
                                </div>
                            </div>
                            <div class="dashboard-card-content">
                                <div class="text-center text-sm p-4" x-show="!dashboardStats.topTools?.length">
                                    <i class="fas fa-info-circle text-info mr-1"></i> No
                                    tool usage data available for
                                    the selected timeframe.
                                </div>
                                <!-- Tool usage bar chart (placeholder for visualization) -->
                                <div id="tool-usage-chart" class="h-64 w-full bg-base-200/50 rounded-md my-4"
                                    x-show="dashboardStats.topTools?.length > 0">
                                    <!-- Chart would render here -->
                                    <div
                                        class="flex items-center justify-center h-full text-base-content/50 text-xs italic">
                                        Tool Usage Chart Area
                                    </div>
                                </div>
                                <!-- Most used tools -->
                                <div class="mt-4 overflow-x-auto" x-show="dashboardStats.topTools?.length > 0">
                                    <h4 class="text-sm font-medium mb-2">Most Used Tools</h4>
                                    <table class="table table-xs w-full">
                                        <thead>
                                            <tr class="bg-base-200">
                                                <th class="text-left">Tool</th>
                                                <th class="text-left">Server</th>
                                                <th class="text-right">Usage Count</th>
                                                <th class="text-right">Success Rate</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <template x-for="tool in dashboardStats.topTools.slice(0, 5)"
                                                :key="tool.name">
                                                <tr class="hover:bg-base-200/50">
                                                    <td class="font-medium" x-text="tool.shortName"></td>
                                                    <td x-text="tool.server"></td>
                                                    <td class="text-right" x-text="tool.count"></td>
                                                    <td class="text-right">
                                                        <span
                                                            :class="tool.successRate > 90 ? 'text-success font-medium' : (tool.successRate > 70 ? 'text-warning font-medium' : 'text-error font-medium')"
                                                            x-text="tool.successRate + '%'"></span>
                                                    </td>
                                                </tr>
                                            </template>
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                        <!-- Server health -->
                        <div class="dashboard-card">
                            <div class="dashboard-card-header">
                                <h3 class="dashboard-card-title">
                                    <i class="fas fa-server mr-1.5 text-success"></i> Server Health
                                </h3>
                                <button class="btn btn-xs btn-outline bg-base-100" @click="checkAllServerHealth()"
                                    :disabled="isCheckingServerHealth" :class="{'loading': isCheckingServerHealth}">
                                    <i class="fas fa-heartbeat" x-show="!isCheckingServerHealth"></i> Check
                                    Health
                                </button>
                            </div>
                            <div class="dashboard-card-content overflow-x-auto">
                                <table class="table table-xs w-full">
                                    <thead>
                                        <tr class="bg-base-200">
                                            <th class="text-left">Server</th>
                                            <th class="text-left">Status</th>
                                            <th class="text-right">Response Time</th>
                                            <th class="text-right">Error Rate</th>
                                            <th class="text-right">Uptime</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <template x-for="server in dashboardStats.serverHealth" :key="server.name">
                                            <tr class="hover:bg-base-200/50">
                                                <td>
                                                    <div class="flex items-center gap-1.5 font-medium">
                                                        <i
                                                            :class="server.type === 'stdio' ? 'fas fa-terminal text-accent' : 'fas fa-network-wired text-info'"></i>
                                                        <span x-text="server.name"></span>
                                                    </div>
                                                </td>
                                                <td>
                                                    <div>
                                                        <span class="badge badge-sm font-medium" :class="{
                                                'badge-success': server.status === 'healthy',
                                                'badge-warning': server.status === 'degraded',
                                                'badge-error': server.status === 'error',
                                                'badge-ghost': server.status === 'unknown'
                                                }">
                                                            <span x-text="server.status"></span>
                                                        </span>
                                                    </div>
                                                </td>
                                                <td class="text-right" x-text="server.responseTime + ' ms'"></td>
                                                <td class="text-right">
                                                    <span :class="{
                                             'text-success font-medium': server.errorRate < 1,
                                             'text-warning font-medium': server.errorRate >= 1 && server.errorRate < 5,
                                             'text-error font-medium': server.errorRate >= 5
                                             }" x-text="server.errorRate + '%'"></span>
                                                </td>
                                                <td class="text-right" x-text="server.uptime"></td>
                                            </tr>
                                        </template>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- End Dashboard Tab -->
                <!-- Agent Tab -->
                <div x-show="activeTab === 'agent'" x-transition.opacity class="space-y-4">
                    <h2 class="text-lg font-semibold mb-4 flex items-center text-base-content">
                        <i class="fas fa-robot mr-2 text-primary text-xl"></i>Agent Self-Driving Mode
                    </h2>

                    <!-- Agent Status & Overview Card -->
                    <div class="card card-compact bg-base-100 shadow-md border border-base-300/30">
                        <div class="card-body p-4 space-y-2.5 text-sm">
                            <div class="flex justify-between items-center pb-2 border-b border-base-300/20">
                                <h3 class="card-title !text-base !pb-0">
                                    <i class="fas fa-tachometer-alt mr-2 text-secondary"></i>Agent Status
                                </h3>
                                <button class="btn btn-xs btn-ghost text-info/80 hover:text-info hover:bg-info/10 px-2" @click="fetchAgentStatus()">
                                    <i class="fas fa-sync fa-xs" :class="{'fa-spin': isLoadingAgentStatus}"></i> Refresh
                                </button>
                            </div>

                            <div class="grid grid-cols-1 md:grid-cols-2 gap-x-4 gap-y-2 text-xs">
                                <div class="flex justify-between items-center">
                                    <span class="font-medium text-base-content/70">Current State:</span>
                                    <span class="badge badge-md font-semibold"
                                          :class="{
                                              'badge-success animate-pulse': agentStatus.status === 'running',
                                              'badge-success': agentStatus.status === 'completed',
                                              'badge-warning': agentStatus.status === 'starting' || agentStatus.status === 'stopping' || agentStatus.status === 'stopping_timeout',
                                              'badge-error': agentStatus.status === 'failed' || agentStatus.status === 'error_stopping',
                                              'badge-ghost': agentStatus.status === 'idle' || agentStatus.status === 'stopped' || agentStatus.status === 'max_loops_reached' || agentStatus.status === 'unknown'
                                          }"
                                          x-text="agentStatus.status_display || 'Idle'">
                                    </span>
                                </div>
                                <div class="flex justify-between items-center" x-show="agentStatus.agent_running && agentStatus.agent_max_loops_from_mcp_config > 0">
                                    <span class="font-medium text-base-content/70">Loop Progress:</span>
                                    <span class="font-mono text-base-content/90" x-text="`${agentStatus.agent_internal_loop_count || 0} / ${agentStatus.agent_max_loops_from_mcp_config || 0}`"></span>
                                </div>
                            </div>
                            
                            <div x-show="agentStatus.agent_running && agentStatus.agent_max_loops_from_mcp_config > 0" class="pt-1">
                                <progress class="progress progress-primary w-full h-2"
                                          :value="agentStatus.agent_internal_loop_count || 0"
                                          :max="agentStatus.agent_max_loops_from_mcp_config || 100"></progress>
                            </div>

                            <div>
                                <span class="font-medium text-base-content/70 block mb-0.5">Overall Task (MCPC):</span>
                                <p class="opacity-90 text-base-content/90 text-xs leading-snug p-2 bg-base-200/50 rounded-md min-h-[3em]" x-text="agentStatus.overall_goal_from_mcp_client || 'Not Set'" :title="agentStatus.overall_goal_from_mcp_client"></p>
                            </div>

                            <div>
                                <span class="font-medium text-base-content/70 block mb-0.5">Current UMS Goal (Agent):</span>
                                <p class="opacity-90 text-base-content/90 text-xs leading-snug p-2 bg-base-200/50 rounded-md min-h-[3em]" x-text="agentStatus.agent_current_ums_goal_description || 'N/A'" :title="agentStatus.agent_current_ums_goal_description"></p>
                                <span class="text-2xs opacity-60 font-mono ml-1" x-show="agentStatus.agent_current_ums_goal_id" x-text="`(ID: ...${agentStatus.agent_current_ums_goal_id ? agentStatus.agent_current_ums_goal_id.slice(-8) : ''})`"></span>
                            </div>

                            <div>
                                <span class="font-medium text-base-content/70 block mb-0.5">Last Action/Message (Agent):</span>
                                <p class="opacity-90 text-base-content/90 text-xs leading-snug p-2 bg-base-200/50 rounded-md min-h-[2.5em]" x-text="agentStatus.agent_last_action_summary || agentStatus.agent_last_general_message || 'N/A'" :title="agentStatus.agent_last_action_summary || agentStatus.agent_last_general_message"></p>
                            </div>
                            
                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-x-4 gap-y-1 text-xs pt-1 border-t border-base-300/20 mt-2">
                                <div><span class="font-medium text-base-content/70">Agent LLM:</span> <span class="font-mono opacity-90 text-base-content/90" x-text="agentStatus.agent_target_model || 'N/A'"></span></div>
                                <div x-show="agentStatus.agent_workflow_id"><span class="font-medium text-base-content/70">UMS Workflow ID:</span> <span class="font-mono opacity-90 text-base-content/90" x-text="agentStatus.agent_workflow_id ? '...' + agentStatus.agent_workflow_id.slice(-8) : 'N/A'"></span></div>
                                <div x-show="agentStatus.agent_thought_chain_id"><span class="font-medium text-base-content/70">UMS Thought Chain:</span> <span class="font-mono opacity-90 text-base-content/90" x-text="agentStatus.agent_thought_chain_id ? '...' + agentStatus.agent_thought_chain_id.slice(-8) : 'N/A'"></span></div>
                            </div>
                        </div>
                    </div>

                    <!-- Agent's UMS Goal Stack Card -->
                    <div x-show="agentStatus.agent_local_ums_goal_stack_summary && agentStatus.agent_local_ums_goal_stack_summary.length > 0"
                         class="card card-compact bg-base-100 shadow-md border border-base-300/30">
                        <div class="card-body p-4">
                            <h3 class="card-title !text-base !pb-0 mb-2 flex items-center text-base-content">
                                <i class="fas fa-layer-group fa-fw mr-2 text-secondary"></i> Agent's UMS Goal Stack
                            </h3>
                            <ul class="list-none pl-0 space-y-1.5 text-xs max-h-60 overflow-y-auto pr-1">
                                <template x-for="(goal, index) in agentStatus.agent_local_ums_goal_stack_summary" :key="goal.goal_id || index">
                                    <li class="flex items-start gap-2 p-2 rounded-md transition-all duration-150"
                                        :class="goal.goal_id === agentStatus.agent_current_ums_goal_id ? 'bg-primary/10 ring-2 ring-primary/50 shadow-sm' : 'bg-base-200/70 hover:bg-base-200'">
                                        <i class="fas fa-flag mt-0.5 text-sm"
                                           :class="goal.goal_id === agentStatus.agent_current_ums_goal_id ? 'text-primary' : 'text-base-content/40'"></i>
                                        <div class="flex-1 min-w-0">
                                            <p class="font-medium text-base-content/95 leading-snug" x-text="goal.description" :title="goal.description"></p>
                                            <div class="flex items-center justify-between text-2xs opacity-70 mt-1">
                                                <span class="badge badge-sm font-mono !py-0.5 !px-2 !text-2xs !leading-tight"
                                                      :class="{
                                                        'badge-success text-success-content': goal.status === 'completed',
                                                        'badge-error text-error-content': goal.status === 'failed' || goal.status === 'abandoned',
                                                        'badge-info text-info-content': goal.status === 'active' || goal.status === 'in_progress' || goal.status === 'planned',
                                                        'badge-warning text-warning-content': goal.status === 'paused',
                                                        'badge-ghost': !['completed', 'failed', 'abandoned', 'active', 'in_progress', 'planned', 'paused'].includes(goal.status)
                                                      }"
                                                      x-text="goal.status || 'unknown'"></span>
                                                <span class="font-mono opacity-80" x-text="goal.goal_id ? `(...${goal.goal_id.slice(-7)})` : 'Not Synced'"></span>
                                            </div>
                                        </div>
                                    </li>
                                </template>
                            </ul>
                        </div>
                    </div>

                    <!-- Agent's Current Plan Steps Card -->
                    <div x-show="agentStatus.agent_running && agentStatus.agent_current_full_plan && agentStatus.agent_current_full_plan.length > 0"
                         class="card card-compact bg-base-100 shadow-md border border-base-300/30">
                        <div class="card-body p-0"> <!-- p-0 on card-body for Tabulator to control padding -->
                            <h3 class="text-base font-semibold mb-0 text-base-content flex items-center p-3 border-b border-base-300/20">
                                <i class="fas fa-tasks fa-fw mr-2 text-secondary"></i> Agent's Current Plan
                            </h3>
                            <div id="agent-current-plan-table" class="text-xs min-h-[100px] m-1"> 
                                <!-- Tabulator styling might need table-xs or specific height -->
                            </div>
                        </div>
                    </div>
                    <div x-show="agentStatus.agent_running && (!agentStatus.agent_current_full_plan || agentStatus.agent_current_full_plan.length === 0)"
                         class="my-3 p-4 text-center text-sm text-base-content/60 bg-base-100/50 rounded-md border border-base-300/20 italic shadow-sm">
                        Agent has no active plan steps.
                    </div>

                    <!-- Agent Start Controls Card -->
                    <div class="card card-compact bg-base-100 shadow-md border border-base-300/30" x-show="!agentStatus.agent_running && !['starting', 'stopping', 'error_stopping', 'stopping_timeout'].includes(agentStatus.status)">
                        <div class="card-body p-4 space-y-3">
                            <h3 class="card-title !text-base !pb-0">
                                <i class="fas fa-rocket mr-2 text-success"></i> Launch Agent
                            </h3>
                            <div>
                                <label class="label py-1"><span class="label-text text-xs font-medium">Agent's Overall Task / Goal</span></label>
                                <textarea class="textarea textarea-bordered w-full text-sm leading-normal textarea-primary" rows="3"
                                          placeholder="Enter the main objective for the agent... Be specific and actionable."
                                          x-model.lazy="agentControl.goal"></textarea>
                            </div>
                            <div class="grid grid-cols-2 gap-3 items-end">
                                <div>
                                    <label class="label py-1"><span class="label-text text-xs font-medium">Max Loops</span></label>
                                    <input type="number" class="input input-bordered input-sm w-full" min="1" max="1000" step="1"
                                           x-model.number="agentControl.maxLoops">
                                </div>
                                <div>
                                    <label class="label py-1"><span class="label-text text-xs font-medium">LLM Model Override (Optional)</span></label>
                                    <input type="text" class="input input-bordered input-sm w-full"
                                           placeholder="Default from settings"
                                           x-model.lazy="agentControl.llmModel"
                                           list="agentModelDatalistShared">
                                    <!-- Datalist is defined above in main layout -->
                                </div>
                            </div>
                            <button class="btn btn-success btn-block mt-2 text-success-content"
                                    @click="startAgent"
                                    :disabled="!agentControl.goal.trim() || agentControl.maxLoops <= 0 || isLoadingAgentAction || agentStatus.agent_running">
                                <i class="fas fa-play mr-2"></i> Start Agent
                            </button>
                        </div>
                    </div>

                    <!-- Agent Active Controls (Stop, Guidance) Card -->
                    <div class="card card-compact bg-base-100 shadow-md border border-base-300/30" x-show="agentStatus.agent_running || ['starting', 'stopping', 'stopping_timeout'].includes(agentStatus.status)">
                        <div class="card-body p-4 space-y-3">
                             <h3 class="card-title !text-base !pb-0">
                                <i class="fas fa-gamepad mr-2 text-warning"></i> Active Controls
                            </h3>
                            <button class="btn btn-error btn-block"
                                    @click="stopAgent"
                                    :disabled="isLoadingAgentAction || ['stopped', 'idle', 'failed', 'completed', 'error_stopping'].includes(agentStatus.status)">
                                <i class="fas fa-stop mr-2"></i>
                                <span x-text="agentStatus.status === 'stopping' || agentStatus.status === 'stopping_timeout' ? 'Stopping...' : (agentStatus.status === 'error_stopping' ? 'Error Stopping' : 'Stop Agent')"></span>
                            </button>

                            <div class="mt-3 pt-3 border-t border-base-300/20" x-show="agentStatus.agent_running">
                                <label class="label py-1"><span class="label-text text-xs font-medium">Provide Live Guidance / Observation:</span></label>
                                <div class="flex gap-2">
                                    <input type="text" class="input input-sm input-bordered flex-grow" x-model.lazy="agentControl.guidanceText"
                                           placeholder="e.g., 'Prioritize searching the web for recent news.'">
                                    <button class="btn btn-sm btn-secondary" @click="sendAgentGuidance"
                                            :disabled="!agentControl.guidanceText.trim() || isLoadingAgentAction">
                                        <i class="fas fa-comment-dots mr-1"></i> Send Hint
                                    </button>
                                </div>
                                <p class="text-2xs opacity-60 mt-1">This will be injected as a high-priority thought/memory for the agent.</p>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- End Agent Tab -->
            </div>
            <!-- End Tab Content -->
        </aside>
        <!-- End Sidebar -->
        <!-- Chat Area -->
        <main class="flex-1 flex flex-col h-full bg-gradient-to-b from-base-200 to-base-300/50">
            <template id="message-render-template">
                <!-- START: Reusable Message Rendering Block -->
                <div :id="`message-${message.id || index}`" class="chat relative group/message"
                     :class="{
                         'chat-start': message.role !== 'user', // Agent, Assistant, System messages are chat-start
                         'chat-end': message.role === 'user',   // User messages are chat-end
                         'compact-mode': uiSettings.compactMode
                     }">

                    <!-- Bookmark Indicator -->
                    <div class="bookmark-indicator" x-show="isMessageBookmarked(message.timestamp, currentNodeId)">
                        <i class="fas fa-bookmark"></i>
                    </div>

                    <!-- Avatar -->
                    <div class="chat-image avatar" x-show="message.role !== 'user'">
                        <div class="w-8 rounded-full flex items-center justify-center"
                             :class="{
                                 // Style for Agent Activity (distinct from regular assistant/LLM)
                                 'bg-accent text-accent-content': message.is_agent_activity && !message.is_error,

                                 // Style for direct LLM (Assistant) responses (NOT agent activity)
                                 'bg-secondary text-secondary-content': message.role === 'assistant' && !message.is_agent_activity && !message.is_error && !message.content_type?.includes('tool'),

                                 // Style for System messages
                                 'bg-neutral text-neutral-content': message.role === 'system' && !message.is_agent_activity && !message.is_error,

                                 // Style for Tool Results/Usage (can be from user-triggered or agent-triggered LLM turns)
                                 // If it's agent activity and also a tool, agent color takes precedence
                                 'bg-info text-info-content': !message.is_agent_activity && (message.content_type === 'tool_result' || message.content_type === 'tool_use' || (Array.isArray(message.content) && message.content.some(b => b.type==='tool_use' || b.type==='tool_result'))) && !message.is_error,

                                 // Style for Errors (applies to any non-user role if error)
                                 'bg-warning text-warning-content': message.is_error
                             }">
                            <i :class="message.is_agent_activity ? 'fas fa-cogs' : messageRoleIcon(message.role, message.content_type)" class="text-sm m-0 p-0"></i>
                        </div>
                    </div>
                    <div class="chat-image avatar" x-show="message.role === 'user'">
                        <div class="w-8 rounded-full bg-primary text-primary-content flex items-center justify-center">
                            <i :class="messageRoleIcon(message.role)" class="text-sm m-0 p-0"></i>
                        </div>
                    </div>

                    <!-- Header -->
                    <div class="chat-header text-xs opacity-60 mb-0.5 ml-1"
                        :class="{'text-right mr-1': message.role === 'user'}">
                        <span x-text="message.is_agent_activity ? 'Agent Activity' : messageRoleDisplayName(message.role, message.content_type)"></span>
                        <span x-show="message.model && (!message.is_agent_activity || message.content_type === 'agent_llm_stream_output')" class="opacity-70" <!-- Show model for agent's LLM stream, not for its generic logs -->
                            x-text="message.model ? (' (' + message.model + ')') : ''"></span>
                        <time class="text-xs opacity-50 ml-1" x-show="uiSettings.showTimestamps"
                            x-text="formatTimestamp(message.timestamp)"></time>
                        <!-- Bookmark Toggle Icon -->
                        <i class="fas fa-bookmark ml-2 cursor-pointer opacity-0 group-hover/message:opacity-100 transition-opacity duration-150"
                            :class="isMessageBookmarked(message.timestamp, currentNodeId) ? 'text-warning opacity-100' : 'text-base-content/30 hover:text-warning/70'"
                            @click="toggleBookmark(message.timestamp, currentNodeId)"
                            data-tippy-content="Toggle Bookmark"></i>
                    </div>

                    <!-- Chat Bubble -->
                    <div class="chat-bubble prose prose-sm max-w-none"
                         :class="{
                            'chat-bubble-warning text-warning-content': message.is_error, // Error style first
                            'chat-bubble-primary text-primary-content': !message.is_error && message.role === 'user', // User
                            'chat-bubble-accent text-accent-content': !message.is_error && message.is_agent_activity, // Agent Activity (takes precedence over assistant/system if agent_activity)
                            'bg-neutral text-neutral-content': !message.is_error && !message.is_agent_activity && message.role === 'assistant' && !message.current_status && !message.content_type?.includes('tool'), // LLM direct response (not agent)
                            'chat-bubble-info text-info-content': !message.is_error && !message.is_agent_activity && (message.role === 'system' || (message.role === 'assistant' && message.current_status) || message.content_type?.includes('tool')), // System, LLM status, or tool data (not agent)
                            'animate__animated animate__fadeInUp animate__faster': shouldAnimate(message.id || index)
                         }"
                        x-html="isMessageSearchActive ? renderMessageWithHighlight(message) : renderMessageContent(message)">
                        <!-- Content rendered by x-html -->
                    </div>

                    <!-- Status Updates (for direct LLM assistant responses, not agent specific status) -->
                    <div class="chat-footer" x-show="message.role === 'assistant' && !message.is_agent_activity && message.current_status">
                        <span class="streaming-status opacity-70" x-text="message.current_status"></span>
                    </div>
                </div>
                <!-- END: Reusable Message Rendering Block -->
            </template>

            <!-- Message Search Container (hidden by default, shown when activated) -->
            <div class="message-search-container" :class="{'active': isMessageSearchActive}">
                <input type="text" placeholder="Search in conversation..." class="input input-sm input-bordered flex-1"
                    x-model="messageSearchQuery" @keyup.enter="findNextSearchMatch"
                    @keyup.esc="isMessageSearchActive = false">
                <button class="btn btn-sm btn-ghost" @click="findPreviousSearchMatch"
                    :disabled="currentSearchMatchIndex <= 0">
                    <i class="fas fa-chevron-up"></i>
                </button>
                <button class="btn btn-sm btn-ghost" @click="findNextSearchMatch"
                    :disabled="currentSearchMatchIndex >= searchMatches.length - 1">
                    <i class="fas fa-chevron-down"></i>
                </button>
                <button class="btn btn-sm btn-ghost" @click="isMessageSearchActive = false">
                    <i class="fas fa-times"></i>
                </button>
                <span class="text-xs opacity-70" x-show="searchMatches.length > 0">
                    <span x-text="currentSearchMatchIndex + 1"></span>/<span x-text="searchMatches.length"></span>
                </span>
            </div>
            <!-- Messages Display -->
            <div class="flex-1 p-4 overflow-y-auto chat-messages"
                :class="{'virtual-scroll-container': uiSettings.virtualScrolling}" x-ref="chatbox">
                <div :class="{'virtual-scroll-content': uiSettings.virtualScrolling}"
                    :style="uiSettings.virtualScrolling ? `height: ${virtualScrollHeight}px` : ''">
                    <!-- Non-Grouped View -->
                    <template x-if="!uiSettings.groupMessagesByDate">
                        <template x-for="(message, index) in currentConversation" :key="message.id || index">
                            <!-- Condition to show/hide -->
                            <template x-if="!shouldHideToolMessage(message)">
                                <div x-html="document.getElementById('message-render-template').innerHTML">
                                    <!-- Alpine will process the bindings inside the cloned template -->
                                    <!-- The outer div ensures the template root is cloned correctly -->
                                </div>
                            </template>
                            <!-- End inner template x-if -->
                        </template>
                        <!-- End outer template x-for -->
                    </template>
                    <!-- End template x-if non-grouped -->
                    <!-- Grouped View -->
                    <template x-if="uiSettings.groupMessagesByDate">
                        <template x-for="date in Object.keys(groupedMessages).sort((a, b) => new Date(a) - new Date(b))"
                            :key="date">
                            <!-- Date Divider -->
                            <div class="message-date-divider">
                                <span x-text="formatMessageDate(date)"></span>
                            </div>
                            <!-- Messages in this date group -->
                            <template x-for="(message, index) in groupedMessages[date]" :key="message.id || index">
                                <!-- Condition to show/hide -->
                                <template x-if="!shouldHideToolMessage(message)">
                                    <div x-html="document.getElementById('message-render-template').innerHTML">
                                        <!-- Alpine will process the bindings inside the cloned template -->
                                        <!-- The outer div ensures the template root is cloned correctly -->
                                    </div>

                                </template>
                                <!-- End inner template x-if -->
                            </template>
                            <!-- End inner template x-for message -->
                        </template>
                        <!-- End outer template x-for date -->
                    </template>
                    <!-- End template x-if grouped -->
                    <!-- Loading Indicator & Scroll Target -->
                    <div x-show="isSendingMessage && !currentStatusMessage" class="chat chat-start">
                        <div class="chat-image avatar">
                            <div
                                class="w-8 rounded-full bg-secondary text-secondary-content flex items-center justify-center">
                                <i class="fas fa-robot text-sm"></i>
                            </div>
                        </div>
                        <div class="chat-bubble chat-bubble-secondary animate-pulse"><span
                                class="loading loading-dots loading-sm"></span></div>
                    </div>
                    <div x-ref="endofchat" class="h-1 m-0 p-0"></div>
                    <!-- Scroll target -->
                </div>
                <!-- End virtual-scroll-content / main message container -->
            </div>
            <!-- End chat-messages -->
            <!-- Input Area -->
            <div class="p-3 border-t border-base-300/50 bg-base-100 flex-shrink-0 shadow-inner drop-zone"
                :class="{'drag-over': isDraggingOverDropZone}" @dragover.prevent="isDraggingOverDropZone = true"
                @dragleave.prevent="isDraggingOverDropZone = false" @drop.prevent="handleDrop($event)">
                <!-- Status Message -->
                <div x-show="currentStatusMessage"
                    class="text-xs text-info mb-1.5 flex items-center gap-1.5 animate__animated animate__fadeIn animate__faster">
                    <i :class="currentStatusIcon()"></i> <span x-text="currentStatusMessage"></span>
                </div>
                <!-- Input -->
                <div class="flex items-end gap-2">
                    <textarea class="textarea textarea-bordered w-full resize-none text-sm leading-tight pt-2 pb-2"
                        placeholder="Ask anything... (Shift+Enter for newline)" rows="1" x-model="userInput"
                        @keydown.enter="if (uiSettings.sendOnEnter && !$event.shiftKey && !$event.ctrlKey && !$event.metaKey) { $event.preventDefault(); sendMessage(); } else if (!uiSettings.sendOnEnter && ($event.ctrlKey || $event.metaKey) && !$event.shiftKey) { $event.preventDefault(); sendMessage(); }"
                        @keydown.shift.enter.exact.prevent="userInput += '\n'; adjustTextareaHeight($el)"
                        @input="adjustTextareaHeight($event.target)" x-ref="inputarea"
                        :disabled="isSendingMessage && !config.enableStreaming"></textarea>
                    <button x-show="isSendingMessage"
                        class="btn btn-warning btn-square btn-sm animate__animated animate__faster animate__fadeIn"
                        @click="abortQuery" data-tippy-content="Stop Generation (Esc)">
                        <i class="fas fa-stop"></i>
                    </button>
                    <button class="btn btn-ghost btn-square btn-sm" @click="showTemplatesModal = true"
                        data-tippy-content="Message Templates">
                        <i class="fas fa-clipboard-list"></i>
                    </button>
                    <label class="btn btn-ghost btn-square btn-sm cursor-pointer" data-tippy-content="Upload File">
                        <i class="fas fa-paperclip"></i>
                        <input type="file" class="hidden" @change="handleFileUpload($event)">
                    </label>
                    <button x-show="!isSendingMessage" class="btn btn-primary btn-square btn-sm" @click="sendMessage"
                        :disabled="!userInput.trim()">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </main> <!-- End Chat Area -->
    </div> <!-- End Main Content Area -->
    <!-- Modals -->
    <dialog id="addServerModal" class="modal" :class="{ 'modal-open': showAddServerModal }"
        @keydown.escape.window="showAddServerModal = false">
        <div class="modal-box bg-base-100">
            <h3 class="font-bold text-lg mb-4">Add New MCP Server</h3>
            <form @submit.prevent="addServer">
                <div class="form-control mb-2">
                    <label class="label"><span class="label-text">Name</span></label>
                    <input type="text" placeholder="e.g., my-local-agent" class="input input-bordered"
                        x-model="newServer.name" required x-ref="addServerNameInput" @keydown.enter.prevent>
                </div>
                <div class="form-control mb-2">
                    <label class="label"><span class="label-text">Type</span></label>
                    <select class="select select-bordered" x-model="newServer.type" required>
                        <option value="stdio">STDIO</option>
                        <option value="sse">SSE (HTTP)</option>
                    </select>
                </div>
                <div class="form-control mb-2">
                    <label class="label"><span class="label-text"
                            x-text="newServer.type === 'stdio' ? 'Command/Path' : 'URL'"></span></label>
                    <input type="text"
                        :placeholder="newServer.type === 'stdio' ? '/path/to/server.py or python -m my_module' : 'http://localhost:8000/mcp'"
                        class="input input-bordered" x-model="newServer.path" required @keydown.enter.prevent>
                </div>
                <div class="form-control mb-4" x-show="newServer.type === 'stdio'">
                    <label class="label"><span class="label-text">Arguments (optional, space-separated)</span></label>
                    <input type="text" placeholder="--port 8080 --debug" class="input input-bordered"
                        x-model="newServer.argsString" @keydown.enter.prevent>
                </div>
                <div class="modal-action">
                    <button type="button" class="btn btn-ghost" @click="showAddServerModal = false">Cancel</button>
                    <button type="submit" class="btn btn-primary">Add Server</button>
                </div>
            </form>
        </div>
        <form method="dialog" class="modal-backdrop"> <button @click="showAddServerModal = false">close</button> </form>
    </dialog>
    <dialog id="keyboardShortcutsModal" class="modal" :class="{ 'modal-open': showKeyboardShortcutsModal }">
        <div class="modal-box keyboard-shortcuts-panel">
            <h3 class="font-bold text-lg">Keyboard Shortcuts</h3>
            <div class="py-4 space-y-1">
                <div class="keyboard-shortcut-item">
                    <span>Send Message</span>
                    <div class="keyboard-shortcut-keys">
                        <span class="keyboard-shortcut-key">Enter</span>
                    </div>
                </div>
                <div class="keyboard-shortcut-item">
                    <span>Add Line Break</span>
                    <div class="keyboard-shortcut-keys">
                        <span class="keyboard-shortcut-key">Shift</span>
                        <span>+</span>
                        <span class="keyboard-shortcut-key">Enter</span>
                    </div>
                </div>
                <div class="keyboard-shortcut-item">
                    <span>Stop Generation</span>
                    <div class="keyboard-shortcut-keys">
                        <span class="keyboard-shortcut-key">Esc</span>
                    </div>
                </div>
                <div class="keyboard-shortcut-item">
                    <span>Search in Conversation</span>
                    <div class="keyboard-shortcut-keys">
                        <span class="keyboard-shortcut-key">Ctrl</span>
                        <span>+</span>
                        <span class="keyboard-shortcut-key">F</span>
                    </div>
                </div>
                <div class="keyboard-shortcut-item">
                    <span>Toggle Sidebar</span>
                    <div class="keyboard-shortcut-keys">
                        <span class="keyboard-shortcut-key">Alt</span>
                        <span>+</span>
                        <span class="keyboard-shortcut-key">S</span>
                    </div>
                </div>
                <div class="keyboard-shortcut-item">
                    <span>Focus on Input</span>
                    <div class="keyboard-shortcut-keys">
                        <span class="keyboard-shortcut-key">/</span>
                    </div>
                </div>
                <div class="keyboard-shortcut-item">
                    <span>Clear Input</span>
                    <div class="keyboard-shortcut-keys">
                        <span class="keyboard-shortcut-key">Ctrl</span>
                        <span>+</span>
                        <span class="keyboard-shortcut-key">K</span>
                    </div>
                </div>
                <div class="keyboard-shortcut-item">
                    <span>Switch to Servers Tab</span>
                    <div class="keyboard-shortcut-keys"><span
                            class="keyboard-shortcut-key">Alt</span><span>+</span><span
                            class="keyboard-shortcut-key">1</span></div>
                </div>
                <div class="keyboard-shortcut-item">
                    <span>Switch to Tools Tab</span>
                    <div class="keyboard-shortcut-keys"><span
                            class="keyboard-shortcut-key">Alt</span><span>+</span><span
                            class="keyboard-shortcut-key">2</span></div>
                </div>
                <div class="keyboard-shortcut-item">
                    <span>Switch to Conversation Tab</span>
                    <div class="keyboard-shortcut-keys"><span
                            class="keyboard-shortcut-key">Alt</span><span>+</span><span
                            class="keyboard-shortcut-key">3</span></div>
                </div>
                <div class="keyboard-shortcut-item">
                    <span>Switch to Settings Tab</span>
                    <div class="keyboard-shortcut-keys"><span
                            class="keyboard-shortcut-key">Alt</span><span>+</span><span
                            class="keyboard-shortcut-key">4</span></div>
                </div>
                <div class="keyboard-shortcut-item">
                    <span>Switch to Dashboard Tab</span>
                    <div class="keyboard-shortcut-keys"><span
                            class="keyboard-shortcut-key">Alt</span><span>+</span><span
                            class="keyboard-shortcut-key">5</span></div>
                </div>
            </div>
            <div class="modal-action">
                <button class="btn" @click="showKeyboardShortcutsModal = false">Close</button>
            </div>
        </div>
        <form method="dialog" class="modal-backdrop">
            <button @click="showKeyboardShortcutsModal = false">close</button>
        </form>
    </dialog>
    <dialog id="branchComparisonModal" class="modal" :class="{ 'modal-open': showBranchComparisonModal }">
        <div class="modal-box max-w-4xl">
            <h3 class="font-bold text-lg">Branch Comparison</h3>
            <div class="flex justify-between items-center text-sm mt-1 mb-3">
                <div><span class="font-medium">Current Branch:</span> <span x-text="currentBranchName"></span></div>
                <div><span class="font-medium">Comparing with:</span> <span x-text="comparisonBranchName"></span></div>
            </div>
            <div class="comparison-view">
                <div class="comparison-branch">
                    <div class="comparison-header">Current Branch</div>
                    <div class="space-y-2">
                        <template x-for="(message, index) in branchComparison.current" :key="index">
                            <div class="p-2 rounded"
                                :class="{ 'bg-base-200': message.status === 'unchanged', 'bg-success/10 border-success/20 border': message.status === 'added', 'bg-warning/10 border-warning/20 border': message.status === 'changed', 'bg-base-200 opacity-40': message.status === 'missing' }">
                                <div class="flex justify-between text-xs mb-1"> <span x-text="message.role"></span>
                                    <span class="badge badge-xs"
                                        :class="{ 'badge-success': message.status === 'added', 'badge-warning': message.status === 'changed', 'badge-ghost': message.status === 'unchanged', 'badge-ghost opacity-40': message.status === 'missing' }"
                                        x-text="message.status"></span>
                                </div>
                                <div class="text-xs line-clamp-3" x-text="message.content"></div>
                            </div>
                        </template>
                    </div>
                </div>
                <div class="comparison-branch">
                    <div class="comparison-header">Comparison Branch</div>
                    <div class="space-y-2">
                        <template x-for="(message, index) in branchComparison.comparison" :key="index">
                            <div class="p-2 rounded"
                                :class="{ 'bg-base-200': message.status === 'unchanged', 'bg-success/10 border-success/20 border': message.status === 'added', 'bg-warning/10 border-warning/20 border': message.status === 'changed', 'bg-base-200 opacity-40': message.status === 'missing' }">
                                <div class="flex justify-between text-xs mb-1"> <span x-text="message.role"></span>
                                    <span class="badge badge-xs"
                                        :class="{ 'badge-success': message.status === 'added', 'badge-warning': message.status === 'changed', 'badge-ghost': message.status === 'unchanged', 'badge-ghost opacity-40': message.status === 'missing' }"
                                        x-text="message.status"></span>
                                </div>
                                <div class="text-xs line-clamp-3" x-text="message.content"></div>
                            </div>
                        </template>
                    </div>
                </div>
            </div>
            <div class="modal-action">
                <button class="btn btn-sm" @click="showBranchComparisonModal = false">Close</button>
                <button class="btn btn-sm btn-primary" @click="exportBranchComparison">Export Comparison</button>
            </div>
        </div>
        <form method="dialog" class="modal-backdrop"> <button @click="showBranchComparisonModal = false">close</button>
        </form>
    </dialog>
    <dialog id="templatesModal" class="modal" :class="{ 'modal-open': showTemplatesModal }">
        <div class="modal-box max-w-2xl">
            <h3 class="font-bold text-lg">Message Templates</h3>
            <div class="py-4">
                <button class="btn btn-sm btn-primary mb-4" @click="showCreateTemplateForm = true"
                    x-show="!showCreateTemplateForm && !editingTemplate"><i class="fas fa-plus mr-1"></i> New
                    Template</button>
                <div class="mb-4 p-3 bg-base-200 rounded-lg" x-show="showCreateTemplateForm || editingTemplate">
                    <h4 class="text-sm font-medium mb-2"
                        x-text="editingTemplate ? 'Edit Template' : 'Create New Template'"></h4>
                    <div class="form-control mb-2"> <label class="label py-1"><span class="label-text text-xs">Template
                                Name</span></label> <input type="text" class="input input-bordered input-sm"
                            x-model="templateForm.name" placeholder="e.g., Greeting, Bug Report, etc.">
                    </div>
                    <div class="form-control mb-2"> <label class="label py-1"><span
                                class="label-text text-xs">Description (Optional)</span></label> <input type="text"
                            class="input input-bordered input-sm" x-model="templateForm.description"
                            placeholder="Short description of this template"> </div>
                    <div class="form-control mb-2"> <label class="label py-1"><span class="label-text text-xs">Template
                                Content</span></label> <textarea class="textarea textarea-bordered h-24 text-sm"
                            x-model="templateForm.content" placeholder="Type your template content here..."></textarea>
                    </div>
                    <div class="flex justify-end gap-2 mt-3"> <button class="btn btn-sm btn-ghost"
                            @click="cancelTemplateEdit">Cancel</button> <button class="btn btn-sm btn-primary"
                            @click="saveTemplate">Save Template</button> </div>
                </div>
                <div class="space-y-2 max-h-80 overflow-y-auto" x-show="!showCreateTemplateForm && !editingTemplate">
                    <div x-show="messageTemplates.length === 0" class="text-center p-4 text-base-content/60"> No
                        templates found. Create one to get started!
                    </div>
                    <template x-for="template in messageTemplates" :key="template.id">
                        <div class="template-item" @click="applyTemplate(template)">
                            <div class="flex justify-between">
                                <div class="template-name" x-text="template.name"></div>
                                <div class="flex gap-1"><button class="btn btn-xs btn-ghost"
                                        @click.stop="editTemplate(template)"><i class="fas fa-edit"></i></button><button
                                        class="btn btn-xs btn-ghost text-error"
                                        @click.stop="deleteTemplate(template.id)"><i
                                            class="fas fa-trash-alt"></i></button></div>
                            </div>
                            <div class="template-description" x-text="template.description || 'No description'"></div>
                        </div>
                    </template>
                </div>
            </div>
            <div class="modal-action"> <button class="btn" @click="showTemplatesModal = false">Close</button> </div>
        </div>
        <form method="dialog" class="modal-backdrop"> <button @click="showTemplatesModal = false">close</button> </form>
    </dialog>
    <dialog id="addTagModal" class="modal" :class="{ 'modal-open': showAddTagModal }">
        <div class="modal-box">
            <h3 class="font-bold text-lg">Create New Tag</h3>
            <div class="py-4">
                <div class="form-control mb-2"> <label class="label py-1"><span class="label-text">Tag
                            Name</span></label> <input type="text" class="input input-bordered" x-model="newTag.name"
                        placeholder="e.g., Important, Bug, Feature">
                </div>
                <div class="form-control mb-2">
                    <label class="label py-1"><span class="label-text">Tag
                            Color</span></label>
                    <div id="tag-color-picker" class="color-picker-container"></div>
                </div>
            </div>
            <div class="modal-action"> <button class="btn btn-ghost" @click="showAddTagModal = false">Cancel</button>
                <button class="btn btn-primary" @click="createTag">Create Tag</button>
            </div>
        </div>
        <form method="dialog" class="modal-backdrop"> <button @click="showAddTagModal = false">close</button> </form>
    </dialog>
    <dialog id="renameBranchModal" class="modal" :class="{ 'modal-open': showRenameBranchModal }">
        <div class="modal-box">
            <h3 class="font-bold text-lg">Rename Branch</h3>
            <div class="py-4">
                <div class="form-control"> <label class="label py-1"><span class="label-text">New Branch
                            Name</span></label> <input type="text" class="input input-bordered"
                        x-model="renameBranchForm.name" placeholder="Enter new branch name">
                </div>
            </div>
            <div class="modal-action"> <button class="btn btn-ghost"
                    @click="showRenameBranchModal = false">Cancel</button> <button class="btn btn-primary"
                    @click="saveBranchRename">Rename</button> </div>
        </div>
        <form method="dialog" class="modal-backdrop"> <button @click="showRenameBranchModal = false">close</button>
        </form>
    </dialog>
    <dialog id="bookmarksModal" class="modal" :class="{ 'modal-open': showBookmarksModal }">
        <div class="modal-box">
            <h3 class="font-bold text-lg">Bookmarked Messages</h3>
            <div class="py-4">
                <div x-show="bookmarkedMessages.length === 0" class="text-center p-4 text-base-content/60"> No bookmarks
                    yet. Click the bookmark icon on any message to save it.
                </div>
                <div class="space-y-2 max-h-80 overflow-y-auto">
                    <template x-for="bookmark in bookmarkedMessages" :key="bookmark.timestamp + '_' + bookmark.nodeId">
                        <div class="bg-base-200 p-2 rounded hover:bg-base-300 cursor-pointer transition-colors"
                            @click="navigateToBookmark(bookmark)">
                            <div class="flex justify-between items-center text-sm mb-1">
                                <div> <span class="badge badge-xs"
                                        :class="{ 'badge-primary': bookmark.role === 'user', 'badge-secondary': bookmark.role === 'assistant', 'badge-neutral': bookmark.role === 'system' }"
                                        x-text="bookmark.role"></span> <span class="text-xs ml-1 opacity-70"
                                        x-text="bookmark.nodeName || 'Unnamed Branch'"></span> </div>
                                <div class="flex items-center gap-2"> <span class="text-xs opacity-70"
                                        x-text="formatTimestamp(bookmark.timestamp)"></span> <button
                                        class="btn btn-xs btn-ghost text-error"
                                        @click.stop="removeBookmark(bookmark.timestamp, bookmark.nodeId)"><i
                                            class="fas fa-times"></i></button></div>
                            </div>
                            <div class="text-xs line-clamp-3" x-text="bookmark.content"></div>
                        </div>
                    </template>
                </div>
            </div>
            <div class="modal-action"> <button class="btn" @click="showBookmarksModal = false">Close</button> </div>
        </div>
        <form method="dialog" class="modal-backdrop"> <button @click="showBookmarksModal = false">close</button> </form>
    </dialog>
    <dialog id="toolDetailsModal" class="modal" :class="{ 'modal-open': showToolDetailsModal }"
        @keydown.escape.window="showToolDetailsModal = false">
        <div class="modal-box w-11/12 max-w-4xl bg-base-100">
            <h3 class="font-bold text-lg mb-3 flex items-center gap-2"> <i class="fas fa-info-circle text-info"></i>
                <span x-text="selectedTool?.name || 'Tool Details'"></span>
            </h3>
            <div class="mb-4 grid grid-cols-1 gap-y-1 text-sm">
                <p><span class="font-semibold">Server:</span> <span class="badge badge-ghost"
                        x-text="selectedTool?.server_name"></span></p>
            </div>
            <div class="mb-4">
                <h4 class="font-semibold text-sm mb-2 flex items-center gap-1 text-primary"> <i class="fas fa-book"></i>
                    Documentation
                </h4>
                <div class="bg-base-200 rounded-md p-4 border border-base-300 max-h-96 overflow-y-auto">
                    <div x-html="renderDocstring(selectedTool?.description)"></div>
                </div>
            </div>
            <div class="mb-4">
                <h4 class="font-semibold text-sm mb-2 flex items-center gap-1 text-primary"> <i class="fas fa-code"></i>
                    Input Schema
                </h4>
                <div
                    class="bg-base-200 p-4 rounded border border-base-300 max-h-80 overflow-y-auto text-sm relative group">
                    <pre><code class="language-json" x-text="JSON.stringify(selectedTool?.input_schema || {}, null, 2)"></code></pre>
                    <button class="copy-code-btn" x-data="{ copied: false }"
                        @click.stop="document.body.dispatchEvent(new CustomEvent('copy-clipboard', { detail: btoa(encodeURIComponent(JSON.stringify(selectedTool?.input_schema || {}, null, 2))) })); copied = true; setTimeout(() => copied = false, 1500)"
                        <i class="fas mr-1" :class="copied ? 'fa-check text-success' : 'fa-copy'"></i> <span
                            x-text="copied ? 'Copied!' : 'Copy'"></span> </button>
                </div>
            </div>
            <div class="mt-5 border-t border-base-300 pt-4">
                <h4 class="font-semibold text-sm mb-2 flex items-center gap-1 text-primary"> <i class="fas fa-play"></i>
                    Execute Tool Directly
                </h4>
                <textarea class="textarea textarea-bordered w-full text-sm font-mono" rows="4"
                    placeholder='Enter JSON parameters... e.g., {"query": "example"}' x-model="directToolParams"
                    @drop.prevent="handleToolParamsDrop($event)" @dragover.prevent="isDraggingOverToolParams = true"
                    @dragleave.prevent="isDraggingOverToolParams = false"
                    :class="{'bg-base-200/50 border-dashed border-2': isDraggingOverToolParams}"></textarea>
                <button class="btn btn-sm btn-primary mt-2" @click="executeToolDirectly"
                    :disabled="!selectedTool || isLoadingDirectTool" :class="{'loading': isLoadingDirectTool}"> <i
                        class="fas fa-play mr-1"></i> Execute </button>
                <div x-show="directToolResult || directToolError"
                    class="mt-3 bg-base-200 p-4 rounded border border-base-300 max-h-60 overflow-y-auto relative group">
                    <h5 class="font-semibold mb-2" :class="directToolError ? 'text-error' : 'text-success'"
                        x-text="directToolError ? 'Error:' : 'Result:'"></h5>
                    <pre
                        class="text-sm"><code class="language-json whitespace-pre-wrap break-all" x-text="directToolError ? directToolError : JSON.stringify(directToolResult?.content, null, 2)"></code></pre>
                    <button x-show="!directToolError && directToolResult" class="copy-code-btn"
                        x-data="{ copied: false }"
                        @click.stop="document.body.dispatchEvent(new CustomEvent('copy-clipboard', { detail: btoa(encodeURIComponent(JSON.stringify(directToolResult?.content, null, 2))) })); copied = true; setTimeout(() => copied = false, 1500)"
                        <i class="fas mr-1" :class="copied ? 'fa-check text-success' : 'fa-copy'"></i> <span
                            x-text="copied ? 'Copied!' : 'Copy Result'"></span> </button>
                </div>
            </div>
            <div class="modal-action mt-4"> <button class="btn btn-ghost"
                    @click="showToolDetailsModal = false">Close</button> </div>
        </div>
        <form method="dialog" class="modal-backdrop"> <button @click="showToolDetailsModal = false">close</button>
        </form>
    </dialog>
    <dialog id="serverDetailsModal" class="modal" :class="{ 'modal-open': showServerDetailsModal }"
        @keydown.escape.window="showServerDetailsModal = false">
        <div class="modal-box w-11/12 max-w-xl bg-base-100">
            <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"
                @click="showServerDetailsModal = false">âœ•</button>
            <h3 class="font-bold text-lg mb-4 flex items-center gap-2"> <i class="fas fa-server text-primary"></i>Server
                Details: <span class="font-mono" x-text="selectedServerDetails?.name || 'Loading...'"></span>
            </h3>
            <div x-show="isLoadingServerDetails" class="text-center p-6"><span
                    class="loading loading-spinner loading-lg"></span></div>
            <template x-if="selectedServerDetails">
                <div class="space-y-3 text-sm" x-transition>
                    <div class="grid grid-cols-2 gap-x-4 gap-y-1 text-xs border-b border-base-300/30 pb-2 mb-2">
                        <div><strong>Status:</strong> <span class="badge badge-sm"
                                :class="selectedServerDetails.is_connected ? 'badge-success' : 'badge-error'"
                                x-text="selectedServerDetails.is_connected ? 'Connected' : 'Disconnected'"></span></div>
                        <div><strong>Type:</strong> <span class="badge badge-sm badge-outline"
                                x-text="selectedServerDetails.type"></span></div>
                        <div><strong>Enabled:</strong> <span
                                x-text="selectedServerDetails.enabled ? 'Yes' : 'No'"></span></div>
                        <div><strong>Trusted:</strong> <span
                                x-text="selectedServerDetails.trusted ? 'Yes' : 'No'"></span></div>
                        <div class="col-span-2"><strong>Path/URL:</strong> <code class="text-xs break-all"
                                x-text="selectedServerDetails.path"></code></div>
                        <div class="col-span-2" x-show="selectedServerDetails.args?.length > 0"><strong>Args:</strong>
                            <code class="text-xs" x-text="selectedServerDetails.args?.join(' ')"></code>
                        </div>
                        <div class="col-span-2"><strong>Description:</strong> <span class="opacity-80"
                                x-text="selectedServerDetails.description || 'N/A'"></span></div>
                        <div x-show="selectedServerDetails.version"><strong>Version:</strong> <span
                                x-text="selectedServerDetails.version"></span></div>
                        <div x-show="selectedServerDetails.registry_url"><strong>Registry:</strong> <a
                                :href="selectedServerDetails.registry_url" target="_blank"
                                class="link link-info text-xs" x-text="selectedServerDetails.registry_url"></a></div>
                        <div><strong>Timeout:</strong> <span x-text="selectedServerDetails.timeout + 's'"></span></div>
                        <div><strong>Retries:</strong> <span x-text="selectedServerDetails.retry_count"></span></div>
                    </div>
                    <details
                        class="collapse collapse-arrow border border-base-300/30 bg-base-200/50 rounded-md text-xs">
                        <summary class="collapse-title text-xs font-medium py-1.5 min-h-0">Metrics</summary>
                        <div class="collapse-content !px-0 !pb-0">
                            <div class="p-2 grid grid-cols-2 gap-x-3 gap-y-1">
                                <div><strong>Health:</strong> <span class="uppercase font-semibold"
                                        :class="{ 'text-success': selectedServerDetails.metrics?.status === 'healthy', 'text-warning': selectedServerDetails.metrics?.status === 'degraded', 'text-error': selectedServerDetails.metrics?.status === 'error' }"
                                        x-text="selectedServerDetails.metrics?.status || 'Unknown'"></span></div>
                                <div><strong>Avg Resp:</strong> <span
                                        x-text="(selectedServerDetails.metrics?.avg_response_time_ms || 0).toFixed(1) + ' ms'"></span>
                                </div>
                                <div><strong>Requests:</strong> <span
                                        x-text="selectedServerDetails.metrics?.request_count || 0"></span></div>
                                <div><strong>Errors:</strong> <span class="font-semibold"
                                        :class="{'text-error': (selectedServerDetails.metrics?.error_count || 0) > 0}"
                                        x-text="selectedServerDetails.metrics?.error_count || 0"></span></div>
                                <div><strong>Error Rate:</strong> <span
                                        x-text="(selectedServerDetails.metrics?.error_rate || 0).toFixed(2) * 100 + '%'"></span>
                                </div>
                                <div><strong>Uptime:</strong> <span
                                        x-text="(selectedServerDetails.metrics?.uptime_minutes || 0).toFixed(1) + ' min'"></span>
                                </div>
                                <div class="col-span-2"><strong>Last Check:</strong> <span
                                        x-text="formatTimestamp(selectedServerDetails.metrics?.last_checked)"></span>
                                </div>
                            </div>
                        </div>
                    </details>
                    <details x-show="selectedServerDetails.type === 'stdio' && selectedServerDetails.process_info"
                        class="collapse collapse-arrow border border-base-300/30 bg-base-200/50 rounded-md text-xs">
                        <summary class="collapse-title text-xs font-medium py-1.5 min-h-0">Process Info (STDIO)
                        </summary>
                        <div class="collapse-content !px-0 !pb-0">
                            <div class="p-2 grid grid-cols-2 gap-x-3 gap-y-1"
                                x-show="!selectedServerDetails.process_info?.error">
                                <div><strong>PID:</strong> <span
                                        x-text="selectedServerDetails.process_info?.pid"></span></div>
                                <div><strong>Status:</strong> <span
                                        x-text="selectedServerDetails.process_info?.status"></span></div>
                                <div><strong>CPU:</strong> <span
                                        x-text="(selectedServerDetails.process_info?.cpu_percent || 0).toFixed(1) + '%'"></span>
                                </div>
                                <div><strong>Memory (RSS):</strong> <span
                                        x-text="(selectedServerDetails.process_info?.memory_rss_mb || 0).toFixed(1) + ' MB'"></span>
                                </div>
                                <div class="col-span-2"><strong>Created:</strong> <span
                                        x-text="formatTimestamp(selectedServerDetails.process_info?.create_time)"></span>
                                </div>
                            </div>
                            <div class="p-2 text-error" x-show="selectedServerDetails.process_info?.error">
                                <strong>Error:</strong> <span x-text="selectedServerDetails.process_info?.error"></span>
                            </div>
                        </div>
                    </details>
                </div>
            </template>
            <div x-show="!isLoadingServerDetails && !selectedServerDetails" class="text-center text-error p-4">Failed to
                load server details.
            </div>
            <div class="modal-action mt-4">
                <button class="btn btn-sm btn-ghost" @click="showServerDetailsModal = false">Close</button>
                <button class="btn btn-sm btn-outline" @click="fetchServerDetails(selectedServerDetails?.name)"
                    :disabled="isLoadingServerDetails"> <i class="fas fa-sync mr-1"
                        :class="{'fa-spin': isLoadingServerDetails}"></i> Refresh </button>
            </div>
        </div>
        <form method="dialog" class="modal-backdrop"><button @click="showServerDetailsModal = false">close</button>
        </form>
    </dialog>
    <!-- Notifications Area -->
    <div
        class="toast toast-bottom toast-center md:toast-top md:toast-end z-[100] w-full md:w-auto max-w-xs md:max-w-sm">
        <template x-for="(notification, index) in notifications" :key="notification.id">
            <div :class="['alert', `alert-${notification.type || 'info'}`, 'shadow-lg', 'flex', '!items-start']"
                x-show="notification.visible" x-transition:enter="animate__animated animate__fadeInUp animate__faster"
                x-transition:leave="animate__animated animate__fadeOutDown animate__faster">
                <i :class="notificationIcon(notification.type)" class="text-lg mt-1"></i>
                <span class="text-sm flex-1" x-text="notification.message"></span>
                <button class="btn btn-xs btn-ghost p-0 ml-2" @click="dismissNotification(notification.id)"><i
                        class="fas fa-times"></i></button>
            </div>
        </template>
    </div>
    <!-- Global Loading Overlay -->
    <div x-show="isLoading && !isSendingMessage" x-transition.opacity.duration.100ms
        class="loading-overlay animate__animated animate__fadeIn animate__faster">
        <span class="loading loading-ring loading-lg text-primary"></span>
    </div>
    <script>
        const API_BASE_URL = 'http://localhost:8880/api'; // Adjust port as needed
        const WS_URL = 'ws://localhost:8880/ws/chat'; // Adjust hostname/port to match backend

        // ContrastOptimizer Class (as provided previously)
        class ContrastOptimizer {
            constructor() {
                this.colorCache = new Map();
                this.effectiveBgCache = new WeakMap();
                this.gammaTable = new Array(256);
                for (let i = 0; i < 256; i++) {
                    const v = i / 255;
                    this.gammaTable[i] = v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
                }
                console.log("ContrastOptimizer initialized.");
            }
            clearCaches() {
                this.colorCache.clear();
                this.effectiveBgCache = new WeakMap();
                console.log("Contrast optimizer caches cleared");
            }
            parseColor(colorString) {
                if (!colorString) return null;
                const normalized = colorString.trim().toLowerCase();
                if (this.colorCache.has(normalized)) {
                    return this.colorCache.get(normalized);
                }
                let result = null;
                try {
                    if (normalized === 'transparent' || normalized === 'rgba(0, 0, 0, 0)') {
                        result = {
                            r: 0,
                            g: 0,
                            b: 0,
                            a: 0
                        };
                    } else if (normalized.startsWith('#')) {
                        let hex = normalized.substring(1);
                        const len = hex.length;
                        if (len === 3 || len === 4) {
                            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + (len === 4 ? hex[3] + hex[3] : '');
                        }
                        if (hex.length === 6 || hex.length === 8) {
                            const bigint = Number(`0x${hex}`);
                            if (!isNaN(bigint)) {
                                const r = (hex.length === 8 ? bigint >> 24 : bigint >> 16) & 255;
                                const g = (hex.length === 8 ? bigint >> 16 : bigint >> 8) & 255;
                                const b = (hex.length === 8 ? bigint >> 8 : bigint) & 255;
                                const a = hex.length === 8 ? ((bigint & 255) === 255 ? 1 : (bigint & 255) / 255) : 1;
                                result = {
                                    r,
                                    g,
                                    b,
                                    a
                                };
                            }
                        }
                    } else if (normalized.startsWith('rgb')) {
                        const isRgba = normalized.startsWith('rgba');
                        const start = isRgba ? 5 : 4;
                        const end = normalized.lastIndexOf(')');
                        if (end > start) {
                            const inner = normalized.slice(start, end);
                            const parts = inner.split(',').map(part => part.trim());
                            if (parts.length >= 3) {
                                const r = Number(parts[0]) | 0;
                                const g = Number(parts[1]) | 0;
                                const b = Number(parts[2]) | 0;
                                const a = parts.length > 3 ? Number(parts[3]) : 1;
                                if (!isNaN(r) && !isNaN(g) && !isNaN(b) && !isNaN(a)) {
                                    result = {
                                        r,
                                        g,
                                        b,
                                        a
                                    };
                                }
                            }
                        }
                    } else if (normalized.startsWith('oklch')) {
                        const end = normalized.lastIndexOf(')');
                        if (end > 6) {
                            const inner = normalized.slice(6, end);
                            const parts = inner.split(/\s+/);
                            if (parts.length >= 3) {
                                const l = parseFloat(parts[0]);
                                let a = 1;
                                if (parts.length > 3) {
                                    if (parts[3] === '/' && parts.length > 4) {
                                        a = parseFloat(parts[4]);
                                    } else if (parts[3].startsWith('/')) {
                                        a = parseFloat(parts[3].substring(1));
                                    } else {
                                        a = parseFloat(parts[3]);
                                    }
                                } else if (parts[2].includes('/')) {
                                    const alphaPart = parts[2].split('/');
                                    if (alphaPart.length === 2) a = parseFloat(alphaPart[1]);
                                }
                                if (!isNaN(l) && !isNaN(a)) {
                                    const gray = Math.round(l * 255);
                                    result = {
                                        r: gray,
                                        g: gray,
                                        b: gray,
                                        a
                                    };
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.warn("Error parsing color:", colorString, e);
                }
                this.colorCache.set(normalized, result);
                return result;
            }
            getLuminance(r, g, b) {
                if (r === undefined || g === undefined || b === undefined) return 0;
                r = Math.max(0, Math.min(255, r | 0));
                g = Math.max(0, Math.min(255, g | 0));
                b = Math.max(0, Math.min(255, b | 0));
                return this.gammaTable[r] * 0.2126 + this.gammaTable[g] * 0.7152 + this.gammaTable[b] * 0.0722;
            }
            getEffectiveBackgroundColor(element, stopElement) {
                if (!element) return {
                    r: 255,
                    g: 255,
                    b: 255,
                    a: 1
                };
                if (this.effectiveBgCache.has(element)) {
                    return this.effectiveBgCache.get(element);
                }
                let current = element;
                let bgColor = null;
                while (current && current !== stopElement && current !== document.body) {
                    const style = window.getComputedStyle(current);
                    const parsedBg = this.parseColor(style.backgroundColor);
                    if (parsedBg && parsedBg.a > 0) {
                        bgColor = parsedBg;
                        break;
                    }
                    current = current.parentElement;
                }
                if (!bgColor) {
                    const stopEl = stopElement || document.body;
                    bgColor = this.parseColor(window.getComputedStyle(stopEl).backgroundColor) || {
                        r: 255,
                        g: 255,
                        b: 255,
                        a: 1
                    };
                }
                this.effectiveBgCache.set(element, bgColor);
                return bgColor;
            }
            fixContrastRecursively(element, stopElement) {
                if (!element || typeof window.getComputedStyle !== 'function' || element === stopElement?.parentElement) {
                    return;
                }
                this.checkAndFixElementContrast(element, stopElement);
                const children = element.children;
                for (let i = 0; i < children.length; i++) {
                    if (children[i] !== element) {
                        this.fixContrastRecursively(children[i], stopElement);
                    }
                }
            }
            checkAndFixElementContrast(element, stopElement) {
                if (!element || element === stopElement || element.classList.contains('chat-bubble') || !element.offsetParent || element.tagName === 'SCRIPT' || element.tagName === 'STYLE' || element.tagName === 'BUTTON') {
                    return;
                }
                const style = window.getComputedStyle(element);
                const textColor = this.parseColor(style.color);
                if (!textColor || textColor.a === 0) {
                    return;
                }
                const effectiveBgColor = this.getEffectiveBackgroundColor(element, stopElement);
                if (!effectiveBgColor) {
                    return;
                }
                const textLuminance = this.getLuminance(textColor.r, textColor.g, textColor.b);
                const bgLuminance = this.getLuminance(effectiveBgColor.r, effectiveBgColor.g, effectiveBgColor.b);
                const epsilon = 1e-6;
                const contrastRatio = bgLuminance > textLuminance ? (bgLuminance + 0.05 + epsilon) / (textLuminance + 0.05 + epsilon) : (textLuminance + 0.05 + epsilon) / (bgLuminance + 0.05 + epsilon);
                const contrastThreshold = 3.0;
                const safeDarkColor = '#1f2937';
                const safeLightColor = '#f9fafb';
                if (contrastRatio < contrastThreshold) {
                    const targetColor = bgLuminance < 0.5 ? safeLightColor : safeDarkColor;
                    const currentColor = element.style.getPropertyValue('color');
                    if (currentColor !== targetColor) {
                        requestAnimationFrame(() => {
                            element.style.setProperty('color', targetColor, 'important');
                        });
                    }
                }
            }
        }

        // safeDebugStringify (as provided previously)
        window.safeDebugStringify = function (obj, indent = 2) {
            const seen = new WeakSet();
            return JSON.stringify(obj, (key, value) => {
                if (value && typeof value === 'object' && value.nodeType > 0) {
                    return `[DOM Node: ${value.nodeName || 'unknown'}]`;
                }
                if (typeof value === 'function') {
                    return `[Function: ${value.name || 'anonymous'}]`;
                }
                if (value !== null && typeof value === 'object') {
                    if (seen.has(value)) {
                        return '[Circular Reference]';
                    }
                    seen.add(value);
                }
                return value;
            }, indent);
        };

        document.addEventListener('alpine:init', () => {
            Alpine.store('conversation', {
                currentNodeId: 'root',
                conversationNodes: [{
                    id: 'root',
                    name: 'Root',
                    parentId: null,
                    childrenIds: []
                }],
                setCurrentNodeId(id) {
                    this.currentNodeId = id;
                },
                setNodes(nodes) {
                    this.conversationNodes = nodes;
                }
            });

            Alpine.data('mcpClientUI', () => ({
                // ===== LOCAL STORAGE HELPERS =====
                loadFromStorage(key, defaultValue) {
                    if (!key) {
                        console.warn("loadFromStorage called with invalid key.");
                        return defaultValue;
                    }
                    const saved = localStorage.getItem(key);
                    if (saved) {
                        try {
                            return JSON.parse(saved);
                        } catch (e) {
                            console.error(`Failed to parse localStorage key "${key}":`, e, "Raw value:", saved);
                            // Optional: remove invalid item
                            // localStorage.removeItem(key);
                            return defaultValue; // Return default if parsing fails
                        }
                    }
                    return defaultValue; // Return default if not found
                },

                saveToStorage(key, value) {
                    if (!key) {
                        console.warn("saveToStorage called with invalid key.");
                        return;
                    }
                    try {
                        if (value === undefined) {
                            // Avoid storing 'undefined' string directly
                            localStorage.removeItem(key);
                            console.log(`Removed localStorage key "${key}" due to undefined value.`);
                        } else {
                            localStorage.setItem(key, JSON.stringify(value));
                        }
                    } catch (e) {
                        console.error(`Failed to save localStorage key "${key}":`, e, "Value:", value);
                        this.addNotification(`Failed to save setting for ${key}`, 'error'); // Notify user
                    }
                },
                // ===== END LOCAL STORAGE HELPERS =====
                servers: [],
                discoveredServers: [],
                tools: [],
                resources: [],
                prompts: [],
                currentConversation: [],
                config: {
                    defaultModel: '',
                    defaultMaxTokens: 8000,
                    temperature: 0.7,
                    enableStreaming: true,
                    enableCaching: true,
                    autoDiscover: true,
                    enableLocalDiscovery: true,
                    dashboardRefreshRate: 2.0,
                    enablePortScanning: true,
                    anthropicApiKey: null,
                    openaiApiKey: null,
                    geminiApiKey: null,
                    grokApiKey: null,
                    deepseekApiKey: null,
                    mistralApiKey: null,
                    groqApiKey: null,
                    cerebrasApiKey: null,
                    openrouterApiKey: null,
                    openaiBaseUrl: null,
                    geminiBaseUrl: null,
                    grokBaseUrl: null,
                    deepseekBaseUrl: null,
                    mistralBaseUrl: null,
                    groqBaseUrl: null,
                    cerebrasBaseUrl: null,
                    openrouterBaseUrl: null
                },
                modelsByProvider: {},
                currentModel: '',
                userInput: '',
                isLoading: false,
                isLoadingServers: false,
                isLoadingTools: false,
                isLoadingDiscovery: false,
                isLoadingImport: false,
                isSendingMessage: false,
                activeTab: 'servers',
                showAddServerModal: false,
                showToolDetailsModal: false,
                showServerDetailsModal: false,
                showKeyboardShortcutsModal: false,
                showBranchComparisonModal: false,
                showAddTagModal: false,
                showTemplatesModal: false,
                showBookmarksModal: false,
                showCreateTemplateForm: false,
                showRenameBranchModal: false,
                selectedTool: null,
                newServer: {
                    name: '',
                    type: 'stdio',
                    path: '',
                    argsString: ''
                },
                notifications: [],
                availableThemes: ["corporate", "light", "dark", "cupcake", "bumblebee", "emerald", "synthwave", "retro", "cyberpunk", "valentine", "halloween", "garden", "forest", "aqua", "lofi", "pastel", "fantasy", "wireframe", "black", "luxury", "dracula", "cmyk", "autumn", "business", "acid", "lemonade", "night", "coffee", "winter"],
                currentTheme: 'corporate',
                capabilitySearchTerm: '',
                ws: null,
                wsConnected: false,
                wsConnecting: false,
                wsStatus: 'Disconnected',
                wsReconnectAttempts: 0,
                currentStatusMessage: null,
                currentAssistantMessageId: null,
                directToolParams: '{}',
                directToolResult: null,
                directToolError: null,
                isLoadingDirectTool: false,
                discoveredServersTable: null,
                saveConfigTimer: null,
                stopController: null,
                cacheEntries: [],
                cacheDependencies: {},
                isLoadingCache: false,
                cacheEntriesTable: null,
                cacheDepsTable: null,
                isLoadingServerDetails: false,
                selectedServerDetails: null,
                isSidebarOpen: false,
                uiSettings: {
                    showTimestamps: true,
                    groupMessagesByDate: false,
                    compactMode: false,
                    showStatusBar: true,
                    virtualScrolling: false,
                    sendOnEnter: true,
                    showToolDataMessages: true
                },
                bookmarkedMessages: [],
                isMessageSearchActive: false,
                messageSearchQuery: '',
                searchMatches: [],
                currentSearchMatchIndex: -1,
                globalSearchQuery: '',
                searchResults: [],
                searchPerformed: false,
                isSearching: false,
                searchOptions: {
                    caseSensitive: false,
                    wholeWord: false,
                    includeSystem: true
                },
                conversationView: 'branches',
                virtualScrollHeight: 0,
                isBranchComparisonActive: false,
                comparisonBranchId: null,
                comparisonBranchName: '',
                currentBranchName: '',
                branchComparison: {
                    current: [],
                    comparison: []
                },
                comparisonStats: {
                    added: 0,
                    removed: 0,
                    modified: 0,
                    unchanged: 0
                },
                allTags: [],
                conversationTags: [],
                newTag: {
                    name: '',
                    color: '#3B82F6'
                },
                messageTemplates: [],
                editingTemplate: false,
                templateForm: {
                    id: null,
                    name: '',
                    description: '',
                    content: ''
                },
                favoriteTools: [],
                recentTools: [],
                isLoadingDashboard: false,
                dashboardLastUpdated: null,
                dashboardStats: {
                    activeServers: 0,
                    totalTools: 0,
                    totalConversations: 0,
                    totalMessages: 0,
                    cacheHitRate: 0,
                    systemUptime: '0m',
                    topTools: [],
                    serverHealth: []
                },
                toolUsageTimeframe: 'day',
                isCheckingServerHealth: false,
                renameBranchForm: {
                    id: null,
                    name: ''
                },
                isDraggingOverDropZone: false,
                isDraggingOverToolParams: false,
                groupedMessages: {},
                favoriteToolIds: [],
                recentToolIds: [],
                tokenUsage: {
                    input_tokens: 0,
                    output_tokens: 0,
                    total_tokens: 0,
                    total_cost: 0
                },
                showSystemStats: false,
                systemStats: {
                    memory: 0,
                    uptime: '0m'
                },
                originalThemeBeforePreview: null,

                agentStatus: {
                    agent_running: false,
                    status: 'idle', // MCPClient's high-level status (e.g., idle, running, completed)
                    status_display: 'Idle', // User-friendly display string

                    overall_goal_from_mcp_client: '', // The goal MCPClient started the agent with

                    // Details from AgentMasterLoop's state
                    agent_workflow_id: null,
                    agent_thought_chain_id: null,
                    agent_target_model: 'N/A',
                    agent_internal_loop_count: 0,
                    agent_max_loops_from_mcp_config: 0, // Max loops MCPC is running agent for

                    agent_current_ums_goal_id: null,
                    agent_current_ums_goal_description: 'No active UMS goal.', // Full description of current UMS goal
                    agent_local_ums_goal_stack_summary: [], // List of {goal_id, description, status} for stack

                    agent_last_action_summary: 'Agent not initialized or no actions yet.', // AML's last action summary
                    agent_last_general_message: '', // MCPClient's general message about the agent task

                    agent_current_plan_step_summary: 'No active plan.', // Truncated description of current plan step
                    agent_current_plan_step_full_description: 'No active plan.', // Full description
                    agent_current_plan_step_dependencies: [], // List of IDs current step depends on
                    agent_current_full_plan: [], // List of all plan step objects {id, description, status, depends_on, assigned_tool, tool_args, result_summary}
                },
                agentControl: {
                    goal: '',
                    maxLoops: 50,
                    llmModel: '',
                    guidanceText: ''
                },
                isLoadingAgentAction: false,
                isLoadingAgentStatus: false,
                agentStatusInterval: null,
                agentPlanTable: null, // To hold the Tabulator instance for the agent's plan
                currentAgentLlmMessageId: null, // To track the agent's LLM response message ID

                // --- COMPUTED PROPERTIES ---
                get connectedServersCount() {
                    return this.servers.filter(s => s.isConnected).length;
                },
                get currentModelShort() {
                    if (!this.currentModel) return 'N/A';
                    const nameOnly = this.currentModel.split('/').pop();
                    return nameOnly.length > 25 ? nameOnly.substring(0, 22) + '...' : nameOnly;
                },
                get conversationNodes() {
                    return Alpine.store('conversation').conversationNodes;
                },
                get currentNodeId() {
                    return Alpine.store('conversation').currentNodeId;
                },
                get filteredServerCapabilities() {
                    const searchTerm = this.capabilitySearchTerm.toLowerCase().trim();
                    const allCapabilities = [...(this.tools || []).map(t => ({
                        ...t,
                        type: 'tool',
                        shortName: t.name.split(':').pop()
                    })), ...(this.resources || []).map(r => ({
                        ...r,
                        type: 'resource',
                        shortName: r.name.split(':').pop()
                    })), ...(this.prompts || []).map(p => ({
                        ...p,
                        type: 'prompt',
                        shortName: p.name.split(':').pop()
                    }))];
                    const grouped = {};
                    allCapabilities.forEach(cap => {
                        const serverName = cap.server_name;
                        if (!serverName) {
                            console.warn("Capability missing server_name:", cap);
                            return;
                        }
                        if (!grouped[serverName]) {
                            grouped[serverName] = {
                                serverName: serverName,
                                tools: [],
                                resources: [],
                                prompts: []
                            };
                        }
                        if (cap.type === 'tool') grouped[serverName].tools.push(cap);
                        else if (cap.type === 'resource') grouped[serverName].resources.push(cap);
                        else if (cap.type === 'prompt') grouped[serverName].prompts.push(cap);
                    });
                    const filteredGroups = Object.values(grouped).filter(group => {
                        if (!searchTerm) return true;
                        if (group.serverName.toLowerCase().includes(searchTerm)) {
                            return true;
                        }
                        const capabilitiesInGroup = [...group.tools, ...group.resources, ...group.prompts];
                        return capabilitiesInGroup.some(cap => (cap.name && cap.name.toLowerCase().includes(searchTerm)) || (cap.shortName && cap.shortName.toLowerCase().includes(searchTerm)) || (cap.description && cap.description.toLowerCase().includes(searchTerm)) || (cap.template && typeof cap.template === 'string' && cap.template.toLowerCase().includes(searchTerm)));
                    }).map(group => {
                        if (searchTerm) {
                            const filterFn = cap => (cap.name && cap.name.toLowerCase().includes(searchTerm)) || (cap.shortName && cap.shortName.toLowerCase().includes(searchTerm)) || (cap.description && cap.description.toLowerCase().includes(searchTerm)) || (cap.template && typeof cap.template === 'string' && cap.template.toLowerCase().includes(searchTerm));
                            return {
                                ...group,
                                tools: group.tools.filter(filterFn),
                                resources: group.resources.filter(filterFn),
                                prompts: group.prompts.filter(filterFn)
                            };
                        }
                        return group;
                    });
                    filteredGroups.sort((a, b) => a.serverName.localeCompare(b.serverName));
                    filteredGroups.forEach(group => {
                        group.tools.sort((a, b) => a.shortName.localeCompare(b.shortName));
                        group.resources.sort((a, b) => a.shortName.localeCompare(b.shortName));
                        group.prompts.sort((a, b) => a.shortName.localeCompare(b.shortName));
                    });
                    return filteredGroups;
                },
                get totalCapabilities() {
                    return (this.tools?.length || 0) + (this.resources?.length || 0) + (this.prompts?.length || 0);
                },
                getServerByName(name) {
                    return this.servers.find(s => s.name === name);
                },

                // --- LIFECYCLE & INITIALIZATION ---
                init() {
                    console.log('Multi-Provider MCP Client UI Initializing...');
                    this.contrastOptimizer = new ContrastOptimizer(); // Initialize this first
                    this.loadTheme();
                    this.loadConfig();
                    this.loadUISettings();
                    this.loadFavoriteTools();
                    this.loadRecentTools();
                    this.loadBookmarkedMessages();
                    this.loadAllTags();
                    this.loadMessageTemplates();
                    this.tokenUsage = this.loadFromStorage('mcp_token_usage', { input_tokens: 0, output_tokens: 0, total_tokens: 0, total_cost: 0 });
                    this.fetchInitialData().then(() => {
                        this.reconcileFavoriteTools();
                        this.reconcileRecentTools();
                        if (this.uiSettings.groupMessagesByDate) this.updateGroupedMessages();
                        if (this.uiSettings.virtualScrolling) this.updateVirtualScrollHeight();
                        
                        // Fetch initial agent status AFTER other data, as it might depend on config
                        this.fetchAgentStatus(); // Fetch initial agent status
                        // Decide about polling based on initial status
                        if (this.agentStatus.agent_running) {
                            this.startAgentStatusPolling();
                        }
                    });
                    this.connectWebSocket();
                    this.initTippy();
                    this.setupKeyboardShortcuts();
                    this.setupResponsiveHandling();
                    this.addMessageToConversation('system', 'Welcome! Connecting to backend...');
                    this.$watch('servers', () => this.$nextTick(() => this.initTippy()));
                    this.$watch('activeTab', (newTab) => {
                        this.$nextTick(() => this.initTippy());
                        if (newTab === 'config' && !this.isLoadingCache) {
                            this.fetchCacheData();
                        } else if (newTab === 'dashboard' && !this.isLoadingDashboard) {
                            this.refreshDashboardData();
                        } else if (newTab === 'agent') { // Refresh agent status when tab is viewed
                            this.fetchAgentStatus();
                        }
                        if (window.innerWidth < 768) {
                            this.isSidebarOpen = false;
                        }
                    });
                    this.$el.addEventListener('checkout-branch', (event) => {
                        if (event.detail?.id) {
                            this.checkoutBranch(event.detail.id);
                        } else {
                            console.error("checkout-branch event received without ID in detail.");
                        }
                    });
                    this.$watch('currentConversation', (newVal, oldVal) => {
                        if (this.uiSettings.groupMessagesByDate) this.updateGroupedMessages();
                        if (newVal.length !== oldVal.length || (newVal.length > 0 && newVal[newVal.length - 1].content !== oldVal[oldVal.length - 1]?.content)) {
                            this.$nextTick(() => this.initHighlighting(this.$refs.chatbox));
                        }
                        if (this.uiSettings.virtualScrolling) this.updateVirtualScrollHeight();
                    }, {
                        deep: true
                    });
                    this.$watch('uiSettings', (newVal, oldVal) => {
                        this.saveUISettings(newVal);
                        if (newVal.groupMessagesByDate !== oldVal.groupMessagesByDate) {
                            if (newVal.groupMessagesByDate) this.updateGroupedMessages();
                            else this.groupedMessages = {};
                        }
                        if (newVal.virtualScrolling !== oldVal.virtualScrolling) {
                            if (newVal.virtualScrolling) this.updateVirtualScrollHeight();
                            else this.virtualScrollHeight = 0;
                        }
                        document.body.classList.toggle('status-bar-active', newVal.showStatusBar);
                    }, {
                        deep: true
                    });
                    this.$watch('showAddServerModal', (value) => {
                        if (value) {
                            this.$nextTick(() => this.$refs.addServerNameInput?.focus());
                        }
                    });
                    this.addMessageToConversation('system', 'Welcome! Connecting to backend...');
                    this.setupHljsThemeSwitcher();
                    document.body.classList.toggle('status-bar-active', this.uiSettings.showStatusBar);
                    console.log('Multi-Provider MCP Client UI Initialized Successfully (with Agent support).');
                },
                // --- DATA FETCHING ---
                async fetchInitialData() {
                    // Indicate general loading start
                    this.isLoading = true;
                    // Indicate specific loading states (can overlap with global)
                    this.isLoadingServers = true;
                    this.isLoadingTools = true; // Using this for all capabilities
                    console.log(">>> fetchInitialData: START"); // <-- Log Start
                    try {
                        console.log(">>> fetchInitialData: Preparing promises..."); // <-- Log before Promise.allSettled

                        // --- Log each function call BEFORE adding to the array ---
                        console.log(">>> fetchInitialData: Adding fetchServers() to promises");
                        const p1 = this.fetchServers();
                        console.log(">>> fetchInitialData: Adding fetchAvailableModels() to promises");
                        const p2 = this.fetchAvailableModels(); // <-- Make sure this line exists!
                        console.log(">>> fetchInitialData: Adding fetchCapabilities() to promises");
                        const p3 = this.fetchCapabilities();
                        console.log(">>> fetchInitialData: Adding fetchConversation() to promises");
                        const p4 = this.fetchConversation();
                        // --------------------------------------------------------

                        const promises = [p1, p2, p3, p4];
                        console.log(">>> fetchInitialData: Awaiting Promise.allSettled..."); // <-- Log before await

                        const results = await Promise.allSettled(promises);

                        console.log(">>> fetchInitialData: Promise.allSettled finished. Results:", results); // <-- Log results

                        console.log("Initial data fetch results:", results);

                        // Process results (keep existing logic)
                        const endpoints = ['servers', 'models', 'capabilities', 'conversation'];
                        results.forEach((result, index) => {
                            console.log(`>>> fetchInitialData: Processing result for ${endpoints[index]} - Status: ${result.status}`); // <-- Log each result status
                            if (result.status === 'rejected') {
                                console.error(`>>> fetchInitialData: Initial fetch failed for ${endpoints[index]}:`, result.reason);
                                this.addNotification(`Failed to fetch initial ${endpoints[index]}. Check backend connection/logs.`, 'error', 5000);
                            }
                        });

                        // Reset currentModel if it's no longer valid after fetching models
                        // This handles cases where the saved default model isn't available anymore
                        const allModelNames = Object.values(this.modelsByProvider).flat().map(m => m.name);
                        if (!this.currentModel || !allModelNames.includes(this.currentModel)) {
                            const firstAvailableModel = allModelNames.length > 0 ? allModelNames[0] : '';
                            this.currentModel = this.config.defaultModel || firstAvailableModel; // Use config default or first available
                            console.log("Reset currentModel based on fetched list to:", this.currentModel);
                            // If config default was invalid, maybe update it? Or just use session value. Let's just use session for now.
                            // this.saveConfigField('defaultModel', this.currentModel); // Optional: Persist the valid model found
                        }


                        // Check if conversation loaded successfully to show "Ready"
                        if (results[3].status === 'fulfilled') {
                            this.addMessageToConversation('system', 'Backend connected. Ready.');
                        } else {
                            // Conversation fetch failed, potentially critical
                            this.addMessageToConversation('system', 'Warning: Connected, but failed to load conversation state. History might be lost or incomplete.', {
                                content_type: 'system'
                            });
                            // Initialize with empty conversation to prevent errors
                            Alpine.store('conversation').setCurrentNodeId('root');
                            this.currentConversation = [];
                            Alpine.store('conversation').setNodes([{
                                id: 'root',
                                name: 'Root',
                                parentId: null,
                                childrenIds: []
                            }]);
                        }

                    } catch (error) {
                        // Catch unexpected errors during the Promise.allSettled phase itself
                        console.error("Unexpected error during initial data fetch setup:", error);
                        this.addNotification(`Critical error fetching initial data: ${error.message}`, 'error', 10000);
                        this.addMessageToConversation('system', `Failed to connect or fetch initial data: ${error.message}`);
                    } finally {
                        // Ensure all loading indicators are turned off
                        this.isLoadingServers = false;
                        this.isLoadingTools = false;
                        this.isLoading = false;
                        // Trigger reconciliation after data is potentially populated
                        this.reconcileFavoriteTools();
                        this.reconcileRecentTools();
                    }
                }, // End fetchInitialData
                async fetchAvailableModels() {
                    console.log(">>> fetchAvailableModels: Starting fetch...");
                    let rawData = null; // Variable to hold raw response
                    try {
                        rawData = await this.apiFetch('/models');
                        console.log(">>> fetchAvailableModels: Received RAW data from API:", rawData); // Log raw data

                        // Perform validation *before* assignment
                        if (rawData && typeof rawData === 'object' && !Array.isArray(rawData) && Object.keys(rawData).length > 0) {
                            // Basic check: Does it have expected provider keys? Are their values arrays?
                            const looksValid = Object.values(rawData).every(value => Array.isArray(value));
                            if (looksValid) {
                                this.modelsByProvider = {...rawData};

                                // Then add this line after assignment to ensure the UI updates:
                                this.$nextTick(() => {
                                console.log("Triggering UI refresh for model dropdown");
                                // Force a UI refresh on the dropdown
                                const dropdownEl = document.querySelector('.dropdown-end [tabindex="0"]');
                                if (dropdownEl) dropdownEl.click(); // Optional: force open the dropdown
                                });
                                console.log(">>> fetchAvailableModels: ASSIGNED VALID data to this.modelsByProvider.");
                                // Log the assigned data AFTER assignment for comparison
                                console.log(">>> fetchAvailableModels: State AFTER assignment:", JSON.stringify(this.modelsByProvider, null, 2));
                            } else {
                                console.warn(">>> fetchAvailableModels: Received data object has invalid structure (values are not all arrays). Resetting. Data:", rawData);
                                this.modelsByProvider = {}; // Reset
                            }
                        } else {
                            console.warn(">>> fetchAvailableModels: Received invalid data format (not a non-empty object). Resetting. Received:", rawData);
                            this.modelsByProvider = {}; // Reset
                        }
                    } catch (e) {
                        console.error(">>> fetchAvailableModels: Error during fetch:", e);
                        this.modelsByProvider = {}; // Reset on error
                    }
                },

                async fetchAgentStatus() {
                    if (this.isLoadingAgentStatus) return;
                    this.isLoadingAgentStatus = true;
                    // console.log("UI: Fetching agent status via API..."); // Already logged by API call
                    try {
                        const statusData = await this.apiFetch('/agent/status'); 

                        if (statusData && typeof statusData === 'object') {
                            const newAgentStatusState = { ...this.agentStatus }; 
                            for (const key in statusData) {
                                if (statusData.hasOwnProperty(key)) {
                                    newAgentStatusState[key] = statusData[key];
                                }
                            }
                            let display = (newAgentStatusState.status || 'unknown').replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                            if (newAgentStatusState.agent_running && newAgentStatusState.status === 'running') {
                                display = `Running (Loop ${newAgentStatusState.agent_internal_loop_count || 0}/${newAgentStatusState.agent_max_loops_from_mcp_config || 0})`;
                            } else if (newAgentStatusState.status === 'completed') {
                                display = 'Goal Achieved!';
                            }
                            newAgentStatusState.status_display = display;
                            this.agentStatus = newAgentStatusState; 

                            console.log("UI: Agent status updated from API", JSON.parse(JSON.stringify(this.agentStatus)));

                            // Call initAgentPlanTable IF the agent tab is active and plan data is available
                            if (this.activeTab === 'agent' && this.agentStatus.agent_current_full_plan) {
                                this.initAgentPlanTable(this.agentStatus.agent_current_full_plan);
                            } else if (this.activeTab !== 'agent' && this.agentPlanTable) {
                                // If tab is not active, ensure table is destroyed
                                console.log("UI: Agent tab not active, destroying plan table if it exists.");
                                try { this.agentPlanTable.destroy(); } catch(e) { console.warn("Error destroying agent plan table (tab not active):", e); }
                                this.agentPlanTable = null;
                            }


                            if (!this.agentStatus.agent_running && this.agentStatusInterval) {
                                this.stopAgentStatusPolling();
                            } else if (this.agentStatus.agent_running && !this.agentStatusInterval) {
                                this.startAgentStatusPolling();
                            }

                            if (this.uiSettings.showToolDataMessages &&
                                this.agentStatus.agent_last_action_summary && 
                                (!this.lastDisplayedAgentAction || this.lastDisplayedAgentAction !== this.agentStatus.agent_last_action_summary)) {
                                this.addMessageToConversation(
                                    'system', 
                                    this.agentStatus.agent_last_action_summary,
                                    {
                                        is_agent_activity: true, 
                                        content_type: 'agent_log_summary', 
                                        timestamp: new Date().toISOString() 
                                    }
                                );
                                this.lastDisplayedAgentAction = this.agentStatus.agent_last_action_summary;
                            }
                        } else {
                            console.warn("UI: Received non-object or empty data from /api/agent/status:", statusData);
                            this.addNotification('Received invalid status data from server.', 'warning');
                            this.agentStatus.status = 'error_fetching_data'; 
                            this.agentStatus.status_display = 'Error: Invalid Data';
                        }
                    } catch (e) { 
                        this.addNotification(`Failed to fetch agent status: ${e.message || 'Unknown API error'}`, 'error');
                        console.error("UI: Error in fetchAgentStatus during apiFetch:", e);
                        this.agentStatus.status = 'error_fetching_api'; 
                        this.agentStatus.status_display = 'Error: API Unreachable';
                    } finally {
                        this.isLoadingAgentStatus = false;
                    }
                },

                async startAgent() {
                    if (!this.agentControl.goal.trim()) {
                        this.addNotification('Agent goal cannot be empty.', 'warning');
                        return;
                    }
                    const maxLoops = parseInt(this.agentControl.maxLoops, 10);
                    if (isNaN(maxLoops) || maxLoops <= 0) {
                        this.addNotification('Max loops must be a positive number.', 'warning');
                        return;
                    }
                    this.isLoadingAgentAction = true;
                    this.addNotification(`Requesting agent start for goal: "${this.agentControl.goal.substring(0,30)}..."`, 'info');
                    // Clear previous agent messages if any, or start a new "run" section
                    this.addMessageToConversation('system', `--- Agent Run Starting: ${this.agentControl.goal} ---`, { is_agent_activity: true, content_type: 'agent_run_marker' });

                    try {
                        const payload = {
                            goal: this.agentControl.goal,
                            max_loops: maxLoops,
                        };
                        if (this.agentControl.llmModel && this.agentControl.llmModel.trim()) {
                            payload.llm_model = this.agentControl.llmModel.trim();
                        }
                        const result = await this.apiFetch('/agent/start', {
                            method: 'POST',
                            body: JSON.stringify(payload)
                        });
                        
                        this.addNotification(result.message || 'Agent start request processing.', result.success ? 'success' : 'error');
                        
                        // Update status from the response of the start call itself
                        if (result.agent_status) {
                            this.agentStatus = { ...this.agentStatus, ...result.agent_status };
                            let display = this.agentStatus.status?.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) || 'Unknown';
                            if (this.agentStatus.agent_running) display = `Running (Loop ${this.agentStatus.current_loop || 0}/${this.agentStatus.max_loops || 0})`;
                            this.agentStatus.status_display = display;
                            if(this.agentStatus.current_plan_from_agent) this.initAgentPlanTable(this.agentStatus.current_plan_from_agent);


                        } else { // Fallback to fetching status if not in direct response
                            await this.fetchAgentStatus();
                        }

                        if(this.agentStatus.agent_running && !this.agentStatusInterval) {
                            this.startAgentStatusPolling();
                        }
                    } catch (e) {
                        this.addNotification(`Failed to start agent: ${e.message}`, 'error');
                        await this.fetchAgentStatus(); // Refresh status even on error
                    } finally {
                        this.isLoadingAgentAction = false;
                    }
                },

                async stopAgent() {
                    if (!this.agentStatus.agent_running && !['starting', 'stopping', 'stopping_timeout'].includes(this.agentStatus.status)) {
                        this.addNotification('Agent is not currently running or starting.', 'info');
                        return;
                    }
                    this.isLoadingAgentAction = true;
                    this.addNotification('Requesting agent to stop...', 'info');
                    try {
                        const result = await this.apiFetch('/agent/stop', { method: 'POST' });
                        this.addNotification(result.message || 'Agent stop request sent.', result.success ? 'success' : 'warning');
                        
                        if (result.agent_status) {
                            this.agentStatus = { ...this.agentStatus, ...result.agent_status };
                            let display = this.agentStatus.status?.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) || 'Unknown';
                            if (this.agentStatus.agent_running) display = `Running (Loop ${this.agentStatus.current_loop || 0}/${this.agentStatus.max_loops || 0})`;
                            else if (this.agentStatus.status === 'stopped') display = 'Stopped';
                            this.agentStatus.status_display = display;
                            if(this.agentStatus.current_plan_from_agent) this.initAgentPlanTable(this.agentStatus.current_plan_from_agent);

                        } else {
                            await this.fetchAgentStatus();
                        }

                        if (!this.agentStatus.agent_running && this.agentStatusInterval) {
                            this.stopAgentStatusPolling();
                        }
                    } catch (e) {
                        this.addNotification(`Failed to send stop signal: ${e.message}`, 'error');
                        await this.fetchAgentStatus();
                    } finally {
                        this.isLoadingAgentAction = false;
                    }
                },

                startAgentStatusPolling() {
                    if (this.agentStatusInterval) clearInterval(this.agentStatusInterval); // Clear existing before starting new
                    this.agentStatusInterval = setInterval(() => {
                        // Only poll if agent was seen as running or in a transition state by the last fetch
                        if (this.agentStatus.agent_running || 
                            ['starting', 'stopping', 'running', 'stopping_timeout'].includes(this.agentStatus.status)) {
                            this.fetchAgentStatus();
                        } else {
                            this.stopAgentStatusPolling(); // Stop if no longer in an active state
                        }
                    }, 3000); // Poll every 3 seconds
                    console.log("UI: Agent status polling started/restarted.");
                },
                stopAgentStatusPolling() {
                    if (this.agentStatusInterval) {
                        clearInterval(this.agentStatusInterval);
                        this.agentStatusInterval = null;
                        console.log("UI: Agent status polling stopped.");
                    }
                },

                initAgentPlanTable(planData) {
                    const tableId = 'agent-current-plan-table';
                    // Defer to ensure DOM is ready
                    this.$nextTick(() => {
                        const tableElement = document.getElementById(tableId);

                        if (this.activeTab !== 'agent' || !tableElement) {
                            if (this.agentPlanTable) {
                                console.log("UI: Agent tab not active or table element missing. Destroying existing agent plan table.");
                                try {
                                    this.agentPlanTable.destroy();
                                } catch (e) {
                                    console.warn("Error destroying agent plan table:", e);
                                }
                                this.agentPlanTable = null;
                            }
                            return;
                        }

                        const validPlanData = Array.isArray(planData) ? planData : [];
                        const columns = [
                            { title: "ID", field: "id", width: 70, frozen: true, cssClass: "p-1 text-2xs font-mono", 
                              formatter: (cell) => { const val = cell.getValue(); return val ? `...${val.slice(-6)}` : ''; },
                              tooltip: (cell) => cell.getValue()
                            },
                            { title: "Step Description", field: "description", hozAlign: "left", sorter: "string", 
                              minWidth: 250, tooltip: true, cssClass: "p-1 text-xs whitespace-normal", // text-xs for slightly larger plan font
                              formatter: "textarea"
                            },
                            { title: "Status", field: "status", width: 110, hozAlign: "center", cssClass: "p-1 text-2xs", 
                              formatter: (cell) => { /* ... (status formatter from previous good version) ... */
                                    const status = cell.getValue() || "unknown";
                                    let badgeClass = 'badge-ghost'; 
                                    let icon = '<i class="fas fa-question-circle fa-xs mr-1 opacity-50"></i>';
                                    switch(status.toLowerCase()) {
                                        case 'completed': badgeClass = 'badge-success'; icon = '<i class="fas fa-check-circle fa-xs mr-1"></i>'; break;
                                        case 'failed': badgeClass = 'badge-error'; icon = '<i class="fas fa-times-circle fa-xs mr-1"></i>'; break;
                                        case 'in_progress': badgeClass = 'badge-info animate-pulse'; icon = '<i class="fas fa-spinner fa-spin fa-xs mr-1"></i>'; break;
                                        case 'planned': badgeClass = 'badge-outline'; icon = '<i class="fas fa-circle-notch fa-xs mr-1 opacity-50"></i>'; break;
                                        case 'skipped': badgeClass = 'badge-neutral opacity-60'; icon = '<i class="fas fa-forward fa-xs mr-1"></i>'; break;
                                    }
                                    return `<span class="badge badge-sm ${badgeClass} !text-2xs !leading-tight !h-auto !py-0.5 !px-1.5">${icon}${status}</span>`;
                                }
                            },
                            { title: "Tool", field: "assigned_tool", width: 130, hozAlign: "left", cssClass: "p-1 text-2xs truncate", 
                              formatter: (cell) => { const val = cell.getValue(); return val ? val.split(':').pop() : '<span class="italic opacity-50">None</span>'; }, 
                              tooltip: (cell) => cell.getValue() 
                            },
                            { title: "Depends On", field: "depends_on", width: 110, cssClass: "p-1 text-2xs", 
                              formatter: (cell) => { const deps = cell.getValue(); if (!deps || deps.length === 0) return '<span class="italic opacity-50">None</span>'; return deps.map(d => `...${String(d).slice(-6)}`).join(', '); },
                              tooltip: (cell) => { const deps = cell.getValue(); return deps && deps.length > 0 ? deps.join('\n') : 'None'; }
                            }
                        ];
                        
                        const placeholderText = validPlanData.length === 0 ? 
                            "<div class='p-4 text-center text-xs italic opacity-70'>Agent has no active plan steps.</div>" : 
                            "<div class='p-4 text-center text-xs italic opacity-70'>Loading plan...</div>";

                        // If table instance exists and is valid, update its data and placeholder
                        if (this.agentPlanTable && typeof this.agentPlanTable.setData === 'function') {
                            console.log("UI: Updating data for existing Agent Plan Tabulator table.");
                            try {
                                // For Tabulator, you set the placeholder text on the table options
                                // or update it via a method if available for dynamic changes.
                                // If `setPlaceholder` is not a function, we might need to destroy and re-create
                                // or rely on it being set at initialization.
                                // Let's try setting data and if it's empty, placeholder will show.
                                // We can't *change* the placeholder text of an existing instance easily without re-init or specific API.
                                // So, the placeholder used during init will be the one.
                                this.agentPlanTable.setData(validPlanData)
                                    .then(() => { 
                                        this.$nextTick(() => this.initTippy()); 
                                    })
                                    .catch(err => {
                                        console.error("UI: Tabulator setData error for agent plan:", err);
                                        tableElement.innerHTML = `<div class="p-4 text-center text-error text-xs">Error updating plan data.</div>`;
                                    });
                            } catch (e) {
                                console.error("UI: Error calling setData on agent plan table (instance might be invalid):", e);
                                try { this.agentPlanTable.destroy(); } catch(de) {}
                                this.agentPlanTable = null; 
                                // Attempt to re-initialize if setData failed badly
                                this.initAgentPlanTable(planData); // Recursive call - be careful
                            }
                        } 
                        // Else, if table instance does NOT exist, create it
                        else if (!this.agentPlanTable) {
                            console.log("UI: Initializing new Tabulator table for Agent Plan.");
                            tableElement.innerHTML = ''; // Clear previous content/placeholder before new Tabulator
                            try {
                                this.agentPlanTable = new Tabulator(tableElement, {
                                    data: validPlanData,
                                    layout: "fitDataFill", 
                                    height: "200px",    
                                    placeholder: placeholderText, // Set placeholder text here
                                    columns: columns,
                                    movableColumns: true,
                                    resizableRows: false, 
                                    initialSort: [{ column: "id", dir: "asc" }], 
                                    rowFormatter:function(row){ /* ... (rowFormatter from previous good version) ... */
                                        var data = row.getData();
                                        if(data.status === "in_progress"){
                                            row.getElement().style.backgroundColor = "hsl(var(--in)/0.1)"; 
                                            row.getElement().style.fontWeight = "500";
                                        } else if (data.status === "planned") {
                                            let foundInProgress = false;
                                            const tableRows = row.getTable().getRows(); // Get all rows
                                            if (Array.isArray(tableRows)) { // Check if it's an array
                                                tableRows.forEach(r => {
                                                    if(r.getData().status === "in_progress") foundInProgress = true;
                                                });
                                            }
                                            // Highlight first planned if no in_progress and it's the first row object in data
                                            const firstPlannedCandidate = row.getTable().getData().find(d => d.status === "planned");
                                            if(!foundInProgress && firstPlannedCandidate && data.id === firstPlannedCandidate.id) {
                                               row.getElement().style.backgroundColor = "hsl(var(--b2)/0.6)";
                                            }
                                        }
                                    },
                                    tableBuilt: () => { 
                                        this.$nextTick(() => this.initTippy()); 
                                    },
                                });
                            } catch(e) {
                                console.error("UI: Failed to initialize agent plan Tabulator table:", e);
                                this.agentPlanTable = null;
                                tableElement.innerHTML = `<div class="p-4 text-center text-error text-xs">Error initializing plan table.</div>`;
                            }
                        }
                    }); // End $nextTick
                },
                async sendAgentGuidance() {
                    if (!this.agentControl.guidanceText.trim()) {
                        this.addNotification('Guidance text cannot be empty.', 'warning');
                        return;
                    }
                    if (!this.agentStatus.agent_running) {
                        this.addNotification('Agent is not running. Cannot send guidance.', 'warning');
                        return;
                    }

                    this.isLoadingAgentAction = true; // Use the general agent action loader
                    this.addNotification('Sending guidance to agent...', 'info');
                    try {
                        const payload = {
                            content: this.agentControl.guidanceText,
                            thought_type: "user_guidance" // Or "observation" if preferred by AML
                        };
                        // Assuming new API endpoint /api/agent/inject_thought
                        const result = await this.apiFetch('/agent/inject_thought', {
                            method: 'POST',
                            body: JSON.stringify(payload)
                        });
                        this.addNotification(result.message || 'Guidance sent to agent.', result.success ? 'success' : 'error');
                        if (result.success) {
                            this.agentControl.guidanceText = ''; // Clear input on success
                        }
                    } catch (e) {
                        this.addNotification(`Failed to send guidance: ${e.message}`, 'error');
                    } finally {
                        this.isLoadingAgentAction = false;
                    }
                },
                getCurrentTimestamp() { // We already have formatTimestamp, this is for new messages
                    return new Date().toISOString();
                },
                loadConfig() {
                    // Define default config structure matching Alpine state and Pydantic model (camelCase)
                    // Ensure this covers all expected keys with sensible defaults.
                    const defaultConfig = {
                        defaultModel: '',
                        defaultMaxTokens: 8000,
                        temperature: 0.7,
                        enableStreaming: true,
                        enableCaching: true,
                        autoDiscover: true,
                        enableLocalDiscovery: true,
                        dashboardRefreshRate: 2.0,
                        enablePortScanning: true,
                        historySize: 300, // Example, adjust if needed
                        // Provider Keys
                        anthropicApiKey: null,
                        openaiApiKey: null,
                        geminiApiKey: null,
                        grokApiKey: null,
                        deepseekApiKey: null,
                        mistralApiKey: null,
                        groqApiKey: null,
                        cerebrasApiKey: null,
                        openrouterApiKey: null,
                        // Provider Base URLs
                        openaiBaseUrl: null,
                        geminiBaseUrl: null,
                        grokBaseUrl: null,
                        deepseekBaseUrl: null,
                        mistralBaseUrl: null,
                        groqBaseUrl: null,
                        cerebrasBaseUrl: null,
                        openrouterBaseUrl: null,
                        // Other settings from your previous config definition
                        discoveryPaths: [],
                        cacheTtlMapping: {},
                        conversationGraphsDir: '',
                        registryUrls: [],
                        summarizationModel: '',
                        useAutoSummarization: false,
                        autoSummarizeThreshold: 100000,
                        maxSummarizedTokens: 1500,
                        portScanRangeStart: 8000,
                        portScanRangeEnd: 9000,
                        portScanConcurrency: 50,
                        portScanTimeout: 4.5,
                        portScanTargets: ["127.0.0.1"]
                    };

                    console.log("Attempting to load config from server..."); // Log the attempt

                    this.apiFetch('/config')
                        .then(data => {
                            // Check if the received data is a non-empty object
                            // This handles null, undefined, primitives, and empty objects {}
                            const isValidConfigData = data && typeof data === 'object' && Object.keys(data).length > 0;

                            if (isValidConfigData) {
                                // --- Path for VALID config received from server ---
                                console.log("Received valid config data from server.");
                                // Merge fetched data with defaults to ensure all keys exist
                                this.config = { ...defaultConfig, ...data };
                                // Set the current model based on the loaded config
                                this.currentModel = this.config.defaultModel || '';
                                console.log("Applied config from server:", this.config); // Log the applied config

                                // Save the successfully fetched config to localStorage as a fallback for future sessions
                                this.saveConfigToLocalStorage();
                                // Optional: Subtle success notification if needed
                                // this.addNotification('Live config loaded.', 'success', 1500);

                            } else {
                                // --- Path for INVALID data received despite successful fetch (e.g., 200 OK with null body) ---
                                console.warn("Received non-valid config data from server despite successful fetch.");
                                // **Diagnostic Logging:** Log details about the invalid data
                                console.log("  > Type of received data:", typeof data);
                                try {
                                    // Attempt to stringify for logging, truncate if potentially large
                                    const dataString = JSON.stringify(data);
                                    console.log("  > Received data value (stringified, max 500 chars):", dataString.substring(0, 500) + (dataString.length > 500 ? '...' : ''));
                                } catch (e) {
                                    console.log("  > Received data value (could not stringify):", data);
                                }

                                // Notify the user specifically about the invalid data
                                this.addNotification('Server config was empty or invalid, using local fallback.', 'warning', 4000);

                                // Fallback to loading from local storage
                                this.loadConfigFromLocalStorage();
                            }
                        })
                        .catch((error) => {
                            // --- Path for FAILED fetch (network error, server error, timeout) ---
                            console.warn(`Primary config fetch failed. Falling back to local storage. Error: ${error.message || 'Unknown fetch error'}`, error);

                            // Notify the user about the fetch failure (less alarming than critical error)
                            this.addNotification(`Failed to fetch live config (${error.message || 'Network issue'}), using local fallback.`, 'warning', 5000);

                            // Fallback to loading from local storage
                            this.loadConfigFromLocalStorage();
                        });
                }, // --- End of loadConfig function ---

                // Make sure you have this helper function defined in your Alpine component:
                saveConfigToLocalStorage() {
                    try {
                        // Only save the core config part, not the entire Alpine component state
                        const configToSave = this.config;
                        if (configToSave) {
                            localStorage.setItem('mcp_client_config', JSON.stringify(configToSave));
                            console.log("Saved current config state to local storage for fallback.");
                        } else {
                            console.warn("Attempted to save null/undefined config to local storage, skipping.");
                        }
                    } catch (e) {
                        console.error("Failed to save config to local storage:", e);
                        // Optionally notify the user if saving the fallback fails
                        // this.addNotification('Could not save config fallback.', 'error');
                    }
                },

                loadConfigFromLocalStorage() {
                    // Define the same default structure as in loadConfig
                    const defaultConfig = {
                        defaultModel: '',
                        defaultMaxTokens: 8000,
                        temperature: 0.7,
                        enableStreaming: true,
                        enableCaching: true,
                        autoDiscover: true,
                        enableLocalDiscovery: true,
                        dashboardRefreshRate: 2.0,
                        enablePortScanning: true,
                        historySize: 300,
                        anthropicApiKey: null,
                        openaiApiKey: null,
                        geminiApiKey: null,
                        grokApiKey: null,
                        deepseekApiKey: null,
                        mistralApiKey: null,
                        groqApiKey: null,
                        cerebrasApiKey: null,
                        openrouterApiKey: null,
                        openaiBaseUrl: null,
                        geminiBaseUrl: null,
                        grokBaseUrl: null,
                        deepseekBaseUrl: null,
                        mistralBaseUrl: null,
                        groqBaseUrl: null,
                        cerebrasBaseUrl: null,
                        openrouterBaseUrl: null,
                        discoveryPaths: [],
                        cacheTtlMapping: {},
                        conversationGraphsDir: '',
                        registryUrls: [],
                        summarizationModel: '',
                        useAutoSummarization: false,
                        autoSummarizeThreshold: 100000,
                        maxSummarizedTokens: 1500,
                        portScanRangeStart: 8000,
                        portScanRangeEnd: 9000,
                        portScanConcurrency: 50,
                        portScanTimeout: 4.5,
                        portScanTargets: ["127.0.0.1"]
                    };
                    const savedConfig = localStorage.getItem('mcp_client_config');
                    if (savedConfig) {
                        try {
                            const parsed = JSON.parse(savedConfig);
                            // Merge saved localStorage data with defaults to ensure all keys exist
                            this.config = {
                                ...defaultConfig,
                                ...parsed
                            };
                            this.currentModel = this.config.defaultModel || ''; // Set current model from loaded config
                            this.addNotification('Loaded config fallback from local storage.', 'info');
                        } catch (e) {
                            console.error("Failed to parse saved config:", e);
                            localStorage.removeItem('mcp_client_config');
                            // Set to defaults if parsing fails
                            this.config = defaultConfig;
                            this.currentModel = this.config.defaultModel || '';
                        }
                    } else {
                        // If nothing in localStorage, use defaults
                        this.config = defaultConfig;
                        this.currentModel = this.config.defaultModel || '';
                    }
                }, // End loadConfigFromLocalStorage
                saveConfigField(key, value) {
                    clearTimeout(this.saveConfigTimer);
                    this.saveConfigTimer = setTimeout(() => {
                        this.config[key] = value; const updatePayload = { [key]: value };
                        console.log('Saving config field via API:', updatePayload);
                        this.apiFetch('/config', { method: 'PUT', body: JSON.stringify(updatePayload), })
                            .then(() => this.addNotification(`Setting '${key}' saved.`, 'success', 1500))
                            .catch(() => { this.addNotification(`Failed to save setting '${key}'.`, 'error'); });
                    }, 750);
                },
                async resetConfig() { // Make async
                    if (confirm('Are you sure you want to reset the configuration TO DEFAULTS? This affects the server and cannot be undone easily.')) {
                        console.warn("Resetting configuration via API...");
                        this.isLoading = true; // Use global loading
                        this.addNotification("Resetting configuration to defaults...", "warning");
                        try {
                            // Call the API endpoint
                            const result = await this.apiFetch('/config/reset', { method: 'POST' });
                            this.addNotification(result.message || "Configuration reset successfully.", "success");
                            // Reload UI config state from server (which should now be default)
                            await this.loadConfig();
                            // Reload servers and capabilities as config changed drastically
                            await this.fetchServers();
                            await this.fetchCapabilities();
                            // Consider reloading the page or forcing a full state refresh if needed
                        } catch (e) {
                            this.addNotification(`Configuration reset failed: ${e.message}`, 'error');
                        } finally {
                            this.isLoading = false;
                        }
                    }
                },
                setModel(modelName) {
                    if (!modelName || modelName === this.currentModel) return;
                    const oldModel = this.currentModel;
                    this.currentModel = modelName; // Update UI immediately

                    console.log(`UI attempting to set model to: ${modelName}`);

                    // Call the new backend API endpoint
                    this.apiFetch('/model', {
                        method: 'PUT',
                        body: JSON.stringify({ model: modelName })
                    })
                    .then(response => {
                        // Backend confirms the model is set (might be the same or updated)
                        this.currentModel = response.currentModel; // Ensure UI matches backend state
                        this.config.defaultModel = response.currentModel; // Update local config state too
                        this.addNotification(response.message || `Model successfully set to ${this.getFormattedModelName(this.currentModel)}.`, 'success', 2000);
                        console.log("Backend confirmed model set:", this.currentModel);
                        // Optionally trigger a config save on the UI side if needed,
                        // but the backend's set_active_model should handle saving the default.
                        // this.saveConfigToLocalStorage(); // Maybe save local fallback
                    })
                    .catch(error => {
                        // Revert UI on error
                        this.currentModel = oldModel;
                        this.addNotification(`Failed to set model: ${error.message}`, 'error');
                        console.error("Error setting model via API:", error);
                    });
                },

                setCustomModel(modelName) {
                    const trimmedName = modelName.trim();
                    // Call the main setModel function, which now handles API call and updates
                    if (trimmedName) {
                        this.setModel(trimmedName);
                    }
                },

                async fetchServers() {
                    this.isLoadingServers = true; // Indicate loading specifically for servers
                    try {
                        const serversData = await this.apiFetch('/servers');
                        this.servers = serversData || []; // Ensure servers is always an array
                    } catch (e) {
                        this.servers = []; // Reset on error
                        // Error notification is handled by apiFetch
                    } finally {
                        this.isLoadingServers = false;
                    }
                }, // Added comma

                async fetchServerDetails(serverName) {
                    if (!serverName) return;
                    console.log(`Fetching details for server: ${serverName}`);
                    this.isLoadingServerDetails = true;
                    this.selectedServerDetails = null; // Clear previous details
                    this.showServerDetailsModal = true; // Open modal immediately

                    try {
                        const details = await this.apiFetch(`/servers/${encodeURIComponent(serverName)}/details`);
                        this.selectedServerDetails = details;
                        // Re-init Tippy if needed after modal content updates
                        this.$nextTick(() => this.initTippy());
                    } catch (e) {
                        this.addNotification(`Failed to load details for ${serverName}: ${e.message}`, 'error');
                        this.selectedServerDetails = null; // Ensure it's null on error
                        // Keep modal open to show error message inside? Or close it? Let's keep it open.
                    } finally {
                        this.isLoadingServerDetails = false;
                    }
                },

                // --- NEW: DISCOVERY METHODS ---
                async triggerDiscovery() {
                    // This now triggers the consolidated backend discovery
                    if (this.isLoadingDiscovery) return;
                    console.log(`Triggering consolidated server discovery via API...`);
                    this.isLoadingDiscovery = true;
                    this.discoveredServers = []; // Clear previous results immediately
                    if (this.discoveredServersTable) {
                        this.discoveredServersTable.clearData(); // Clear Tabulator table
                        this.discoveredServersTable.setPlaceholder("Scanning network..."); // Update placeholder
                    }
                    this.addNotification('Starting network server discovery scan...', 'info', 2500);
                    try {
                        // Call the single trigger endpoint
                        await this.apiFetch('/discover/trigger', { method: 'POST' });
                        // Wait a reasonable time for discovery to finish on backend.
                        // Adjust delay based on typical scan time (mDNS/Port Scan can take longer)
                        await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds
                        await this.fetchDiscoveryResults(); // Fetch results after waiting
                    } catch (e) {
                        this.addNotification(`Failed to initiate discovery scan: ${e.message}`, 'error');
                        this.isLoadingDiscovery = false; // Ensure loading stops on trigger error
                        if (this.discoveredServersTable) {
                            this.discoveredServersTable.setPlaceholder("Discovery failed.");
                        }
                    }
                    // isLoadingDiscovery is set to false by fetchDiscoveryResults' finally block
                },

                async fetchDiscoveryResults() {
                    console.log("Fetching discovery results for Tabulator...");
                    try {
                        const results = await this.apiFetch('/discover/results');
                        // Store raw data - Tabulator will use this
                        this.discoveredServers = results || [];
                        console.log(`Found ${this.discoveredServers.length} discovered servers.`);

                        // Initialize or update Tabulator table using the data
                        this.initOrUpdateDiscoveredTable();

                    } catch (e) {
                        this.addNotification(`Failed to fetch discovery results: ${e.message}`, 'error');
                        this.discoveredServers = []; // Clear data on error
                        if (this.discoveredServersTable) {
                            this.discoveredServersTable.clearData(); // Clear table too
                            this.discoveredServersTable.setPlaceholder("Error fetching results.");
                        }
                    } finally {
                        this.isLoadingDiscovery = false; // Stop loading indicator *after* fetching/rendering
                    }
                },

                // Tabulator Initialization/Update Function
                initOrUpdateDiscoveredTable() {
                    const tableElement = document.getElementById('discovered-servers-table');
                    if (!tableElement) {
                        console.warn("Tabulator container '#discovered-servers-table' not found in DOM yet.");
                        return;
                    }

                    // --- Define Tabulator Columns ---
                    const columns = [
                        { // Icon column
                            title: "", hozAlign: "center", width: 40, headerSort: false, cssClass: "p-1", frozen: true,
                            formatter: (cell) => `<i class="${this.serverTypeIcon(cell.getRow().getData().type)} opacity-80 text-base"></i>`
                        },
                        { title: "Name", field: "name", minWidth: 120, sorter: "string", headerFilter: "input", cssClass: "p-1 font-medium", tooltip: (cell) => cell.getValue() },
                        { title: "Path / URL", field: "path_or_url", minWidth: 180, sorter: "string", headerFilter: "input", cssClass: "p-1 text-base-content/70", tooltip: (cell) => cell.getValue() },
                        { // Source Badge column
                            title: "Source", field: "source", sorter: "string", headerFilter: "select", headerFilterParams: { values: ["", "filesystem", "registry", "mdns", "portscan"] }, width: 90, hozAlign: "center", cssClass: "p-1",
                            formatter: (cell) => `<span class="badge badge-xs capitalize ${this.discoverySourceColor(cell.getValue())}">${cell.getValue() || 'N/A'}</span>`
                        },
                        { // Action Button column
                            title: "Action", hozAlign: "center", width: 70, headerSort: false, cssClass: "p-1",
                            formatter: (cell) => {
                                const serverData = cell.getRow().getData();
                                const isDisabled = serverData.is_configured;
                                const uniqueId = `add-disc-btn-${cell.getRow().getIndex()}`;
                                // Use data attributes to store necessary info for the click handler
                                return `
                                    <button id="${uniqueId}"
                                            class="btn btn-xs btn-outline btn-success p-1"
                                            ${isDisabled ? 'disabled' : ''}
                                            data-tippy-content="${serverData.is_configured ? 'Already Configured' : 'Add & Connect'}"
                                            data-server-info="${encodeURIComponent(JSON.stringify(serverData))}"
                                            >
                                        <i class="fas fa-plus"></i>
                                    </button>
                                `;
                            },
                            cellClick: (e, cell) => { // Handle clicks within the cell
                                const button = e.target.closest('button'); // Find the clicked button
                                if (button && !button.disabled) { // If a non-disabled button was clicked
                                    const serverInfoEncoded = button.getAttribute('data-server-info');
                                    if (serverInfoEncoded) {
                                        try {
                                            const serverData = JSON.parse(decodeURIComponent(serverInfoEncoded));
                                            // Call the Alpine method, passing the button for state changes
                                            this.addAndConnectDiscoveredServer(serverData, button);
                                        } catch (parseError) {
                                            console.error("Error parsing server data from button:", parseError);
                                            this.addNotification("Internal UI error processing discovered server.", "error");
                                        }
                                    }
                                }
                            }
                        }
                    ]; // End columns definition

                    // --- Initialize or Update Table ---
                    const placeholderText = this.isLoadingDiscovery ? "Scanning..." : "No new servers found.";
                    if (this.discoveredServersTable) {
                        console.log("Tabulator: Updating data");
                        this.discoveredServersTable.setPlaceholder(placeholderText);
                        this.discoveredServersTable.setData(this.discoveredServers)
                            .then(() => { this.$nextTick(() => this.initTippy()); }) // Re-init tippy after data update
                            .catch(err => console.error("Tabulator setData error:", err));
                    } else {
                        console.log("Tabulator: Initializing new table");
                        try {
                            this.discoveredServersTable = new Tabulator("#discovered-servers-table", {
                                data: this.discoveredServers,
                                layout: "fitDataStretch",
                                placeholder: placeholderText,
                                height: "12rem",
                                // virtualDom: true, // Enable if expecting many results
                                // virtualDomBuffer: 300,
                                responsiveLayout: "hide", // Hide columns that don't fit
                                columns: columns,
                                initialSort: [{ column: "name", dir: "asc" }],
                                tableBuilt: () => { this.$nextTick(() => this.initTippy()); },
                            });
                        } catch (err) {
                            console.error("Failed to initialize Tabulator:", err);
                            this.addNotification("Error initializing discovery table.", "error");
                        }
                    }
                    // Ensure tippy runs after table potentially renders/updates outside the promises too
                    this.$nextTick(() => this.initTippy());
                }, // End initOrUpdateDiscoveredTable

                // Modified addAndConnect to handle button loading state
                async addAndConnectDiscoveredServer(dServer, buttonElement = null) {
                    if (!dServer || dServer.is_configured) return;

                    this.addNotification(`Adding & connecting to ${dServer.name}...`, 'info');

                    let originalButtonContent = null;
                    if (buttonElement) {
                        originalButtonContent = buttonElement.innerHTML;
                        buttonElement.classList.add('loading');
                        buttonElement.disabled = true;
                        buttonElement.innerHTML = ''; // Clear icon
                    } else {
                        this.isLoading = true; // Fallback global loading
                    }

                    try {
                        // Construct payload carefully matching the Pydantic model on backend
                        const payload = {
                            name: dServer.name,
                            type: dServer.type,
                            path_or_url: dServer.path_or_url, // Ensure this matches backend expectation
                            source: dServer.source,
                            description: dServer.description,
                            version: dServer.version,
                            categories: dServer.categories || [],
                            is_configured: dServer.is_configured // Send current state
                        };
                        const result = await this.apiFetch('/discover/connect', {
                            method: 'POST',
                            body: JSON.stringify(payload)
                        });
                        this.addNotification(result.message || `Successfully processed ${dServer.name}.`, 'success');

                        // Refresh main server list, capabilities, AND discovery results
                        await this.fetchServers();
                        await this.fetchCapabilities();
                        // Re-fetch discovery results - this will update the table and disable the button
                        await this.fetchDiscoveryResults();

                    } catch (e) {
                        this.addNotification(`Failed to add/connect ${dServer.name}: ${e.message}`, 'error');
                        // Reset button state on error only if element was passed
                        if (buttonElement) {
                            buttonElement.classList.remove('loading');
                            // Re-enable button only if it wasn't already configured
                            buttonElement.disabled = dServer.is_configured;
                            buttonElement.innerHTML = originalButtonContent;
                        }
                    } finally {
                        // Ensure global loading is reset if it was used
                        this.isLoading = false;
                        // Button state is reset on error above, or implicitly handled by
                        // fetchDiscoveryResults on success (which rebuilds the table)
                    }
                },

                async reloadAllServers() {
                    if (this.isLoadingServers) return;
                    if (confirm("This will disconnect and attempt to reconnect all configured servers, reloading their capabilities. Proceed?")) {
                        console.log("Reloading all servers via API...");
                        this.isLoadingServers = true; // Use server loading flag
                        this.addNotification("Reloading all servers...", "info");
                        // Clear current UI state immediately for better feedback
                        this.servers = [];
                        this.tools = [];
                        this.resources = [];
                        this.prompts = [];
                        try {
                            const result = await this.apiFetch('/runtime/reload', { method: 'POST' });
                            this.addNotification(result.message || "Server reload complete.", "success");
                        } catch (e) {
                            this.addNotification(`Server reload failed: ${e.message}`, "error");
                        } finally {
                            // Always refresh state after attempt
                            await this.fetchServers();
                            await this.fetchCapabilities();
                            this.isLoadingServers = false;
                        }
                    }
                },

                // Utility function for server type icons (ADD this or ensure it exists)
                serverTypeIcon(type) {
                    switch (type?.toLowerCase()) {
                        case 'stdio': return 'fas fa-terminal text-accent';
                        case 'sse': return 'fas fa-network-wired text-info';
                        default: return 'fas fa-question-circle text-base-content/40';
                    }
                },

                // Utility function for discovery source badge colors (ADD this or ensure it exists)
                discoverySourceColor(source) {
                    switch (source?.toLowerCase()) {
                        case 'filesystem': return 'badge-neutral';
                        case 'registry': return 'badge-secondary';
                        case 'mdns': return 'badge-accent';
                        case 'portscan': return 'badge-warning';
                        default: return 'badge-ghost';
                    }
                },

                async fetchCacheData() {
                    // Guard: Only run if the config tab is active
                    if (this.activeTab !== 'config') {
                        console.log("fetchCacheData: Skipping, config tab not active.");
                        return;
                    }
                    // Guard: Prevent concurrent runs
                    if (this.isLoadingCache) {
                        console.log("fetchCacheData: Already loading.");
                        return;
                    }

                    console.log("Fetching cache data...");
                    this.isLoadingCache = true;

                    // --- STEP 1: Destroy existing tables (if they exist) ---
                    // This cleans up old instances and event listeners reliably.
                    if (this.cacheEntriesTable) {
                        try {
                            console.log("Destroying previous cacheEntriesTable instance.");
                            this.cacheEntriesTable.destroy();
                        } catch (e) {
                            console.warn("Error destroying previous cacheEntriesTable:", e);
                        } finally {
                            this.cacheEntriesTable = null; // Ensure reference is cleared
                        }
                    }
                    if (this.cacheDepsTable) {
                        try {
                            console.log("Destroying previous cacheDepsTable instance.");
                            this.cacheDepsTable.destroy();
                        } catch (e) {
                            console.warn("Error destroying previous cacheDepsTable:", e);
                        } finally {
                            this.cacheDepsTable = null; // Ensure reference is cleared
                        }
                    }
                    // --- End Destroy Step ---

                    // Set temporary loading placeholders manually (optional, but good feedback)
                    const entriesTableEl = document.getElementById('cache-entries-table');
                    const depsTableEl = document.getElementById('cache-dependencies-table');
                    if (entriesTableEl) entriesTableEl.innerHTML = `<div class="tabulator-placeholder p-4"><span class="opacity-70 italic">Loading entries...</span></div>`;
                    if (depsTableEl) depsTableEl.innerHTML = `<div class="tabulator-placeholder p-4"><span class="opacity-70 italic">Loading dependencies...</span></div>`;

                    try {
                        // --- STEP 2: Fetch data ---
                        const results = await Promise.allSettled([
                            this.apiFetch('/cache/entries'),
                            this.apiFetch('/cache/dependencies')
                        ]);

                        // Process entries
                        if (results[0].status === 'fulfilled') {
                            this.cacheEntries = results[0].value || [];
                        } else {
                            this.addNotification('Failed to fetch cache entries.', 'error');
                            this.cacheEntries = [];
                        }

                        // Process dependencies
                        if (results[1].status === 'fulfilled' && results[1].value?.dependencies) {
                            this.cacheDependencies = results[1].value.dependencies;
                        } else {
                            if (results[1].status === 'rejected') {
                                this.addNotification('Failed to fetch cache dependencies.', 'error');
                            }
                            this.cacheDependencies = {};
                        }

                        // --- STEP 3: Initialize NEW tables AFTER data is fetched ---
                        // Ensure the DOM elements still exist before initializing
                        if (entriesTableEl) {
                            this.initializeCacheEntriesTable(); // Call the new init function
                        } else {
                            console.warn("Cache entries table element missing after fetch.");
                        }
                        if (depsTableEl) {
                            this.initializeCacheDepsTable();    // Call the new init function
                        } else {
                            console.warn("Cache dependencies table element missing after fetch.");
                        }

                    } catch (e) {
                        console.error("Unexpected error during cache data fetch:", e);
                        this.addNotification('Critical error fetching cache data.', 'error');
                        // Clear placeholders or set error messages if elements exist
                        if (entriesTableEl) entriesTableEl.innerHTML = `<div class="tabulator-placeholder p-4 text-error">Error loading entries.</div>`;
                        if (depsTableEl) depsTableEl.innerHTML = `<div class="tabulator-placeholder p-4 text-error">Error loading dependencies.</div>`;
                    } finally {
                        this.isLoadingCache = false;
                        // Refresh tooltips after tables might have been created/updated
                        this.$nextTick(() => this.initTippy());
                    }
                },
                initializeCacheEntriesTable() {
                    // Guards are important: only initialize if the instance is null AND element exists
                    if (this.cacheEntriesTable) {
                        console.log("initializeCacheEntriesTable: Instance already exists, skipping recreation.");
                        return;
                    }
                    const tableId = 'cache-entries-table';
                    const tableElement = document.getElementById(tableId);
                    if (!tableElement) {
                        console.warn(`initializeCacheEntriesTable: Cannot find element #${tableId}.`);
                        return;
                    }
                    // Determine placeholder text *now* based on final state
                    const placeholderText = (!this.cacheEntries || this.cacheEntries.length === 0)
                        ? "<span class='opacity-70 italic p-4'>No cache entries found.</span>"
                        : ""; // No placeholder if data exists

                    const columns = [ // Define columns directly here or use a helper
                        { title: "Tool Name", field: "tool_name", minWidth: 150, sorter: "string", headerFilter: "input", cssClass: "p-1 font-medium", tooltip: true },
                        { title: "Created At", field: "created_at", width: 140, sorter: "datetime", hozAlign: "center", cssClass: "p-1 text-base-content/70", sorterParams: { format: "iso" }, formatter: "datetime", formatterParams: { outputFormat: "MM/DD HH:mm:ss" }, tooltip: (cell) => { try { const val = cell.getValue(); return val ? new Date(val).toLocaleString() : ''; } catch { return cell.getValue(); } } },
                        { title: "Expires At", field: "expires_at", width: 140, sorter: "datetime", hozAlign: "center", cssClass: "p-1 text-base-content/70", sorterParams: { format: "iso" }, formatter: (cell) => { const v = cell.getValue(); return v ? new Date(v).toLocaleTimeString([], { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' }) : '<span class="italic opacity-50">Never</span>' }, tooltip: (cell) => { try { const val = cell.getValue(); return val ? new Date(val).toLocaleString() : 'Never'; } catch { return cell.getValue(); } } },
                        { title: "Key Hash", field: "key", minWidth: 100, sorter: "string", headerFilter: "input", cssClass: "p-1 font-mono text-xs opacity-60", formatter: (cell) => { const k = cell.getValue(); return k ? (k.split(':').pop()?.substring(0, 10) || '') + '...' : ''; }, tooltip: (cell) => cell.getValue() },
                        { title: "Clear", hozAlign: "center", width: 60, headerSort: false, cssClass: "p-1", formatter: (cell) => { const t = cell.getRow().getData()?.tool_name || ''; return `<button class="btn btn-xs btn-ghost text-error/70 hover:text-error p-1" data-tool-name="${encodeURIComponent(t)}" data-tippy-content="Clear all for '${t || 'this entry'}'" title="Clear cache for ${t}"><i class="fas fa-times"></i></button>`; }, cellClick: (e, cell) => { const btn = e.target.closest('button'); if (btn) { const tEnc = btn.getAttribute('data-tool-name'); if (tEnc) this.clearCacheByToolName(decodeURIComponent(tEnc)); } } }
                    ];

                    console.log(`Tabulator (Cache Entries): Initializing new table with ${this.cacheEntries?.length || 0} entries.`);
                    try {
                        // Create the new instance and assign it
                        this.cacheEntriesTable = new Tabulator(tableElement, { // Pass the DOM element
                            data: this.cacheEntries || [],
                            placeholder: placeholderText, // Set initial placeholder
                            layout: "fitDataStretch",
                            height: "10rem",
                            columns: columns,
                            initialSort: [{ column: "created_at", dir: "desc" }],
                            responsiveLayout: "hide",
                            tableBuilt: () => {
                                console.log("Tabulator (Cache Entries): Instance successfully created.");
                                // Optional: Init tippy specifically for this table? Usually global is fine.
                            },
                            dataLoadError: (error) => {
                                console.error("Tabulator (Cache Entries): Internal data load error.", error);
                                // Placeholder should reflect the error state if needed
                                if (tableElement) tableElement.innerHTML = `<div class="tabulator-placeholder p-4 text-error">Error displaying data.</div>`;
                            },
                        });
                    } catch (err) {
                        console.error("Tabulator (Cache Entries): FAILED TO INITIALIZE.", err);
                        this.addNotification("Critical error initializing cache table.", "error");
                        this.cacheEntriesTable = null; // Ensure instance is null on failure
                        if (tableElement) tableElement.innerHTML = `<div class="tabulator-placeholder p-4 text-error">Error initializing table.</div>`;
                    }
                },

                // NEW Initialization function for Cache Dependencies Table
                initializeCacheDepsTable() {
                    // Guards
                    if (this.cacheDepsTable) {
                        console.log("initializeCacheDepsTable: Instance already exists, skipping recreation.");
                        return;
                    }
                    const tableId = 'cache-dependencies-table';
                    const tableElement = document.getElementById(tableId);
                    if (!tableElement) {
                        console.warn(`initializeCacheDepsTable: Cannot find element #${tableId}.`);
                        return;
                    }

                    // Prepare data & columns
                    const tableData = Object.entries(this.cacheDependencies || {}).map(([tool, deps]) => ({
                        tool: tool,
                        depends_on: Array.isArray(deps) ? deps.join(', ') : String(deps || '')
                    }));
                    const columns = [
                        { title: "Tool", field: "tool", minWidth: 180, sorter: "string", headerFilter: "input", cssClass: "p-1 font-medium", tooltip: true },
                        { title: "Depends On", field: "depends_on", minWidth: 200, sorter: "string", headerFilter: "input", cssClass: "p-1 text-base-content/80", tooltip: true }
                    ];
                    const placeholderText = (!this.cacheDependencies || Object.keys(this.cacheDependencies).length === 0)
                        ? "<span class='opacity-70 italic p-4'>No dependencies found.</span>"
                        : "";

                    console.log(`Tabulator (Cache Deps): Initializing new table with ${tableData.length} entries.`);
                    try {
                        this.cacheDepsTable = new Tabulator(tableElement, { // Pass element
                            data: tableData,
                            placeholder: placeholderText,
                            layout: "fitDataStretch",
                            height: "6rem",
                            columns: columns,
                            initialSort: [{ column: "tool", dir: "asc" }],
                            tableBuilt: () => {
                                console.log("Tabulator (Cache Deps): Instance successfully created.");
                            },
                            dataLoadError: (error) => {
                                console.error("Tabulator (Cache Deps): Internal data load error.", error);
                                if (tableElement) tableElement.innerHTML = `<div class="tabulator-placeholder p-4 text-error">Error displaying data.</div>`;
                            },
                        });
                    } catch (err) {
                        console.error("Tabulator (Cache Deps): FAILED TO INITIALIZE.", err);
                        this.addNotification("Critical error initializing dependencies table.", "error");
                        this.cacheDepsTable = null;
                        if (tableElement) tableElement.innerHTML = `<div class="tabulator-placeholder p-4 text-error">Error initializing table.</div>`;
                    }
                },
                initOrUpdateCacheEntriesTable() {
                    // --- 1. Guards ---
                    if (this.activeTab !== 'config') return; // Only run if tab is active

                    const tableId = 'cache-entries-table';
                    const tableElement = document.getElementById(tableId);
                    if (!tableElement) {
                        console.warn(`initOrUpdateCacheEntriesTable: Cannot find element #${tableId}.`);
                        // If element removed, destroy table instance if it exists
                        if (this.cacheEntriesTable) {
                            try { this.cacheEntriesTable.destroy(); } catch (e) { }
                            this.cacheEntriesTable = null;
                        }
                        return;
                    }

                    // --- 2. Define Columns (remains the same) ---
                    const getTableColumns = () => [
                        // ... (keep your existing column definitions here) ...
                        { title: "Tool Name", field: "tool_name", minWidth: 150, sorter: "string", headerFilter: "input", cssClass: "p-1 font-medium", tooltip: true },
                        { title: "Created At", field: "created_at", width: 140, sorter: "datetime", hozAlign: "center", cssClass: "p-1 text-base-content/70", sorterParams: { format: "iso" }, formatter: "datetime", formatterParams: { outputFormat: "MM/DD HH:mm:ss" }, tooltip: (cell) => { try { const val = cell.getValue(); return val ? new Date(val).toLocaleString() : ''; } catch { return cell.getValue(); } } },
                        { title: "Expires At", field: "expires_at", width: 140, sorter: "datetime", hozAlign: "center", cssClass: "p-1 text-base-content/70", sorterParams: { format: "iso" }, formatter: (cell) => { /* ... keep formatter ... */ const value = cell.getValue(); if (!value) return '<span class="italic opacity-50">Never</span>'; try { return new Date(value).toLocaleTimeString([], { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' }); } catch { return String(value); } }, tooltip: (cell) => { try { const val = cell.getValue(); return val ? new Date(val).toLocaleString() : 'Never'; } catch { return cell.getValue(); } } },
                        { title: "Key Hash", field: "key", minWidth: 100, sorter: "string", headerFilter: "input", cssClass: "p-1 font-mono text-xs opacity-60", formatter: (cell) => { /* ... keep formatter ... */ const key = cell.getValue(); if (!key || typeof key !== 'string') return ''; return (key.split(':').pop()?.substring(0, 10) || '') + '...'; }, tooltip: (cell) => cell.getValue() },
                        { title: "Clear", hozAlign: "center", width: 60, headerSort: false, cssClass: "p-1", formatter: (cell) => { /* ... keep formatter ... */ const toolName = cell.getRow().getData()?.tool_name || ''; return `<button class="btn btn-xs btn-ghost text-error/70 hover:text-error p-1" data-tool-name="${encodeURIComponent(toolName)}" data-tippy-content="Clear all cache for '${toolName || 'this entry'}'" title="Clear cache for ${toolName}"><i class="fas fa-times"></i></button>`; }, cellClick: (e, cell) => { /* ... keep cellClick ... */ const button = e.target.closest('button'); if (button) { const toolNameEncoded = button.getAttribute('data-tool-name'); if (toolNameEncoded) { this.clearCacheByToolName(decodeURIComponent(toolNameEncoded)); } } } }
                    ];

                    // --- 3. Determine Placeholder Text ---
                    let placeholderText = "";
                    if (this.isLoadingCache) {
                        placeholderText = `<span class='opacity-70 italic p-4'>Loading entries...</span>`; // Use HTML for better display
                    } else if (!this.cacheEntries || this.cacheEntries.length === 0) {
                        placeholderText = "<span class='opacity-70 italic p-4'>No cache entries found.</span>";
                    }
                    // If data exists and not loading, Tabulator won't show the placeholder.

                    // --- 4. Initialize or Update ---
                    // Check if the table instance *already exists and is valid*
                    if (this.cacheEntriesTable && typeof this.cacheEntriesTable.setData === 'function') {
                        // --- 4a. Update Existing Table ---
                        console.log(`Tabulator (Cache Entries): Updating existing table.`);
                        try {
                            // Set placeholder *before* potentially slow data update
                            this.cacheEntriesTable.setPlaceholder(placeholderText);
                            // Update the data
                            this.cacheEntriesTable.setData(this.cacheEntries)
                                .then(() => { /* console.log("Cache Entries setData success"); */ })
                                .catch(err => {
                                    console.error("Tabulator (Cache Entries): setData failed.", err);
                                    this.addNotification("Error updating cache table display.", "error");
                                    // Attempt to set an error placeholder if setData fails
                                    try { this.cacheEntriesTable.setPlaceholder("<span class='text-error p-4'>Error loading data.</span>"); } catch (e) { }
                                });
                        } catch (e) {
                            // Catch synchronous errors (e.g., if setPlaceholder fails unexpectedly)
                            console.error("Tabulator (Cache Entries): Error during table update.", e);
                            this.addNotification("Error during cache table update.", "error");
                            // Destroy potentially corrupted instance?
                            try { this.cacheEntriesTable.destroy(); } catch (destroyErr) { }
                            this.cacheEntriesTable = null; // Reset instance variable
                        }
                    }
                    // Check if table instance does *not* exist
                    else if (!this.cacheEntriesTable) {
                        // --- 4b. Initialize New Table ---
                        console.log(`Tabulator (Cache Entries): Initializing new table.`);
                        try {
                            this.cacheEntriesTable = new Tabulator(tableElement, { // Pass element directly
                                data: this.cacheEntries || [],
                                placeholder: placeholderText, // Use constructor option
                                layout: "fitDataStretch",
                                height: "10rem",
                                columns: getTableColumns(),
                                initialSort: [{ column: "created_at", dir: "desc" }],
                                responsiveLayout: "hide",
                                tableBuilt: () => {
                                    console.log("Tabulator (Cache Entries): Instance successfully created.");
                                    // Defer tooltip initialization slightly after table is built
                                    this.$nextTick(() => this.initTippy());
                                },
                                dataLoadError: (error) => {
                                    console.error("Tabulator (Cache Entries): Internal data load error.", error);
                                    this.addNotification("Tabulator internal error loading cache data.", "error");
                                },
                            });
                        } catch (err) {
                            console.error("Tabulator (Cache Entries): FAILED TO INITIALIZE.", err);
                            this.addNotification("Critical error initializing cache table.", "error");
                            this.cacheEntriesTable = null; // Ensure instance is null on failure
                        }
                    } else {
                        // Edge case: this.cacheEntriesTable exists but is not a valid instance (e.g., destroyed)
                        console.warn("Tabulator (Cache Entries): Instance exists but seems invalid. Re-initializing.");
                        this.cacheEntriesTable = null; // Clear invalid reference
                        this.initOrUpdateCacheEntriesTable(); // Retry initialization
                    }

                    // --- 5. Final UI Refresh (Tippy) ---
                    // It's generally safe to call this, it will re-scan for tooltips.
                    // Moved to the finally block of fetchCacheData for better timing.
                    // this.$nextTick(() => this.initTippy());
                },

                // Revised initOrUpdateCacheDepsTable function
                initOrUpdateCacheDepsTable() {
                    // --- 1. Guards ---
                    if (this.activeTab !== 'config') return;

                    const tableId = 'cache-dependencies-table';
                    const tableElement = document.getElementById(tableId);
                    if (!tableElement) {
                        console.warn(`initOrUpdateCacheDepsTable: Cannot find element #${tableId}.`);
                        if (this.cacheDepsTable) {
                            try { this.cacheDepsTable.destroy(); } catch (e) { }
                            this.cacheDepsTable = null;
                        }
                        return;
                    }

                    // --- 2. Prepare Data & Columns ---
                    const tableData = Object.entries(this.cacheDependencies || {}).map(([tool, deps]) => ({
                        tool: tool,
                        depends_on: Array.isArray(deps) ? deps.join(', ') : String(deps || '')
                    }));
                    const columns = [
                        { title: "Tool", field: "tool", minWidth: 180, sorter: "string", headerFilter: "input", cssClass: "p-1 font-medium", tooltip: true },
                        { title: "Depends On", field: "depends_on", minWidth: 200, sorter: "string", headerFilter: "input", cssClass: "p-1 text-base-content/80", tooltip: true }
                    ];

                    // --- 3. Determine Placeholder Text ---
                    let placeholderText = "";
                    if (this.isLoadingCache) {
                        placeholderText = `<span class='opacity-70 italic p-4'>Loading dependencies...</span>`;
                    } else if (!this.cacheDependencies || Object.keys(this.cacheDependencies).length === 0) {
                        placeholderText = "<span class='opacity-70 italic p-4'>No dependencies found.</span>";
                    }

                    // --- 4. Initialize or Update ---
                    if (this.cacheDepsTable && typeof this.cacheDepsTable.setData === 'function') {
                        // --- 4a. Update Existing Table ---
                        console.log(`Tabulator (Cache Deps): Updating existing table.`);
                        try {
                            this.cacheDepsTable.setPlaceholder(placeholderText);
                            this.cacheDepsTable.setData(tableData)
                                .then(() => { /* console.log("Cache Deps setData success"); */ })
                                .catch(err => {
                                    console.error("Tabulator (Cache Deps): setData failed.", err);
                                    this.addNotification("Error updating dependencies table.", "error");
                                    try { this.cacheDepsTable.setPlaceholder("<span class='text-error p-4'>Error loading data.</span>"); } catch (e) { }
                                });
                        } catch (e) {
                            console.error("Tabulator (Cache Deps): Error during table update.", e);
                            this.addNotification("Error during dependencies table update.", "error");
                            try { this.cacheDepsTable.destroy(); } catch (destroyErr) { }
                            this.cacheDepsTable = null;
                        }
                    }
                    // Check if table instance does *not* exist
                    else if (!this.cacheDepsTable) {
                        // --- 4b. Initialize New Table ---
                        console.log(`Tabulator (Cache Deps): Initializing new table.`);
                        try {
                            this.cacheDepsTable = new Tabulator(tableElement, { // Pass element
                                data: tableData,
                                placeholder: placeholderText, // Use constructor option
                                layout: "fitDataStretch",
                                height: "6rem", // Adjusted height slightly
                                columns: columns,
                                initialSort: [{ column: "tool", dir: "asc" }],
                                tableBuilt: () => {
                                    console.log("Tabulator (Cache Deps): Instance successfully created.");
                                    this.$nextTick(() => this.initTippy());
                                },
                                dataLoadError: (error) => {
                                    console.error("Tabulator (Cache Deps): Internal data load error.", error);
                                    this.addNotification("Tabulator internal error loading dependencies data.", "error");
                                },
                            });
                        } catch (err) {
                            console.error("Tabulator (Cache Deps): FAILED TO INITIALIZE.", err);
                            this.addNotification("Critical error initializing dependencies table.", "error");
                            this.cacheDepsTable = null;
                        }
                    } else {
                        // Edge case: Instance exists but is invalid
                        console.warn("Tabulator (Cache Deps): Instance exists but seems invalid. Re-initializing.");
                        this.cacheDepsTable = null; // Clear invalid reference
                        this.initOrUpdateCacheDepsTable(); // Retry initialization
                    }

                    // --- 5. Final UI Refresh (Tippy) ---
                    // Moved to the finally block of fetchCacheData
                    // this.$nextTick(() => this.initTippy());
                },

                async clearCacheByToolName(toolName) {
                    if (!toolName) { /* ... */ return; }
                    if (confirm(`Are you sure you want to clear all cache entries for the tool "${toolName}"?`)) {
                        console.log(`Requesting cache clear for tool: ${toolName}`);
                        const originalLoading = this.isLoadingCache; // Preserve potential outer loading state
                        this.isLoadingCache = true; // Indicate cache-specific loading
                        try {
                            const endpoint = `/cache/entries/${encodeURIComponent(toolName)}`;
                            const result = await this.apiFetch(endpoint, { method: 'DELETE' });
                            this.addNotification(result.message || `Cache cleared for tool '${toolName}'.`, 'success');
                            // --- Crucial: Call fetchCacheData to refresh and recreate tables ---
                            await this.fetchCacheData();
                            // --- End Crucial Step ---
                        } catch (e) {
                            console.error(`Failed to clear cache for tool '${toolName}':`, e);
                            this.addNotification(`Failed to clear cache for '${toolName}': ${e.message}`, 'error');
                        } finally {
                            // Restore the original loading state if needed, or just set false if this is the only operation
                            this.isLoadingCache = originalLoading;
                            // If the fetchCacheData above sets isLoadingCache=false, this might be redundant,
                            // but it's safer to ensure it's false here.
                            // If fetchCacheData failed, we still want to ensure loading is off.
                            if (this.isLoadingCache) { this.isLoadingCache = false };
                        }
                    }
                },

                async clearAllCacheAPI() {
                    if (confirm("Are you sure you want to clear the ENTIRE tool result cache?")) {
                        this.isLoadingCache = true;
                        try {
                            const result = await this.apiFetch('/cache/entries', { method: 'DELETE' });
                            this.addNotification(result.message || 'Cache cleared successfully.', 'success');
                            await this.fetchCacheData(); // Refresh view
                        } catch (e) {
                            this.addNotification(`Failed to clear cache: ${e.message}`, 'error');
                        } finally {
                            this.isLoadingCache = false;
                        }
                    }
                },

                async clearSingleCacheEntry(cacheKey) {
                    // Note: The API currently supports clearing by tool_name, not specific key hash.
                    // We'll extract the tool_name from the key.
                    const toolName = cacheKey.split(':')[0];
                    if (!toolName) {
                        this.addNotification('Invalid cache key format.', 'error');
                        return;
                    }

                    if (confirm(`Clear all cache entries for tool "${toolName}"? (Cannot clear single entry via API yet)`)) {
                        this.isLoadingCache = true;
                        try {
                            const endpoint = `/cache/entries/${encodeURIComponent(toolName)}`;
                            const result = await this.apiFetch(endpoint, { method: 'DELETE' });
                            this.addNotification(result.message || `Cache cleared for tool '${toolName}'.`, 'success');
                            await this.fetchCacheData(); // Refresh view
                        } catch (e) {
                            this.addNotification(`Failed to clear cache for '${toolName}': ${e.message}`, 'error');
                        } finally {
                            this.isLoadingCache = false;
                        }
                    }
                },

                async cleanCacheAPI() {
                    if (confirm("Clean expired entries from the cache?")) {
                        this.isLoadingCache = true;
                        try {
                            const result = await this.apiFetch('/cache/clean', { method: 'POST' });
                            this.addNotification(result.message || 'Expired cache entries cleaned.', 'success');
                            await this.fetchCacheData(); // Refresh view
                        } catch (e) {
                            this.addNotification(`Failed to clean cache: ${e.message}`, 'error');
                        } finally {
                            this.isLoadingCache = false;
                        }
                    }
                },

                async fetchCapabilities() {
                    this.isLoadingTools = true; // Use this flag for all capabilities
                    try {
                        // Use allSettled again for resilience
                        const results = await Promise.allSettled([
                            this.apiFetch('/tools'),
                            this.apiFetch('/resources'),
                            this.apiFetch('/prompts')
                        ]);

                        this.tools = results[0].status === 'fulfilled' ? (results[0].value || []) : [];
                        this.resources = results[1].status === 'fulfilled' ? (results[1].value || []) : [];
                        this.prompts = results[2].status === 'fulfilled' ? (results[2].value || []) : [];

                        if (results[0].status === 'rejected') this.addNotification('Failed to load tools.', 'warning');
                        if (results[1].status === 'rejected') this.addNotification('Failed to load resources.', 'warning');
                        if (results[2].status === 'rejected') this.addNotification('Failed to load prompts.', 'warning');

                    } catch (e) {
                        // Should not be reached with allSettled, but safety net
                        this.addNotification('Failed to load capabilities.', 'error');
                        this.tools = []; this.resources = []; this.prompts = [];
                    } finally {
                        this.isLoadingTools = false;
                    }
                }, // Added comma
                // --- SERVER MGMT ---
                serverStatusIcon(server) {
                    const baseClasses = 'text-lg ';
                    if (!server || typeof server.enabled === 'undefined') return baseClasses + 'fas fa-question-circle text-gray-400';
                    if (!server.enabled) return baseClasses + 'fas fa-ban text-base-content/30';
                    if (server.isLoading) return baseClasses + 'fas fa-spinner fa-spin text-info';
                    if (server.isConnected) return baseClasses + 'fas fa-check-circle text-success';
                    return baseClasses + 'fas fa-times-circle text-error';
                },
                async toggleServerConnection(server) {
                    if (!server || !server.name) return; const action = server.isConnected ? 'disconnect' : 'connect';
                    const endpoint = `/servers/${encodeURIComponent(server.name)}/${action}`;
                    const serverIndex = this.servers.findIndex(s => s.name === server.name); if (serverIndex === -1) return;
                    this.servers[serverIndex].isLoading = true; this.servers[serverIndex].statusText = action === 'connect' ? 'Connecting...' : 'Disconnecting...';
                    this.servers = [...this.servers];
                    try {
                        await this.apiFetch(endpoint, { method: 'POST' });
                        this.addNotification(`Server ${server.name} ${action} requested.`, 'info');
                        setTimeout(() => this.fetchServers(), 1500); await this.fetchCapabilities();
                    } catch (e) { this.addNotification(`Failed to ${action} server ${server.name}.`, 'error'); await this.fetchServers(); }
                    finally { const finalServerState = this.servers.find(s => s.name === server.name); if (finalServerState) { finalServerState.isLoading = false; } else if (this.servers[serverIndex]) { this.servers[serverIndex].isLoading = false; } this.servers = [...this.servers]; }
                },
                async toggleServerEnabled(server) {
                    if (!server || !server.name) return; const wasEnabled = server.enabled;
                    const serverIndex = this.servers.findIndex(s => s.name === server.name); if (serverIndex === -1) return;
                    this.servers[serverIndex].enabled = !wasEnabled; this.servers = [...this.servers];
                    if (!this.servers[serverIndex].enabled && this.servers[serverIndex].isConnected && !this.servers[serverIndex].isLoading) { console.log(`Disabling server ${server.name}, requesting disconnect.`); this.toggleServerConnection(this.servers[serverIndex]).catch(e => console.warn(`Disconnect during disable failed: ${e}`)); }
                    try {
                        await this.apiFetch(`/servers/${encodeURIComponent(server.name)}/enable?enabled=${!wasEnabled}`, { method: 'PUT' });
                        this.addNotification(`Server ${server.name} ${!wasEnabled ? 'enabled' : 'disabled'}.`, 'success');
                        await this.fetchServers(); await this.fetchCapabilities();
                    } catch (e) { this.addNotification(`Failed to update enable status for ${server.name}.`, 'error'); if (this.servers[serverIndex]) { this.servers[serverIndex].enabled = wasEnabled; this.servers = [...this.servers]; } await this.fetchServers(); }
                },
                async removeServer(serverName) {
                    if (confirm(`Are you sure you want to remove server "${serverName}"? This cannot be undone.`)) {
                        try {
                            await this.apiFetch(`/servers/${encodeURIComponent(serverName)}`, { method: 'DELETE' });
                            this.addNotification(`Server ${serverName} removed.`, 'warning');
                            await this.fetchServers(); await this.fetchCapabilities();
                        } catch (e) { this.addNotification(`Failed to remove server ${serverName}.`, 'error'); }
                    }
                },
                async addServer() {
                    const trimmedName = this.newServer.name.trim(); const trimmedPath = this.newServer.path.trim();
                    if (!trimmedName || !this.newServer.type || !trimmedPath) { this.addNotification('Server name, type, and path/URL are required.', 'error'); return; }
                    if (this.servers.some(s => s.name === trimmedName)) { this.addNotification(`Server name "${trimmedName}" already exists.`, 'error'); return; }
                    if (this.newServer.type === 'sse' && !trimmedPath.match(/^https?:\/\//)) { this.addNotification('SSE server requires a valid HTTP(S) URL.', 'error'); return; }
                    this.isLoading = true;
                    try {
                        const payload = { name: trimmedName, type: this.newServer.type, path: trimmedPath, argsString: this.newServer.argsString.trim() || "" };
                        await this.apiFetch('/servers', { method: 'POST', body: JSON.stringify(payload) });
                        this.addNotification(`Server ${payload.name} added.`, 'success');
                        this.showAddServerModal = false; this.newServer = { name: '', type: 'stdio', path: '', argsString: '' };
                        await this.fetchServers();
                    } catch (e) { this.addNotification(`Failed to add server ${trimmedName}.`, 'error'); }
                    finally { this.isLoading = false; }
                },


                // --- DISCOVERY ---
                async discoverServers(type) {
                    if (type === 'mdns' && !this.config.enableLocalDiscovery) { this.addNotification('mDNS discovery is disabled in settings.', 'warning'); return; }
                    console.log(`Discovering servers (${type}) via API...`); this.isLoadingDiscovery = true; this.discoveredServers = [];
                    try {
                        const results = await this.apiFetch(`/discover?type=${type}`, { method: 'POST' });
                        this.discoveredServers = results || [];
                        this.addNotification(`${type} discovery finished. Found ${this.discoveredServers.length}.`, this.discoveredServers.length > 0 ? 'success' : 'info', 2500);
                    } catch (e) { this.addNotification(`Discovery (${type}) failed.`, 'error'); }
                    finally { this.isLoadingDiscovery = false; }
                },
                serverExists(discoveredServer) {
                    if (!discoveredServer) return false; const pathOrUrl = discoveredServer.path || discoveredServer.url;
                    return this.servers.some(s => s.name === discoveredServer.name || s.path === pathOrUrl);
                },
                addDiscoveredServer(discoveredServer) {
                    if (!discoveredServer) return;
                    this.newServer = { name: discoveredServer.name || `discovered-${discoveredServer.type || 'server'}`, type: discoveredServer.type || 'sse', path: discoveredServer.path || discoveredServer.url || '', argsString: discoveredServer.args ? discoveredServer.args.join(' ') : '' };
                    this.addServer();
                },


                reconcileFavoriteTools() {
                    if (!this.tools || this.tools.length === 0) {
                        console.warn("Tools not loaded, cannot reconcile favorites yet.");
                        this.favoriteTools = [];
                        return;
                    }
                    this.favoriteTools = this.favoriteToolIds.map(favId => this.tools.find(t => t.name === favId)).filter(Boolean);
                    console.log("Reconciled Favorites:", this.favoriteTools.length);
                },
                reconcileRecentTools() {
                    if (!this.tools || this.tools.length === 0) {
                        console.warn("Tools not loaded, cannot reconcile recents yet.");
                        this.recentTools = [];
                        return;
                    }
                    this.recentTools = this.recentToolIds.map(recentId => this.tools.find(t => t.name === recentId)).filter(Boolean);
                    console.log("Reconciled Recents:", this.recentTools.length);
                },
                setupResponsiveHandling() {
                    window.addEventListener('resize', () => {
                        if (window.innerWidth >= 768 && this.isSidebarOpen) {
                            this.isSidebarOpen = false;
                        }
                    });
                },
                numberWithCommas(x) {
                    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
                },
                toggleSidebar(force) {
                    if (typeof force !== 'undefined') {
                        this.isSidebarOpen = force;
                    } else {
                        this.isSidebarOpen = !this.isSidebarOpen;
                    }
                },
                loadUISettings() {
                    const defaultSettings = {
                        showTimestamps: true,
                        groupMessagesByDate: false,
                        compactMode: false,
                        showStatusBar: true,
                        virtualScrolling: false,
                        sendOnEnter: true,
                        showToolDataMessages: true
                    };
                    // Use the helper function
                    this.uiSettings = this.loadFromStorage('mcp_client_ui_settings', defaultSettings);
                    console.log("UI Settings loaded:", this.uiSettings);
                },
                saveUISettings(settings = this.uiSettings) {
                    // Use the helper function
                    this.saveToStorage('mcp_client_ui_settings', settings);
                },
                saveUiSetting(key, value) {
                    this.uiSettings[key] = value;
                    this.saveUISettings();
                },
                setupKeyboardShortcuts() {
                    Mousetrap.bind('?', () => {
                        this.showKeyboardShortcutsModal = true;
                    });
                    Mousetrap.bind('ctrl+f', (e) => {
                        e.preventDefault();
                        this.isMessageSearchActive = !this.isMessageSearchActive;
                        if (this.isMessageSearchActive) {
                            this.$nextTick(() => {
                                document.querySelector('.message-search-container input').focus();
                            });
                        }
                    });
                    Mousetrap.bind('alt+s', () => {
                        this.toggleSidebar();
                    });
                    Mousetrap.bind('esc', () => {
                        if (this.isSendingMessage) {
                            this.stopGeneration();
                        } else if (this.isMessageSearchActive) {
                            this.isMessageSearchActive = false;
                        }
                    });
                    Mousetrap.bind('/', (e) => {
                        if (!this.isSendingMessage && this.$refs.inputarea) {
                            e.preventDefault();
                            this.$refs.inputarea.focus();
                        }
                    });
                    Mousetrap.bind('ctrl+k', () => {
                        this.userInput = '';
                        if (this.$refs.inputarea) {
                            this.$refs.inputarea.focus();
                        }
                    });
                    Mousetrap.bind('alt+1', () => {
                        this.activeTab = 'servers';
                    });
                    Mousetrap.bind('alt+2', () => {
                        this.activeTab = 'tools';
                    });
                    Mousetrap.bind('alt+3', () => {
                        this.activeTab = 'conversation';
                    });
                    Mousetrap.bind('alt+4', () => {
                        this.activeTab = 'config';
                    });
                    Mousetrap.bind('alt+5', () => {
                        this.activeTab = 'dashboard';
                    });
                },
                findNextSearchMatch() {
                    if (this.searchMatches.length === 0) {
                        this.performMessageSearch();
                        return;
                    }
                    if (this.currentSearchMatchIndex < this.searchMatches.length - 1) {
                        this.currentSearchMatchIndex++;
                        this.scrollToSearchMatch(this.searchMatches[this.currentSearchMatchIndex]);
                    }
                },
                findPreviousSearchMatch() {
                    if (this.searchMatches.length === 0) {
                        return;
                    }
                    if (this.currentSearchMatchIndex > 0) {
                        this.currentSearchMatchIndex--;
                        this.scrollToSearchMatch(this.searchMatches[this.currentSearchMatchIndex]);
                    }
                },
                performMessageSearch() {
                    if (!this.messageSearchQuery.trim()) {
                        this.searchMatches = [];
                        this.currentSearchMatchIndex = -1;
                        return;
                    }
                    const query = this.messageSearchQuery.toLowerCase();
                    this.searchMatches = this.currentConversation.filter(message => {
                        const content = typeof message.content === 'string' ? message.content.toLowerCase() : JSON.stringify(message.content).toLowerCase();
                        return content.includes(query);
                    }).map((message, index) => ({
                        messageIndex: index,
                        messageId: message.id
                    }));
                    this.currentSearchMatchIndex = this.searchMatches.length > 0 ? 0 : -1;
                    if (this.searchMatches.length > 0) {
                        this.scrollToSearchMatch(this.searchMatches[0]);
                    }
                },
                scrollToSearchMatch(match) {
                    if (!match) return;
                    const messageEl = document.getElementById(`message-${match.messageId || match.messageIndex}`);
                    if (messageEl) {
                        messageEl.scrollIntoView({
                            behavior: 'smooth',
                            block: 'center'
                        });
                        messageEl.classList.add('bg-warning/10');
                        setTimeout(() => {
                            messageEl.classList.remove('bg-warning/10');
                        }, 1000);
                    }
                },
                renderMessageWithHighlight(message) {
                    let content = this.renderMessageContent(message);
                    if (!this.isMessageSearchActive || !this.messageSearchQuery.trim()) {
                        return content;
                    }
                    const sanitizedQuery = this.messageSearchQuery.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`(${sanitizedQuery})`, 'gi');
                    content = content.replace(/>[^<]+</g, match => {
                        return match.replace(regex, '<span class="search-result-highlight">$1</span>');
                    });
                    return content;
                },
                performGlobalSearch() {
                    if (!this.globalSearchQuery.trim()) {
                        this.searchResults = [];
                        this.searchPerformed = false;
                        return;
                    }
                    this.isSearching = true;
                    this.searchPerformed = true;
                    this.searchResults = [];
                    const nodes = Alpine.store('conversation').conversationNodes;
                    setTimeout(() => {
                        try {
                            const results = this.currentConversation.filter(message => {
                                const content = typeof message.content === 'string' ? message.content : JSON.stringify(message.content);
                                if (!this.searchOptions.includeSystem && message.role === 'system') {
                                    return false;
                                }
                                let searchText = content;
                                let queryText = this.globalSearchQuery;
                                if (!this.searchOptions.caseSensitive) {
                                    searchText = searchText.toLowerCase();
                                    queryText = queryText.toLowerCase();
                                }
                                if (this.searchOptions.wholeWord) {
                                    const regex = new RegExp(`\\b${queryText}\\b`, this.searchOptions.caseSensitive ? '' : 'i');
                                    return regex.test(content);
                                }
                                return searchText.includes(queryText);
                            }).map(message => ({
                                messageId: message.id,
                                nodeId: this.currentNodeId,
                                nodeName: nodes.find(n => n.id === this.currentNodeId)?.name || 'Current Conversation',
                                role: message.role,
                                content: typeof message.content === 'string' ? message.content : JSON.stringify(message.content),
                                timestamp: message.timestamp
                            }));
                            this.searchResults = results;
                        } catch (error) {
                            console.error('Search error:', error);
                            this.addNotification('Error performing search', 'error');
                        } finally {
                            this.isSearching = false;
                        }
                    }, 500);
                },
                highlightSearchResult(content, query) {
                    if (!query || !content) return content;
                    const sanitizedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`(${sanitizedQuery})`, 'gi');
                    const maxLength = 200;
                    let truncatedContent = content;
                    if (content.length > maxLength) {
                        const lowerContent = content.toLowerCase();
                        const lowerQuery = query.toLowerCase();
                        const matchPos = lowerContent.indexOf(lowerQuery);
                        if (matchPos >= 0) {
                            const startPos = Math.max(0, matchPos - 50);
                            truncatedContent = (startPos > 0 ? '...' : '') + content.substring(startPos, Math.min(content.length, startPos + maxLength)) + (startPos + maxLength < content.length ? '...' : '');
                        } else {
                            truncatedContent = content.substring(0, maxLength) + '...';
                        }
                    }
                    return truncatedContent.replace(regex, '<span class="search-result-highlight">$1</span>');
                },
                checkoutBranchAndScrollToMessage(nodeId, messageTimestamp) {
                    this.checkoutBranch(nodeId).then(() => {
                        this.$nextTick(() => {
                            setTimeout(() => {
                                const message = this.currentConversation.find(m => m.timestamp === messageTimestamp);
                                if (message) {
                                    const messageIndex = this.currentConversation.indexOf(message);
                                    const messageEl = document.getElementById(`message-${message.id || messageIndex}`);
                                    if (messageEl) {
                                        messageEl.scrollIntoView({
                                            behavior: 'smooth',
                                            block: 'center'
                                        });
                                        messageEl.classList.add('bg-warning/10');
                                        setTimeout(() => messageEl.classList.remove('bg-warning/10'), 1500);
                                    }
                                }
                            }, 300);
                        });
                    });
                },
                updateGroupedMessages() {
                    if (!this.currentConversation || !this.currentConversation.length) {
                        this.groupedMessages = {};
                        return;
                    }
                    const groups = {};
                    this.currentConversation.forEach(message => {
                        if (!message.timestamp) return;
                        const date = new Date(message.timestamp).toISOString().split('T')[0];
                        if (!groups[date]) {
                            groups[date] = [];
                        }
                        groups[date].push(message);
                    });
                    this.groupedMessages = groups;
                },
                formatMessageDate(dateStr) {
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const yesterday = new Date(today);
                    yesterday.setDate(yesterday.getDate() - 1);
                    const date = new Date(dateStr);
                    date.setHours(0, 0, 0, 0);
                    if (date.getTime() === today.getTime()) {
                        return 'Today';
                    } else if (date.getTime() === yesterday.getTime()) {
                        return 'Yesterday';
                    } else {
                        if (typeof dateFns !== 'undefined') {
                            return dateFns.format(new Date(dateStr), 'MMMM d, yyyy');
                        } else {
                            return new Date(dateStr).toLocaleDateString();
                        }
                    }
                },
                loadBookmarkedMessages() {
                    // Use the helper function with an empty array as default
                    this.bookmarkedMessages = this.loadFromStorage('mcp_client_bookmarks', []);
                    console.log(`Loaded ${this.bookmarkedMessages.length} bookmarks.`);
                },
                saveBookmarkedMessages() {
                    // Use the helper function
                    this.saveToStorage('mcp_client_bookmarks', this.bookmarkedMessages);
                },
                toggleBookmark(messageTimestamp, nodeId = this.currentNodeId) {
                    if (!messageTimestamp || !nodeId) return;
                    if (event) {
                        event.stopPropagation();
                        event.preventDefault();
                    }
                    const isBookmarked = this.isMessageBookmarked(messageTimestamp, nodeId);
                    if (isBookmarked) {
                        this.bookmarkedMessages = this.bookmarkedMessages.filter(m => m.timestamp !== messageTimestamp || m.nodeId !== nodeId);
                        this.addNotification('Message removed from bookmarks', 'info');
                    } else {
                        const message = this.currentConversation.find(m => m.timestamp === messageTimestamp);
                        if (message) {
                            const bookmarkData = {
                                timestamp: messageTimestamp,
                                role: message.role,
                                content: typeof message.content === 'string' ? message.content : JSON.stringify(message.content),
                                nodeId: nodeId,
                                nodeName: this.conversationNodes.find(n => n.id === nodeId)?.name || 'Unnamed'
                            };
                            this.bookmarkedMessages.push(bookmarkData);
                            this.addNotification('Message bookmarked', 'success');
                        }
                    }
                    this.$nextTick(() => this.saveBookmarkedMessages());
                },
                isMessageBookmarked(messageTimestamp, nodeId = this.currentNodeId) {
                    if (!messageTimestamp) return false;
                    return this.bookmarkedMessages.some(m => m.timestamp === messageTimestamp && m.nodeId === nodeId);
                },
                openMessageBookmarks() {
                    this.showBookmarksModal = true;
                },
                navigateToBookmark(bookmark) {
                    this.checkoutBranchAndScrollToMessage(bookmark.nodeId, bookmark.timestamp);
                    this.showBookmarksModal = false;
                },
                removeBookmark(messageTimestamp, nodeId) {
                    this.bookmarkedMessages = this.bookmarkedMessages.filter(m => m.timestamp !== messageTimestamp || m.nodeId !== nodeId);
                    this.saveBookmarkedMessages();
                },
                updateVirtualScrollHeight() {
                    const avgMessageHeight = 100;
                    this.virtualScrollHeight = Math.max(500, this.currentConversation.length * avgMessageHeight);
                },
                showBranchComparison(branchId) {
                    if (!branchId || branchId === this.currentNodeId) {
                        this.addNotification('Cannot compare a branch with itself', 'warning');
                        return;
                    }
                    this.comparisonBranchId = branchId;
                    this.comparisonBranchName = this.getNodeById(branchId)?.name || 'Comparison Branch';
                    this.currentBranchName = this.getNodeById(this.currentNodeId)?.name || 'Current Branch';
                    this.performBranchComparison();
                    this.isBranchComparisonActive = true;
                },
                performBranchComparison() {
                    const currentMessages = this.currentConversation.map(m => ({
                        id: m.id,
                        role: m.role,
                        content: typeof m.content === 'string' ? m.content : JSON.stringify(m.content),
                        timestamp: m.timestamp,
                        status: 'unchanged'
                    }));
                    const comparisonMessages = [...currentMessages];
                    if (comparisonMessages.length > 1) {
                        comparisonMessages.splice(1, 0, {
                            id: 'added-msg-' + Date.now(),
                            role: 'assistant',
                            content: 'This message only exists in the comparison branch.',
                            timestamp: new Date().toISOString(),
                            status: 'added'
                        });
                    }
                    if (comparisonMessages.length > 2) {
                        comparisonMessages[2] = {
                            ...comparisonMessages[2],
                            content: 'This message was modified in the comparison branch.',
                            status: 'modified'
                        };
                    }
                    if (comparisonMessages.length > 3) {
                        comparisonMessages.splice(3, 1);
                    }
                    this.branchComparison = {
                        current: currentMessages,
                        comparison: comparisonMessages
                    };
                    let added = 0,
                        removed = 0,
                        modified = 0,
                        unchanged = 0;
                    const currentIds = currentMessages.map(m => m.id);
                    const comparisonIds = comparisonMessages.map(m => m.id);
                    comparisonIds.forEach(id => {
                        if (!currentIds.includes(id)) added++;
                    });
                    currentIds.forEach(id => {
                        if (!comparisonIds.includes(id)) removed++;
                    });
                    const commonIds = currentIds.filter(id => comparisonIds.includes(id));
                    commonIds.forEach(id => {
                        const currentMsg = currentMessages.find(m => m.id === id);
                        const comparisonMsg = comparisonMessages.find(m => m.id === id);
                        if (currentMsg.content !== comparisonMsg.content) {
                            modified++;
                        } else {
                            unchanged++;
                        }
                    });
                    this.comparisonStats = {
                        added,
                        removed,
                        modified,
                        unchanged
                    };
                },
                viewDetailedComparison() {
                    this.showBranchComparisonModal = true;
                },
                closeBranchComparison() {
                    this.isBranchComparisonActive = false;
                    this.comparisonBranchId = null;
                },
                exportBranchComparison() {
                    let content = `# Branch Comparison Report\n\n## ${this.currentBranchName} vs ${this.comparisonBranchName}\n\n- Added: ${this.comparisonStats.added}\n- Removed: ${this.comparisonStats.removed}\n- Modified: ${this.comparisonStats.modified}\n- Unchanged: ${this.comparisonStats.unchanged}\n\n## Changes\n\n`;
                    this.branchComparison.comparison.forEach(message => {
                        if (message.status !== 'unchanged') {
                            content += `### ${message.status.toUpperCase()}: ${message.role} message\n\n\`\`\`\n${message.content}\n\`\`\`\n\n`;
                        }
                    });
                    const blob = new Blob([content], {
                        type: "text/markdown;charset=utf-8"
                    });
                    saveAs(blob, `branch-comparison-${Date.now()}.md`);
                },
                loadAllTags() {
                    // Use the helper function
                    this.allTags = this.loadFromStorage('mcp_client_all_tags', []);
                    console.log(`Loaded ${this.allTags.length} global tags.`);
                },
                saveAllTags() {
                    // Use the helper function
                    this.saveToStorage('mcp_client_all_tags', this.allTags);
                },
                loadConversationTags() {
                    // Use the helper function with a dynamic key
                    const key = `mcp_client_conversation_tags_${this.currentNodeId}`;
                    this.conversationTags = this.loadFromStorage(key, []);
                    // console.log(`Loaded ${this.conversationTags.length} tags for node ${this.currentNodeId}.`); // Optional: more verbose log
                },
                saveConversationTags() {
                    // Use the helper function with a dynamic key
                    const key = `mcp_client_conversation_tags_${this.currentNodeId}`;
                    this.saveToStorage(key, this.conversationTags);
                },
                createTag() {
                    if (!this.newTag.name.trim()) {
                        this.addNotification('Tag name cannot be empty', 'warning');
                        return;
                    }
                    const tagId = 'tag-' + Date.now();
                    const newTag = {
                        id: tagId,
                        name: this.newTag.name.trim(),
                        color: this.newTag.color
                    };
                    this.allTags.push(newTag);
                    this.saveAllTags();
                    this.addTagToConversation(tagId);
                    this.newTag = {
                        name: '',
                        color: '#3B82F6'
                    };
                    this.showAddTagModal = false;
                    this.addNotification(`Tag "${newTag.name}" created`, 'success');
                },
                addTagToConversation(tagId) {
                    const tag = this.allTags.find(t => t.id === tagId);
                    if (!tag) return;
                    if (this.conversationTags.some(t => t.id === tagId)) {
                        this.addNotification(`Tag "${tag.name}" already added to conversation`, 'info');
                        return;
                    }
                    this.conversationTags.push(tag);
                    this.saveConversationTags();
                    this.addNotification(`Tag "${tag.name}" added to conversation`, 'success');
                },
                removeTagFromConversation(tagId) {
                    const tagName = this.conversationTags.find(t => t.id === tagId)?.name;
                    this.conversationTags = this.conversationTags.filter(t => t.id !== tagId);
                    this.saveConversationTags();
                    if (tagName) {
                        this.addNotification(`Tag "${tagName}" removed from conversation`, 'info');
                    }
                },
                loadMessageTemplates() {
                    // Use the helper function
                    this.messageTemplates = this.loadFromStorage('mcp_client_message_templates', []);
                    console.log(`Loaded ${this.messageTemplates.length} message templates.`);
                },
                saveMessageTemplates() {
                    // Use the helper function
                    this.saveToStorage('mcp_client_message_templates', this.messageTemplates);
                },
                saveTemplate() {
                    if (!this.templateForm.name.trim() || !this.templateForm.content.trim()) {
                        this.addNotification('Template name and content are required', 'warning');
                        return;
                    }
                    if (this.editingTemplate) {
                        const index = this.messageTemplates.findIndex(t => t.id === this.templateForm.id);
                        if (index >= 0) {
                            this.messageTemplates[index] = {
                                ...this.templateForm
                            };
                            this.addNotification(`Template "${this.templateForm.name}" updated`, 'success');
                        }
                    } else {
                        const newTemplate = {
                            id: 'template-' + Date.now(),
                            name: this.templateForm.name.trim(),
                            description: this.templateForm.description.trim(),
                            content: this.templateForm.content.trim()
                        };
                        this.messageTemplates.push(newTemplate);
                        this.addNotification(`Template "${newTemplate.name}" created`, 'success');
                    }
                    this.saveMessageTemplates();
                    this.templateForm = {
                        id: null,
                        name: '',
                        description: '',
                        content: ''
                    };
                    this.showCreateTemplateForm = false;
                    this.editingTemplate = false;
                },
                editTemplate(template) {
                    this.templateForm = {
                        ...template
                    };
                    this.editingTemplate = true;
                    this.showCreateTemplateForm = false;
                },
                deleteTemplate(templateId) {
                    const template = this.messageTemplates.find(t => t.id === templateId);
                    if (!template) return;
                    if (confirm(`Are you sure you want to delete the template "${template.name}"?`)) {
                        this.messageTemplates = this.messageTemplates.filter(t => t.id !== templateId);
                        this.saveMessageTemplates();
                        this.addNotification(`Template "${template.name}" deleted`, 'info');
                    }
                },
                applyTemplate(template) {
                    this.userInput = template.content;
                    this.showTemplatesModal = false;
                    this.$nextTick(() => {
                        if (this.$refs.inputarea) {
                            this.adjustTextareaHeight(this.$refs.inputarea);
                            this.$refs.inputarea.focus();
                        }
                    });
                },
                cancelTemplateEdit() {
                    this.templateForm = {
                        id: null,
                        name: '',
                        description: '',
                        content: ''
                    };
                    this.showCreateTemplateForm = false;
                    this.editingTemplate = false;
                },
                loadFavoriteTools() {
                    // Use the helper function (still loading IDs)
                    this.favoriteToolIds = this.loadFromStorage('mcp_client_favorite_tools', []);
                    console.log(`Loaded ${this.favoriteToolIds.length} favorite tool IDs.`);
                    // Note: Reconciliation happens separately after tools are loaded
                },
                saveFavoriteTools() {
                    // Map to IDs before saving using the helper
                    const toolIds = this.favoriteTools.map(tool => tool.name);
                    this.saveToStorage('mcp_client_favorite_tools', toolIds);
                },
                toggleFavoriteTool(tool) {
                    if (!tool) return;
                    const isFavorite = this.isFavoriteTool(tool);
                    if (isFavorite) {
                        this.favoriteTools = this.favoriteTools.filter(t => t.name !== tool.name);
                        this.addNotification(`Removed "${tool.shortName || tool.name}" from favorites`, 'info');
                    } else {
                        if (!this.favoriteTools.some(t => t.name === tool.name)) {
                            this.favoriteTools.push(tool);
                            this.addNotification(`Added "${tool.shortName || tool.name}" to favorites`, 'success');
                        }
                    }
                    this.saveFavoriteTools();
                },
                isFavoriteTool(tool) {
                    if (!tool) return false;
                    return this.favoriteTools.some(t => t.name === tool.name);
                },
                clearFavorites() {
                    if (confirm('Are you sure you want to clear all favorite tools?')) {
                        this.favoriteTools = [];
                        this.saveFavoriteTools();
                        this.addNotification('All favorites cleared', 'info');
                    }
                },
                loadRecentTools() {
                    // Use the helper function (still loading IDs)
                    this.recentToolIds = this.loadFromStorage('mcp_client_recent_tools', []);
                    console.log(`Loaded ${this.recentToolIds.length} recent tool IDs.`);
                    // Note: Reconciliation happens separately after tools are loaded
                },
                saveRecentTools() {
                    // Map to IDs before saving using the helper
                    const toolIds = this.recentTools.map(tool => tool.name);
                    this.saveToStorage('mcp_client_recent_tools', toolIds);
                },
                addToRecentTools(tool) {
                    if (!tool) return;
                    this.recentTools = this.recentTools.filter(t => t.name !== tool.name);
                    this.recentTools.unshift(tool);
                    if (this.recentTools.length > 5) {
                        this.recentTools = this.recentTools.slice(0, 5);
                    }
                    this.saveRecentTools();
                },
                clearRecentTools() {
                    this.recentTools = [];
                    this.saveRecentTools();
                    this.addNotification('Recent tools cleared', 'info');
                },
                refreshDashboardData() {
                    this.isLoadingDashboard = true;
                    setTimeout(() => {
                        this.dashboardStats = {
                            activeServers: this.servers.filter(s => s.isConnected).length,
                            totalTools: this.tools.length,
                            totalConversations: this.conversationNodes.length,
                            totalMessages: this.currentConversation.length,
                            cacheHitRate: Math.round(Math.random() * 100),
                            systemUptime: '3h 42m',
                            topTools: this.generateDemoTopTools(),
                            serverHealth: this.generateDemoServerHealth()
                        };
                        this.dashboardLastUpdated = new Date().toISOString();
                        this.isLoadingDashboard = false;
                        this.initDashboardCharts();
                    }, 800);
                },
                generateDemoTopTools() {
                    return this.tools.slice(0, 5).map(tool => ({
                        name: tool.name,
                        shortName: tool.name.split(':').pop(),
                        server: tool.server_name,
                        count: Math.floor(Math.random() * 50) + 1,
                        successRate: Math.floor(Math.random() * 30) + 70
                    }));
                },
                generateDemoServerHealth() {
                    return this.servers.map(server => ({
                        name: server.name,
                        type: server.type,
                        status: server.isConnected ? (Math.random() > 0.8 ? 'degraded' : 'healthy') : 'error',
                        responseTime: Math.floor(Math.random() * 200) + 50,
                        errorRate: Math.floor(Math.random() * 5),
                        uptime: `${Math.floor(Math.random() * 24)}h ${Math.floor(Math.random() * 60)}m`
                    }));
                },
                initDashboardCharts() {
                    console.log('Dashboard charts would be initialized here');
                },
                checkAllServerHealth() {
                    this.isCheckingServerHealth = true;
                    setTimeout(() => {
                        this.dashboardStats.serverHealth = this.generateDemoServerHealth();
                        this.isCheckingServerHealth = false;
                        this.addNotification('Server health check complete', 'success');
                    }, 1500);
                },
                toggleSystemStats() {
                    this.uiSettings.showStatusBar = !this.uiSettings.showStatusBar;
                    this.saveUISettings();
                },
                renameBranch(nodeId, currentName) {
                    this.renameBranchForm = {
                        id: nodeId,
                        name: currentName || ''
                    };
                    this.showRenameBranchModal = true;
                },
                async saveBranchRename() {
                    if (!this.renameBranchForm.id || !this.renameBranchForm.name.trim()) {
                        this.addNotification('Branch name cannot be empty', 'warning');
                        return;
                    }
                    const nodes = [...Alpine.store('conversation').conversationNodes];
                    const nodeIndex = nodes.findIndex(n => n.id === this.renameBranchForm.id);
                    if (nodeIndex >= 0) {
                        try {
                            const payload = {
                                new_name: this.renameBranchForm.name.trim()
                            };
                            await this.apiFetch(`/conversation/nodes/${this.renameBranchForm.id}/rename`, {
                                method: 'PUT',
                                body: JSON.stringify(payload)
                            });
                            nodes[nodeIndex].name = this.renameBranchForm.name.trim();
                            Alpine.store('conversation').setNodes(nodes);
                            this.addNotification(`Branch renamed to "${this.renameBranchForm.name}"`, 'success');
                            this.showRenameBranchModal = false;
                            this.renameBranchForm = {
                                id: null,
                                name: ''
                            };
                        } catch (e) {
                            this.addNotification(`Rename failed: ${e.message}`, 'error');
                        }
                    } else {
                        this.addNotification('Branch not found', 'error');
                    }
                },
                handleDrop(event) {
                    this.isDraggingOverDropZone = false;
                    const files = event.dataTransfer.files;
                    if (files.length === 0) return;
                    const file = files[0];
                    const fileInfo = `File: ${file.name} (${(file.size / 1024).toFixed(2)} KB, ${file.type})`;
                    this.userInput = fileInfo;
                    this.addNotification(`File "${file.name}" ready to use`, 'success');
                },
                handleToolParamsDrop(event) {
                    this.isDraggingOverToolParams = false;
                    const files = event.dataTransfer.files;
                    if (files.length === 0) return;
                    const file = files[0];
                    this.directToolParams = JSON.stringify({
                        file_name: file.name,
                        file_size: file.size,
                        file_type: file.type,
                        content_preview: "File content would be read and processed here"
                    }, null, 2);
                    this.addNotification(`File "${file.name}" added as tool parameters`, 'success');
                },
                handleFileUpload(event) {
                    const files = event.target.files;
                    if (files.length === 0) return;
                    const file = files[0];
                    const fileInfo = `File: ${file.name} (${(file.size / 1024).toFixed(2)} KB, ${file.type})`;
                    this.userInput = fileInfo;
                    this.addNotification(`File "${file.name}" uploaded`, 'success');
                    event.target.value = '';
                },
                async exportConversationAPI(format = 'json') {
                    if (!this.currentNodeId || (this.currentNodeId === 'root' && this.currentConversation.length === 0)) {
                        this.addNotification("Cannot export an empty root conversation.", "warning");
                        return;
                    }
                    this.isLoading = true;
                    this.addNotification(`Exporting branch '${this.currentNodeId.slice(0, 8)}...'`, 'info');
                    try {
                        const dataToExport = {
                            id: this.currentNodeId,
                            name: this.getNodeById(this.currentNodeId)?.name || 'Unnamed',
                            timestamp: new Date().toISOString(),
                            messages: this.currentConversation.map(msg => ({
                                id: msg.id,
                                role: msg.role,
                                content: msg.content,
                                timestamp: msg.timestamp
                            }))
                        };
                        const nodeName = dataToExport.name || this.currentNodeId.slice(0, 6);
                        const sanitizedName = nodeName.replace(/[^a-z0-9_-]/gi, '_').toLowerCase();
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                        if (format === 'json') {
                            const blob = new Blob([JSON.stringify(dataToExport, null, 2)], {
                                type: "application/json;charset=utf-8"
                            });
                            const filename = `mcp-convo-${sanitizedName}-${timestamp}.json`;
                            saveAs(blob, filename);
                            this.addNotification(`Conversation exported as ${filename}`, 'success');
                        } else if (format === 'markdown') {
                            let mdContent = `# Conversation: ${dataToExport.name}\n\nExported on: ${new Date().toLocaleString()}\n\n## Messages\n\n`;
                            dataToExport.messages.forEach(msg => {
                                mdContent += `### ${msg.role.toUpperCase()} - ${new Date(msg.timestamp).toLocaleString()}\n\n`;
                                if (typeof msg.content === 'string') {
                                    mdContent += msg.content + '\n\n';
                                } else {
                                    mdContent += '```json\n' + JSON.stringify(msg.content, null, 2) + '\n```\n\n';
                                }
                            });
                            const blob = new Blob([mdContent], {
                                type: "text/markdown;charset=utf-8"
                            });
                            const filename = `mcp-convo-${sanitizedName}-${timestamp}.md`;
                            saveAs(blob, filename);
                            this.addNotification(`Conversation exported as ${filename}`, 'success');
                        } else if (format === 'pdf') {
                            this.addNotification(`Preparing PDF export...`, 'info');
                            setTimeout(() => {
                                const filename = `mcp-convo-${sanitizedName}-${timestamp}.pdf`;
                                this.addNotification(`PDF export would save as ${filename}`, 'success');
                            }, 1500);
                        }
                    } catch (e) {
                        console.error("Export failed:", e);
                        this.addNotification(`Failed to export conversation: ${e.message}`, 'error');
                    } finally {
                        this.isLoading = false;
                    }
                },
                truncateText(text, maxLength = 100) {
                    if (!text) return '';
                    if (text.length <= maxLength) return text;
                    return text.substring(0, maxLength) + '...';
                },
                setupHljsThemeSwitcher() {
                    const lightThemeLink = document.getElementById('hljs-theme-light');
                    const darkThemeLink = document.getElementById('hljs-theme-dark');
                    if (!lightThemeLink || !darkThemeLink) {
                        console.warn("Highlight.js theme links not found.");
                        return;
                    }
                    const matcher = window.matchMedia('(prefers-color-scheme: dark)');
                    const updateHljsTheme = (isSystemDark) => {
                        const currentDaisyTheme = document.documentElement.getAttribute('data-theme') || 'light';
                        const isDaisyDark = ['dark', 'synthwave', 'halloween', 'forest', 'black', 'luxury', 'dracula', 'night', 'coffee', 'business'].includes(currentDaisyTheme);
                        lightThemeLink.disabled = isDaisyDark;
                        darkThemeLink.disabled = !isDaisyDark;
                        console.log(`HighlightJS theme set to: ${isDaisyDark ? 'dark' : 'light'}`);
                    };
                    matcher.addEventListener('change', e => updateHljsTheme(e.matches));
                    updateHljsTheme(matcher.matches);
                },
                initTippy() {
                    if (this._tippyInstances) {
                        this._tippyInstances.forEach(instance => instance.destroy());
                    }
                    this._tippyInstances = tippy('[data-tippy-content]', {
                        animation: 'scale',
                        theme: document.documentElement.getAttribute('data-theme') === 'light' ? 'dark' : 'light',
                        arrow: true,
                        allowHTML: true,
                        interactive: false,
                        placement: 'top',
                        delay: [150, 0],
                        onCreate(instance) {
                            instance.popper.style.maxWidth = '300px';
                        }
                    });
                },

                initHighlighting(container = document) {
                    this.$nextTick(() => {
                        if (typeof hljs === 'undefined') {
                            console.warn("highlight.js not loaded.");
                            return;
                        }
                        // --- ADD CHECK ---
                        if (!this.contrastOptimizer) {
                            console.warn("ContrastOptimizer not ready in initHighlighting.");
                            // return; // Optionally return if critical, or proceed without contrast fix
                        }
                        // --- END CHECK ---
                        try {
                            const blocks = container.querySelectorAll('pre code:not(.hljs)');
                            blocks.forEach((block) => {
                                const bubble = block.closest('.chat-bubble');
                                hljs.highlightElement(block);
                                if (bubble && this.contrastOptimizer) { // Check again before using
                                    this.contrastOptimizer.checkAndFixElementContrast(block, bubble);
                                }
                                // ... rest of highlighting logic ...
                            });
                            const alreadyHighlighted = container.querySelectorAll('pre code.hljs');
                            alreadyHighlighted.forEach((block) => {
                                const bubble = block.closest('.chat-bubble');
                                if (bubble && this.contrastOptimizer) { // Check again before using
                                    this.contrastOptimizer.checkAndFixElementContrast(block, bubble);
                                }
                            });
                        } catch (e) {
                            console.error("Error during highlighting:", e);
                        }
                    });
                },
                previewTheme(themeName) {
                    if (this.currentTheme !== themeName) {
                        if (this.originalThemeBeforePreview === null) {
                            this.originalThemeBeforePreview = this.currentTheme; // Store original theme ONLY if not already previewing
                        }
                        // Temporarily apply the theme without saving it
                        this.setTheme(themeName, false);
                    }
                },

                resetPreviewTheme() {
                    if (this.originalThemeBeforePreview !== null) {
                        // Revert to the original theme without saving
                        this.setTheme(this.originalThemeBeforePreview, false);
                        this.originalThemeBeforePreview = null; // Reset the stored theme
                    }
                },
                loadTheme() {
                    const savedTheme = localStorage.getItem('mcp_client_theme') || 'corporate';
                    // Call setTheme with save=false during initial load, as it's just loading, not an explicit user choice yet
                    this.setTheme(savedTheme, false);
                    // Set the original theme tracker after initial load
                    this.originalThemeBeforePreview = null;
                },
                setTheme(themeName, save = true) { // Added save parameter with default true
                    this.currentTheme = themeName;
                    document.documentElement.setAttribute('data-theme', themeName);
                    if (save) { // Only save if explicitly told to
                        localStorage.setItem('mcp_client_theme', themeName);
                        this.originalThemeBeforePreview = null; // Clear preview state when saving a real theme
                    }
                    this.setupHljsThemeSwitcher();
                    if (this.contrastOptimizer) {
                        this.contrastOptimizer.clearCaches();
                    } else {
                        console.warn("ContrastOptimizer not ready during setTheme.");
                    }
                    this.$nextTick(() => this.initTippy());
                },
                async apiFetch(endpoint, options = {}) {
                    console.log(`>>> apiFetch: Called for endpoint: '${endpoint}' with options:`, options.method || 'GET');
                    this.isLoading = true;
                    try {
                        // Add a timeout to prevent long-hanging requests
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 15000);

                        const response = await fetch(`${API_BASE_URL}${endpoint}`, {
                            signal: controller.signal,
                            headers: {
                                'Content-Type': 'application/json',
                                ...options.headers
                            },
                            ...options,
                        });

                        clearTimeout(timeoutId);
                        if (response.status === 499) {
                            throw new Error('Request cancelled by client.');
                        }
                        if (!response.ok) {
                            let errorDetail = `HTTP ${response.status}: ${response.statusText}`;
                            try {
                                const errJson = await response.json();
                                errorDetail = errJson.detail || JSON.stringify(errJson);
                            } catch (e) {
                                /* ignore */
                            }
                            throw new Error(errorDetail);
                        }
                        if (response.status === 204 || response.headers.get('content-length') === '0') {
                            return null;
                        }
                        return await response.json();
                    } catch (error) {
                        if (error.name === 'AbortError') {
                            console.log(`Request timeout: ${endpoint}`);
                            this.addNotification('Request timed out. Server may be unavailable.', 'warning');
                        } else {
                            console.error(`API Fetch Error (${endpoint}):`, error);
                            this.addNotification(`Connection error: ${error.message}`, 'error');
                        }
                        throw error;
                    } finally {
                        if (!this.isLoadingServers && !this.isLoadingTools && !this.isLoadingDiscovery /* add other flags if needed */) {
                           this.isLoading = false;
                       }
                    }
                },
                connectWebSocket() {
                    if (this.wsConnected || this.wsConnecting) return;
                    console.log('Attempting WebSocket connection...');
                    this.wsConnecting = true;
                    this.wsStatus = 'Connecting...';
                    this.wsConnected = false;
                    try {
                        this.ws = new WebSocket(WS_URL);
                    } catch (e) {
                        console.error("WebSocket creation failed:", e);
                        this.wsConnecting = false;
                        this.wsStatus = 'Error (Creation Failed)';
                        this.addNotification('Failed to create WebSocket connection.', 'error');
                        return;
                    }
                    this.ws.onopen = () => {
                        console.log('WebSocket Connected!');
                        this.wsConnected = true;
                        this.wsConnecting = false;
                        this.wsStatus = 'Connected';
                        this.wsReconnectAttempts = 0;
                        this.addNotification('Chat connected.', 'success', 1500);
                    };
                    this.ws.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);
                            this.handleWebSocketMessage(message);
                        } catch (e) {
                            console.error('Failed to parse WebSocket message:', e, event.data);
                        }
                    };
                    this.ws.onerror = (error) => {
                        console.error('WebSocket Error:', error);
                        this.wsStatus = `Error: ${error.type || 'Connection failed'}`;
                        this.addNotification('Chat connection error. Backend server may be unavailable.', 'error');
                        this.wsConnected = false;
                        this.wsConnecting = false;
                    };
                    this.ws.onclose = (event) => {
                        console.log(`WebSocket Closed: Code=${event.code}, Reason=${event.reason}, WasClean=${event.wasClean}`);
                        this.wsConnected = false;
                        this.wsConnecting = false;
                        this.wsStatus = `Disconnected (Code: ${event.code})`;
                        this.currentAssistantMessageId = null;
                        this.isSendingMessage = false;
                        this.isLoading = false;
                        this.currentStatusMessage = null;
                        if (event.code !== 1000 && event.code !== 1001) {
                            if (this.wsReconnectAttempts < 5) {
                                this.wsReconnectAttempts++;
                                const delay = Math.min(30000, Math.pow(2, this.wsReconnectAttempts) * 1000);
                                this.addNotification(`Chat disconnected. Retrying in ${delay / 1000}s...`, 'warning');
                                console.log(`WebSocket reconnect attempt ${this.wsReconnectAttempts} in ${delay}ms`);
                                setTimeout(() => this.connectWebSocket(), delay);
                            } else {
                                this.addNotification('Chat disconnected. Max retries reached.', 'error');
                                console.error('WebSocket max reconnect attempts reached.');
                                this.wsStatus = 'Disconnected (Max Retries)';
                            }
                        } else {
                            this.addNotification('Chat connection closed.', 'info');
                            this.wsStatus = 'Disconnected';
                        }
                    };
                },
                sendWebSocketMessage(message) {
                    if (this.ws && this.wsConnected) {
                        try {
                            this.ws.send(JSON.stringify(message));
                        } catch (e) {
                            console.error("Failed to send WebSocket message:", e);
                            this.addNotification('Failed to send message.', 'error');
                            if (this.ws.readyState === WebSocket.CLOSED || this.ws.readyState === WebSocket.CLOSING) {
                                this.connectWebSocket();
                            }
                        }
                    } else {
                        this.addNotification('Chat not connected. Cannot send message.', 'error');
                        console.warn('WebSocket not connected, cannot send:', message);
                        if (!this.wsConnecting) {
                            this.connectWebSocket();
                        }
                    }
                },
                handleWebSocketMessage(message) {
                // Ensure message and message.type are valid
                if (!message || typeof message.type !== 'string') {
                    console.warn('WS: Received invalid or malformed message structure:', message);
                    return;
                }

                console.log(`WS: Handling message type: ${message.type}`, message.payload);

                let assistantMsg = null; // For user-initiated queries
                let agentLlmMsg = null;  // For agent-initiated LLM interactions

                // --- Logic to find/create the correct message object to update ---
                // This needs to differentiate between a user's query stream and an agent's LLM stream.

                if (message.type.startsWith('agent_llm_')) {
                    // This message is part of an agent's LLM interaction stream
                    if (this.currentAgentLlmMessageId) {
                        agentLlmMsg = this.currentConversation.find(m => m.id === this.currentAgentLlmMessageId);
                    }
                    const isAgentStartingEvent = ['agent_llm_text_chunk', 'agent_llm_tool_call_start', 'agent_llm_status'].includes(message.type);
                    if (!agentLlmMsg && isAgentStartingEvent) {
                        const timestamp = new Date().toISOString();
                        const newMsgId = `agent_llm_response_${timestamp}_${Math.random().toString(16).slice(2)}`;
                        agentLlmMsg = {
                            role: 'assistant', // Displayed as assistant, but styled as agent
                            content: '',
                            id: newMsgId,
                            timestamp: timestamp,
                            model: this.agentStatus.agent_target_model || this.currentModelShort, // Use agent's target model
                            is_agent_activity: true, // Key flag for styling
                            content_type: 'agent_llm_stream_output', // Specific content type
                            current_status: message.type === 'agent_llm_status' ? message.payload : null,
                        };
                        this.currentConversation.push(agentLlmMsg);
                        this.currentAgentLlmMessageId = newMsgId;
                        console.log(`WS: Started NEW AGENT LLM message: ${newMsgId}`);
                    } else if (!agentLlmMsg && !isAgentStartingEvent && message.type !== 'agent_llm_final_stats' && message.type !== 'agent_llm_error') {
                        // Received a non-starting agent_llm event without an active agent_llm message (e.g., tool_call_end after text)
                        // This might happen if an agent LLM turn has multiple content blocks.
                        // We need to ensure agentLlmMsg is re-fetched if currentAgentLlmMessageId is set.
                        if(this.currentAgentLlmMessageId) { // Attempt to re-find if ID exists
                            agentLlmMsg = this.currentConversation.find(m => m.id === this.currentAgentLlmMessageId);
                            if (!agentLlmMsg) console.warn(`WS: Agent LLM event '${message.type}' received, but currentAgentLlmMessageId '${this.currentAgentLlmMessageId}' not found in conversation.`);
                        } else {
                            console.warn(`WS: Agent LLM event '${message.type}' received, but no active currentAgentLlmMessageId.`);
                        }
                    }

                } else if (!message.type.startsWith('agent_')) { // Regular user query stream
                    const backendMessageId = message.message_id;
                    if (backendMessageId) {
                        assistantMsg = this.currentConversation.find(m => m.id === backendMessageId);
                        if (assistantMsg && this.currentAssistantMessageId !== backendMessageId) {
                            this.currentAssistantMessageId = backendMessageId;
                        }
                    }
                    if (!assistantMsg && this.currentAssistantMessageId) {
                        assistantMsg = this.currentConversation.find(m => m.id === this.currentAssistantMessageId);
                    }
                    const isUserQueryStartingEvent = ['stream_start', 'text_chunk', 'status', 'tool_call_start', 'tool_call_input_chunk', 'tool_call_end'].includes(message.type);
                    if (!assistantMsg && isUserQueryStartingEvent) {
                        const timestamp = new Date().toISOString();
                        const newMsgId = backendMessageId || `client_assistant_${timestamp}_${Math.random().toString(16).slice(2)}`;
                        assistantMsg = {
                            role: 'assistant',
                            content: '',
                            id: newMsgId,
                            timestamp: timestamp,
                            current_status: message.type === 'status' ? message.payload : null,
                            model: this.currentModelShort,
                            is_agent_activity: false // This is a direct LLM response to user
                        };
                        this.currentConversation.push(assistantMsg);
                        this.currentAssistantMessageId = newMsgId;
                    }
                }
                // --- End logic to find/create message object ---

                // --- Process message based on type ---
                switch (message.type) {
                    // == Standard User Query Stream Events ==
                    case 'text_chunk':
                        if (assistantMsg) { // For user's query
                            if (typeof assistantMsg.content !== 'string') assistantMsg.content = '';
                            assistantMsg.content += (typeof message.payload === 'string' ? message.payload : JSON.stringify(message.payload));
                            assistantMsg.current_status = null;
                            this.currentConversation = [...this.currentConversation];
                        } else {
                            console.warn("WS (user query): Received text_chunk but no active assistant message.");
                        }
                        this.scrollToBottom();
                        break;
                    case 'status': // For user's query
                        if (assistantMsg) {
                            assistantMsg.current_status = message.payload;
                            this.currentConversation = [...this.currentConversation];
                        } else {
                            this.currentStatusMessage = message.payload; // Global status
                            setTimeout(() => { if (this.currentStatusMessage === message.payload) this.currentStatusMessage = null; }, 4000);
                        }
                        this.scrollToBottom();
                        break;
                    case 'tool_result': // This is when a tool called by USER's query returns data to LLM
                        const toolResultPayload = message.payload;
                        this.addMessageToConversation('user', [toolResultPayload], { // User role because it's input to LLM
                            content_type: 'tool_result',
                            id: `tool_result_user_${toolResultPayload.tool_use_id || Date.now()}`,
                            is_error: toolResultPayload.is_error || false,
                            tool_name: toolResultPayload.tool_name,
                            is_agent_activity: false // Not agent's own activity
                        });
                        this.scrollToBottom();
                        break;
                    case 'query_complete': // For user's query
                    case 'stream_end':     // For user's query
                        this.isSendingMessage = false; // This is for user-initiated queries
                        this.isLoading = false;
                        this.currentStatusMessage = null;
                        if (assistantMsg) assistantMsg.current_status = null;
                        this.currentAssistantMessageId = null; // Reset for user queries
                        this.currentConversation = [...this.currentConversation];
                        this.$nextTick(() => this.initHighlighting(this.$refs.chatbox));
                        break;

                    // == Agent LLM Stream Events ==
                    case 'agent_llm_text_chunk':
                        if (agentLlmMsg) {
                            if (typeof agentLlmMsg.content !== 'string') agentLlmMsg.content = '';
                            agentLlmMsg.content += (typeof message.payload === 'string' ? message.payload : JSON.stringify(message.payload));
                            agentLlmMsg.current_status = null;
                            this.currentConversation = [...this.currentConversation];
                        } else {
                            console.warn("WS (agent LLM): Received agent_llm_text_chunk but no active agent LLM message.");
                        }
                        this.scrollToBottom();
                        break;
                    case 'agent_llm_tool_call_start':
                        if (agentLlmMsg) { // Add to the agent's LLM output bubble
                            // Ensure content is an array to hold multiple blocks
                            if (!Array.isArray(agentLlmMsg.content)) agentLlmMsg.content = [];
                            // Add a placeholder or representation for the tool call start
                            agentLlmMsg.content.push({
                                type: "agent_tool_call_placeholder_start", // Custom internal type for rendering
                                name: message.payload.name,
                                id: message.payload.id,
                                status_text: `Agent preparing tool: ${message.payload.name.split(':').pop()} (ID: ${message.payload.id.substring(0,8)})...`
                            });
                            agentLlmMsg.current_status = `Agent preparing tool: ${message.payload.name.split(':').pop()}`;
                            this.currentConversation = [...this.currentConversation];
                        }
                        this.scrollToBottom();
                        break;
                    case 'agent_llm_tool_call_input_chunk':
                        // Could update a specific tool_call_placeholder in agentLlmMsg.content if needed
                        // For now, a general status update is often enough for this.
                        if (agentLlmMsg && agentLlmMsg.current_status) {
                            agentLlmMsg.current_status = `Agent tool input streaming... (${message.payload.id.substring(0,8)})`;
                            this.currentConversation = [...this.currentConversation];
                        }
                        break;
                    case 'agent_llm_tool_call_end':
                        if (agentLlmMsg) {
                            // Update placeholder or add a new block for tool call decision
                            if (!Array.isArray(agentLlmMsg.content)) agentLlmMsg.content = [];
                            const toolEndPayload = message.payload; // {id, name, parsed_input}
                            agentLlmMsg.content.push({
                                type: "agent_tool_call_placeholder_end", // Custom internal type
                                name: toolEndPayload.name,
                                id: toolEndPayload.id,
                                input: toolEndPayload.parsed_input, // Store the parsed input for potential display
                                status_text: `Agent LLM decided to call: ${toolEndPayload.name.split(':').pop()}`
                            });
                            agentLlmMsg.current_status = `Agent LLM decided: Call ${toolEndPayload.name.split(':').pop()}`;
                            this.currentConversation = [...this.currentConversation];
                            // The actual execution and result will come via 'agent_activity_log'
                        }
                        // For agent's LLM stream, tool_call_end does NOT mean the agent stream is over.
                        // It might yield more text or more tool calls.
                        // We don't reset currentAgentLlmMessageId here.
                        this.scrollToBottom();
                        break;
                    case 'agent_llm_status':
                        if (agentLlmMsg) {
                            agentLlmMsg.current_status = `Agent LLM: ${message.payload}`;
                            this.currentConversation = [...this.currentConversation];
                        } else {
                            // General agent status if no specific agent LLM message is active
                            this.addMessageToConversation('system', `Agent Status: ${message.payload}`, {
                                is_agent_activity: true, content_type: 'agent_status_update'
                            });
                        }
                        this.scrollToBottom();
                        break;
                    case 'agent_llm_final_stats': // This signifies the end of the agent's LLM turn stream
                        this.currentStatusMessage = `Agent LLM turn finished. Stop: ${message.payload.stop_reason}`;
                        // Update token usage for the agent's turn if provided in payload
                        if (message.payload.input_tokens !== undefined) this.tokenUsage.input_tokens += message.payload.input_tokens;
                        if (message.payload.output_tokens !== undefined) this.tokenUsage.output_tokens += message.payload.output_tokens;
                        if (message.payload.total_cost !== undefined) this.tokenUsage.total_cost += message.payload.total_cost;
                        // this.saveToStorage('mcp_token_usage', this.tokenUsage); // Save updated totals

                        if (agentLlmMsg) agentLlmMsg.current_status = null; // Clear status on the bubble
                        this.currentAgentLlmMessageId = null; // Reset, agent's LLM turn is done
                        this.currentConversation = [...this.currentConversation];
                        this.$nextTick(() => this.initHighlighting(this.$refs.chatbox));
                        break;

                    // == Agent Activity Log (from AML's own actions/thoughts) ==
                    case 'agent_activity_log':
                        const activityPayload = message.payload; // Expected: {summary: "...", timestamp: "..."}
                        this.addMessageToConversation(
                            'system', // Or a dedicated 'agent_log' role if you want different styling
                            activityPayload.summary,
                            {
                                id: `agent_activity_${activityPayload.timestamp || Date.now()}`,
                                timestamp: activityPayload.timestamp || new Date().toISOString(),
                                is_agent_activity: true,
                                content_type: 'agent_log_summary' // Specific content type
                            }
                        );
                        this.scrollToBottom();
                        break;

                    // == General Websocket/Client State Messages (Mostly Unchanged) ==
                    case 'error': // Generic error from backend/MCPClient
                        this.addNotification(`Backend Error: ${message.payload.message || message.payload}`, 'error');
                        // These flags are for user-initiated queries, agent has its own status
                        if (!this.agentStatus.agent_running) {
                            this.isSendingMessage = false;
                            this.isLoading = false;
                        }
                        this.currentStatusMessage = null;
                        this.currentAssistantMessageId = null; // Reset for user query
                        this.currentAgentLlmMessageId = null; // Reset for agent query
                        this.addMessageToConversation('system', `Error processing request: ${message.payload.message || message.payload}`);
                        break;
                    case 'token_usage': // Usually for user-initiated queries' final stats
                        // If agent is running, its token usage is part of agent_llm_final_stats
                        if (!this.agentStatus.agent_running) {
                            this.tokenUsage = message.payload;
                            this.saveToStorage('mcp_token_usage', this.tokenUsage);
                        }
                        break;
                    case 'command_response':
                        const responseData = message.payload;
                        const notificationType = responseData.success ? 'success' : 'error';
                        this.addNotification(responseData.message, notificationType);
                        if (responseData.success) {
                            if (responseData.message.startsWith("Model set to:")) {
                                const newModel = responseData.message.split("Model set to: ")[1];
                                if (newModel) {
                                    this.currentModel = newModel; // This is for the user's direct interaction model
                                    // Potentially update config.defaultModel if the API confirms it
                                }
                            }
                            // Refresh conversation if a command might have changed its state
                            // (e.g., clear, fork, checkout, apply_prompt)
                            const commandsRequiringConvoRefresh = ["branch cleared", "Switched to branch", "Prompt applied"];
                            if (commandsRequiringConvoRefresh.some(txt => responseData.message.includes(txt)) || responseData.messages) {
                                console.log("Command successful, refreshing conversation state from command_response...");
                                // If payload includes messages, use them directly
                                if (responseData.messages) {
                                    this.currentConversation = responseData.messages;
                                    // If the command response provides the full new conversation state
                                    if(responseData.currentNodeId) Alpine.store('conversation').setCurrentNodeId(responseData.currentNodeId);
                                    if(responseData.nodes) Alpine.store('conversation').setNodes(responseData.nodes);
                                    this.$nextTick(() => {
                                        this.scrollToBottom(true);
                                        this.initHighlighting(this.$refs.chatbox);
                                    });
                                } else {
                                    // Fallback to fetching if messages not directly provided
                                    setTimeout(() => {
                                        this.fetchConversation().catch(err => console.error("Error fetching conversation after command:", err));
                                    }, 150);
                                }
                            }
                        }
                        break;
                    case 'state_update': // Full state update, less common for agent activity, more for initial load/major changes
                        console.log("Received full state update:", message.payload);
                        if (message.payload.servers) this.servers = message.payload.servers;
                        if (message.payload.tools) {
                            this.tools = (message.payload.tools || []).map(t => ({ ...t, shortName: t.name.split(':').pop() }));
                            this.reconcileFavoriteTools(); this.reconcileRecentTools();
                        }
                        if (message.payload.resources) this.resources = (message.payload.resources || []).map(r => ({ ...r, shortName: r.name.split(':').pop() }));
                        if (message.payload.prompts) this.prompts = (message.payload.prompts || []).map(p => ({ ...p, shortName: p.name.split(':').pop() }));

                        if (message.payload.conversation) {
                            this.currentConversation = message.payload.conversation.messages || [];
                            Alpine.store('conversation').setNodes(message.payload.conversation.nodes || [{ id: 'root', name: 'Root', parentId: null, childrenIds: [] }]);
                            Alpine.store('conversation').setCurrentNodeId(message.payload.conversation.currentNodeId || 'root');
                            this.currentModel = message.payload.conversation.model || this.config.defaultModel;
                            this.scrollToBottom(true);
                            this.$nextTick(() => this.initHighlighting(this.$refs.chatbox));
                            this.loadConversationTags();
                        }
                        if (message.payload.config) { // Update local config view
                            this.config = { ...this.config, ...message.payload.config };
                            this.currentModel = this.config.defaultModel || '';
                        }
                        // Update agent status if provided in state_update
                        if (message.payload.agent_status) {
                            this.agentStatus = { ...this.agentStatus, ...message.payload.agent_status };
                            // Update display status string
                            let display = this.agentStatus.status?.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) || 'Unknown';
                            if (this.agentStatus.agent_running) display = `Running (Loop ${this.agentStatus.current_loop}/${this.agentStatus.max_loops})`;
                            this.agentStatus.status_display = display;

                            if (this.agentStatus.agent_running && !this.agentStatusInterval) this.startAgentStatusPolling();
                            else if (!this.agentStatus.agent_running && this.agentStatusInterval) this.stopAgentStatusPolling();
                        }
                        this.$nextTick(() => this.initTippy());
                        break;
                    default:
                        console.warn('WS: Received unknown message type:', message.type, message);
                }
            },
                resetUsageStats() {
                    // Reset the object in memory
                    this.tokenUsage = { input_tokens: 0, output_tokens: 0, total_tokens: 0, total_cost: 0 };
                    // Remove the item explicitly using standard localStorage API, as saveToStorage(key, undefined) also removes it
                    localStorage.removeItem('mcp_token_usage');
                    this.addNotification("Usage stats reset.", "info");
                },

                async fetchServers() {
                    this.isLoadingServers = true; // Indicate loading specifically for servers
                    try {
                        const serversData = await this.apiFetch('/servers');
                        // Add isLoading state to each server for individual connect/disconnect feedback
                        this.servers = (serversData || []).map(s => ({
                            ...s,
                            isLoading: false,
                            statusText: s.isConnected ? 'Connected' : 'Disconnected'
                        }));
                    } catch (e) {
                        this.servers = []; // Reset on error
                        // Error notification is handled by apiFetch
                    } finally {
                        this.isLoadingServers = false;
                    }
                },
                async fetchCapabilities() {
                    this.isLoadingTools = true; // Use this flag for all capabilities
                    try {
                        // Use allSettled again for resilience
                        const results = await Promise.allSettled([
                            this.apiFetch('/tools'),
                            this.apiFetch('/resources'),
                            this.apiFetch('/prompts')
                        ]);

                        this.tools = results[0].status === 'fulfilled' ? (results[0].value || []).map(t => ({
                            ...t,
                            shortName: t.name.split(':').pop()
                        })) : [];
                        this.resources = results[1].status === 'fulfilled' ? (results[1].value || []).map(r => ({
                            ...r,
                            shortName: r.name.split(':').pop()
                        })) : [];
                        this.prompts = results[2].status === 'fulfilled' ? (results[2].value || []).map(p => ({
                            ...p,
                            shortName: p.name.split(':').pop()
                        })) : [];

                        if (results[0].status === 'rejected') this.addNotification('Failed to load tools.', 'warning');
                        if (results[1].status === 'rejected') this.addNotification('Failed to load resources.', 'warning');
                        if (results[2].status === 'rejected') this.addNotification('Failed to load prompts.', 'warning');

                        // After loading tools, reconcile favorites and recents
                        this.reconcileFavoriteTools();
                        this.reconcileRecentTools();

                    } catch (e) {
                        this.addNotification('Failed to load capabilities.', 'error');
                        this.tools = [];
                        this.resources = [];
                        this.prompts = [];
                    } finally {
                        this.isLoadingTools = false;
                    }
                },
                async fetchConversation() {
                    try {
                        const data = await this.apiFetch('/conversation');
                        console.log('fetchConversation received data:', JSON.stringify(data).substring(0, 200) + "..."); // Log truncated data
                        if (data) {
                            console.log('fetchConversation is SETTING nodes:', JSON.stringify(data.nodes || []).substring(0, 200) + "...");
                            Alpine.store('conversation').setCurrentNodeId(data.currentNodeId || 'root');
                            this.currentConversation = data.messages || [];
                            Alpine.store('conversation').setNodes(data.nodes || [{
                                id: 'root',
                                name: 'Root',
                                parentId: null,
                                childrenIds: []
                            }]);
                            this.currentModel = data.model || this.config.defaultModel;
                            this.loadConversationTags(); // Load tags for the *new* current node
                            this.$nextTick(() => {
                                this.scrollToBottom(true); // Force scroll after loading convo
                                this.initHighlighting(this.$refs.chatbox);
                                if (this.uiSettings.groupMessagesByDate) this.updateGroupedMessages();
                                if (this.uiSettings.virtualScrolling) this.updateVirtualScrollHeight();
                            });
                        } else {
                            console.log('fetchConversation received NULL data, resetting nodes.');
                            Alpine.store('conversation').setCurrentNodeId('root');
                            this.currentConversation = [];
                            Alpine.store('conversation').setNodes([{
                                id: 'root',
                                name: 'Root',
                                parentId: null,
                                childrenIds: []
                            }]);
                            this.loadConversationTags(); // Load tags for root node
                        }
                    } catch (e) {
                        this.addNotification('Failed to load conversation state.', 'error');
                    }
                },

                // --- message rendering helpers ---
                shouldHideToolMessage(message) {
                    if (this.uiSettings.showToolDataMessages) return false;
                    if (message.content_type === 'tool_result' || message.content_type === 'tool_use') return true;
                    if (Array.isArray(message.content) && message.content.length > 0) {
                        const containsOnlyToolBlocks = message.content.every(block => block && (block.type === 'tool_use' || block.type === 'tool_result'));
                        if (containsOnlyToolBlocks) return true;
                        const isUserToolResult = message.role === 'user' && message.content.length === 1 && message.content[0]?.type === 'tool_result';
                        if (isUserToolResult) return true;
                    }
                    return false;
                },
                addMessageToConversation(role, content, metadata = {}) {
                    const tempId = `${role}_${Date.now()}_${Math.random().toString(16).slice(2)}`;
                    const newMessage = {
                        role: role,
                        content: content,
                        id: metadata.id || tempId,
                        timestamp: metadata.timestamp || new Date().toISOString(),
                        model: metadata.model || (role === 'assistant' ? this.currentModelShort : null),
                        content_type: metadata.content_type || null,
                        tool_name: metadata.tool_name,
                        is_error: metadata.is_error,
                        ...metadata
                    };
                    const existingIndex = this.currentConversation.findIndex(m => m.id === newMessage.id);
                    if (existingIndex === -1) {
                        this.currentConversation.push(newMessage);
                    } else {
                        this.currentConversation[existingIndex] = {
                            ...this.currentConversation[existingIndex],
                            ...newMessage
                        };
                        this.currentConversation = [...this.currentConversation];
                    }
                    this.$nextTick(() => {
                        setTimeout(() => {
                            const messageElement = document.getElementById(`message-${newMessage.id}`);
                            if (messageElement) {
                                const bubbleElement = messageElement.querySelector('.chat-bubble');
                                if (bubbleElement) {
                                    if (this.contrastOptimizer) {
                                        this.contrastOptimizer.fixContrastRecursively(bubbleElement, bubbleElement);
                                    }
                                } else {
                                    console.warn("Could not find BUBBLE element inside message element for contrast fix:", newMessage.id);
                                }
                            } else {
                                console.log(`Message element ${newMessage.id} not found for contrast fix (likely removed before check).`);
                            }
                        }, 150);
                    });
                    this.scrollToBottom();
                },
                shouldAnimate(messageId) {
                    const lastMsg = this.currentConversation[this.currentConversation.length - 1];
                    return lastMsg && lastMsg.id === messageId;
                },
                isProbablyJsonString(str) {
                    if (typeof str !== 'string') return false;
                    const trimmed = str.trim();
                    if (!((trimmed.startsWith('{') && trimmed.endsWith('}')) || (trimmed.startsWith('[') && trimmed.endsWith(']')))) {
                        return false;
                    }
                    try {
                        return JSON.parse(trimmed);
                    } catch (e) {
                        return false;
                    }
                },
                 // Utility to inspect object properties and structure - helpful for debugging
                 debugObjectStructure(obj, maxDepth = 2, depth = 0) {
                    if (depth > maxDepth) return "...";
                    if (obj === null) return "null";
                    if (obj === undefined) return "undefined";
                    if (typeof obj !== 'object') return String(obj);

                    if (Array.isArray(obj)) {
                        if (obj.length === 0) return "[]";
                        return "[" + obj.slice(0, 3).map(item => this.debugObjectStructure(item, maxDepth, depth + 1)).join(", ") +
                            (obj.length > 3 ? ", ..." : "") + "]";
                    }

                    const keys = Object.keys(obj);
                    if (keys.length === 0) return "{}";
                    const keyValues = keys.slice(0, 5).map(key =>
                        `${key}: ${this.debugObjectStructure(obj[key], maxDepth, depth + 1)}`
                    );
                    return "{" + keyValues.join(", ") + (keys.length > 5 ? ", ..." : "") + "}";
                },
                _extractAndUnescapePayload(rawContent) {
                    if (rawContent === null || typeof rawContent === 'undefined') return null;
                    if (typeof rawContent === 'object' && !Array.isArray(rawContent)) return rawContent;
                    let contentString = '';
                    if (Array.isArray(rawContent)) {
                        contentString = rawContent[0]?.toString() || '';
                    } else {
                        contentString = rawContent.toString();
                    }
                    let extractedContent = contentString;
                    const textContentMatch = contentString.match(/TextContent\(.*?text=(['"])((?:\\.|(?!\1).)*?)\1/);
                    if (textContentMatch && textContentMatch[2]) {
                        extractedContent = textContentMatch[2];
                    }
                    let unescapedContent = extractedContent.replace(/\\"/g, '"').replace(/\\'/g, "'").replace(/\\n/g, '\n').replace(/\\\\/g, '\\').replace(/\\u([0-9a-fA-F]{4})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));
                    if ((unescapedContent.trim().startsWith('{') && unescapedContent.trim().endsWith('}')) || (unescapedContent.trim().startsWith('[') && unescapedContent.trim().endsWith(']'))) {
                        try {
                            unescapedContent = unescapedContent.replace(/[\u0000-\u001F]/g, match => {
                                return match === '\n' ? '\\n' : match === '\r' ? '\\r' : match === '\t' ? '\\t' : match === '\b' ? '\\b' : match === '\f' ? '\\f' : `\\u${match.charCodeAt(0).toString(16).padStart(4, '0')}`;
                            });
                            unescapedContent = unescapedContent.replace(/\\([^"'\\\/bfnrtu])/g, '$1');
                            return JSON.parse(unescapedContent);
                        } catch (e) {
                            console.error("JSON parsing failed:", e.message, "\nContent:", unescapedContent.substring(0, 100) + "...");
                            return unescapedContent;
                        }
                    }
                    return unescapedContent;
                },
                renderMessageContent(message) {
                    try {
                        if (message.role === 'user' && Array.isArray(message.content) && message.content.length > 0 && message.content.some(b => b?.type === 'tool_result')) {
                            if (message.content.every(b => b?.type === 'tool_result')) {
                                return message.content.map(block => this.renderUserProvidedToolResult(block, message)).join('');
                            }
                            console.warn("User message has mixed tool_result and other blocks - unusual structure.");
                        }
                        const isExplicitToolResult = message.content_type === 'tool_result';
                        const isSingleBlockToolResult = Array.isArray(message.content) && message.content.length === 1 && message.content[0]?.type === 'tool_result';
                        if (isExplicitToolResult || isSingleBlockToolResult) {
                            let resultBlock = isSingleBlockToolResult ? message.content[0] : null;
                            let resultData = isSingleBlockToolResult ? resultBlock.content : message.content;
                            if (typeof resultData === 'string' && this.isProbablyJsonString(resultData)) {
                                try {
                                    resultData = JSON.parse(resultData);
                                } catch (e) {
                                    /* Leave as string */
                                }
                            }
                            return this.visualRenderer.init(this).renderModelResult(resultData, {
                                ...message,
                                ...(resultBlock || {})
                            });
                        }
                        if (Array.isArray(message.content) && message.content.some(b => typeof b === 'object' && b !== null && b.type && b.type !== 'text')) {
                            return this.renderMixedMessageContent(message.content, message);
                        }
                        if (Array.isArray(message.content) && message.content.every(b => b?.type === 'text')) {
                            const combinedText = message.content.map(b => b?.text || '').join('\n\n');
                            return this.visualRenderer.renderMarkdown(combinedText);
                        }
                        if (typeof message.content === 'string') {
                            return this.visualRenderer.renderMarkdown(message.content);
                        }
                        if (typeof message.content === 'object' && message.content !== null && !Array.isArray(message.content)) {
                            return this.renderJson(message.content);
                        }
                        console.warn("renderMessageContent: Fallback rendering for unknown structure:", message.content);
                        if (message.content === null || message.content === undefined) {
                            return '<span class="opacity-50 italic">[No Content]</span>';
                        }
                        return `<div class="prose prose-sm max-w-none"><p>${DOMPurify.sanitize(String(message.content))}</p></div>`;
                    } catch (err) {
                        console.error('renderMessageContent() failed severely:', err, message);
                        return `<div class="text-error p-2 bg-error/10 rounded">Render error: ${DOMPurify.sanitize(err.message)}</div>`;
                    }
                },
                renderMixedMessageContent(content, message) {
                    if (!Array.isArray(content)) {
                        console.warn("renderMixedMessageContent called with non-array:", content);
                        return this.renderJson(content);
                    }
                    let html = '';
                    content.forEach((block, index) => {
                        if (!block) return;
                        if (index > 0 && (block.type === 'tool_use' || block.type === 'tool_result')) {
                            const prevBlock = content[index - 1];
                            if (prevBlock && ((prevBlock.type === 'tool_use' && block.type === 'tool_result') || (prevBlock.type === 'tool_result' && block.type === 'tool_use'))) {
                                html += `<div class="divider my-3 text-xs opacity-50 font-sans">Tool Step</div>`;
                            }
                        }
                        if (block.type === 'tool_use' && (index === 0 || (content[index - 1] && content[index - 1].type !== 'text'))) {
                            if (index > 0 || content.length > 1) {
                                html += `<div class="divider my-3 text-xs opacity-50 font-sans">Tool Step</div>`;
                            }
                        }
                        if (block.type === 'text') {
                            let textContent = block.text;
                            if (typeof textContent === 'object' && textContent !== null && textContent.content) {
                                textContent = textContent.content;
                            }
                            if (textContent === null || typeof textContent === 'undefined') {
                                textContent = '';
                            }
                            let rawText;
                            if (typeof Alpine !== 'undefined' && Alpine.raw) {
                                rawText = Alpine.raw(textContent);
                            } else {
                                rawText = JSON.parse(JSON.stringify(textContent));
                            }
                            const stringToParse = String(rawText);
                            html += this.visualRenderer.renderMarkdown(block);
                        } else if (block.type === 'tool_use') {
                            const toolName = block.name || "Unknown Tool";
                            const inputData = block.input || {};
                            let inputJson = '{}';
                            try {
                                inputJson = JSON.stringify(inputData, null, 2);
                            } catch (e) {
                                console.error("Failed to stringify tool input:", e);
                                inputJson = '{ "error": "Could not display input" }';
                            }
                            const showInputBox = inputJson !== '{}';
                            html += `<div class="not-prose my-2 p-3 border border-base-300/20 rounded-lg shadow-sm"><div class="flex flex-wrap items-baseline gap-x-2 gap-y-1 text-sm mb-1.5"><span class="flex items-center gap-1.5 font-medium"><i class="fas fa-terminal fa-fw text-info/80"></i> Using Tool: </span><p class="text-sm font-semibold font-mono px-1 py-0.5 rounded bg-transparent">${DOMPurify.sanitize(toolName)}</p> ${block.id ? `<span class="text-xs text-base-content/60">(ID: ...${DOMPurify.sanitize(block.id.slice(-6))})</span>` : ''}</div> ${showInputBox ? `<details class="rounded group border border-base-300/30 shadow-inner" open><summary class="list-none cursor-pointer select-none p-1.5 font-medium text-xs group-open:border-b group-open:border-base-300/40 transition-colors duration-150 flex items-center gap-1"><i class="fas fa-caret-right transition-transform duration-150 group-open:rotate-90"></i>Input Parameters</summary><div class="tool-content-wrapper max-h-60 overflow-y-auto group/codeblock"><pre><p class="language-json hljs">${hljs.highlight(inputJson, { language: 'json', ignoreIllegals: true }).value}</p></pre>${createCopyButton(inputJson, 'code')}</div></details>` : `<div class="text-xs italic text-base-content/60 mt-1 px-1">(No input parameters)</div>`}</div>`;
                        } else if (block.type === 'tool_result') {
                            const isError = block.is_error || false;
                            const statusClass = isError ? 'text-error' : 'text-success';
                            const statusIcon = isError ? 'fa-exclamation-circle' : 'fa-check-circle';
                            const toolUseId = block.tool_use_id || "";
                            const relatedToolUseBlock = content.find(b => b.type === 'tool_use' && b.id === toolUseId);
                            const relatedToolName = relatedToolUseBlock?.name;
                            let rawResultContent = block.content;
                            let displayContent = "";
                            let language = 'plaintext';
                            let rawContentForCopy = rawResultContent;
                            try {
                                if (typeof rawResultContent === 'string') {
                                    rawContentForCopy = rawResultContent;
                                    if (this.isProbablyJsonString(rawResultContent)) {
                                        displayContent = JSON.stringify(JSON.parse(rawResultContent), null, 2);
                                        language = 'json';
                                    } else {
                                        displayContent = rawResultContent;
                                    }
                                } else if (typeof rawResultContent === 'object' && rawResultContent !== null) {
                                    try {
                                        displayContent = JSON.stringify(rawResultContent, null, 2);
                                        rawContentForCopy = displayContent;
                                        language = 'json';
                                    } catch (stringifyError) {
                                        displayContent = String(rawResultContent);
                                        rawContentForCopy = displayContent;
                                    }
                                } else {
                                    displayContent = String(rawResultContent);
                                    rawContentForCopy = displayContent;
                                }
                            } catch (e) {
                                console.error("Error processing tool result content:", e);
                                displayContent = String(rawResultContent || (isError ? '[Error Content Processing Failed]' : '[Result Content Processing Failed]'));
                                rawContentForCopy = displayContent;
                            }
                            let highlightedContent = '';
                            if (displayContent.length < 10000) {
                                try {
                                    highlightedContent = hljs.highlight(displayContent, {
                                        language: language,
                                        ignoreIllegals: true
                                    }).value;
                                } catch (e) {
                                    console.error("Highlighting error in renderMixedMessageContent (tool_result):", e);
                                    highlightedContent = DOMPurify.sanitize(displayContent);
                                }
                            } else {
                                highlightedContent = DOMPurify.sanitize(displayContent);
                            }
                            html += `<div class="not-prose my-2 p-3 rounded-lg border ${isError ? 'border-error/30' : 'border-success/30'}"><div class="flex flex-wrap items-baseline gap-x-2 gap-y-1 ${statusClass} font-medium text-sm mb-1.5"><span class="flex items-center gap-1.5"><i class="fas ${statusIcon} fa-fw"></i>${isError ? 'Tool Error' : 'Tool Result'}</span> ${relatedToolName ? `<span class="text-xs text-base-content/70">(from <code class="text-xs font-semibold font-mono bg-base-100/50 px-1 py-0.5 rounded">${DOMPurify.sanitize(relatedToolName)}</code>)</span>` : ''} ${toolUseId ? `<span class="text-xs text-base-content/70">(for call <code class="text-xs font-mono bg-base-100/50 px-1 py-0.5 rounded">...${DOMPurify.sanitize(toolUseId.slice(-6))}</code>)</span>` : ''}</div> <div class="tool-content-wrapper group/codeblock"><pre class="overflow-auto max-h-60"><p class="language-${language} hljs whitespace-pre-wrap break-all">${highlightedContent}</p></pre>${createCopyButton(rawContentForCopy, 'result')}</div></div>`;
                        } else {
                            let unknownContent;
                            try {
                                unknownContent = JSON.stringify(block, null, 2);
                            } catch (e) {
                                unknownContent = '[Error stringifying unknown block]';
                            }
                            html += `<div class="p-2 rounded-lg my-2 opacity-70 border border-warning/30"><div class="font-medium text-xs mb-1 text-warning-content/80">Unknown Content Block Type: <code class="text-xs font-bold">${DOMPurify.sanitize(block.type || 'N/A')}</code></div><pre class="text-xs">${DOMPurify.sanitize(unknownContent)}</pre></div>`;
                        }
                    });
                    return html;
                },
                // ===== CONTENT ANALYSIS & EXTRACTION ENGINE (Component Property) =====
                contentInspector: {
                    // Core Analysis Functions
                    inspectContent(content) {
                        const result = { markdown: [], json: [], models: [], stats: null, rawText: [], detectedType: 'unknown' };
                        try {
                            this._analyzeDeep(content, result);
                            result.detectedType = this._determineContentType(result);
                        } catch (err) { console.error("Content inspection error:", err); }
                        return result;
                    },

                    // Recursive analysis engine
                    _analyzeDeep(content, result, path = '') {
                        if (content === null || content === undefined) return;

                        // --- CORRECTED STRING HANDLING ---
                        if (typeof content === 'string') {
                            // 1. Clean TextContent wrapper first
                            const cleanedContent = this._cleanTextContentWrappers(content);
                            let potentialJsonString = cleanedContent;

                            // If cleaning occurred, log it
                            if (cleanedContent !== content) {
                                console.log("_analyzeDeep: TextContent cleaned, potential JSON:", potentialJsonString);
                            } else {
                                //console.log("_analyzeDeep: Processing raw string:", content); // Less verbose log
                            }

                            // 2. Attempt to parse the *result* of cleaning as JSON
                            let parsedJson = null;
                            try {
                                const trimmed = potentialJsonString.trim();
                                if ((trimmed.startsWith('{') && trimmed.endsWith('}')) || (trimmed.startsWith('[') && trimmed.endsWith(']'))) {
                                    parsedJson = JSON.parse(potentialJsonString);
                                    //console.log("_analyzeDeep: Successfully parsed cleaned content as JSON.");
                                } else {
                                    //console.log("_analyzeDeep: Cleaned content doesn't look like JSON, skipping parse.");
                                }
                            } catch (e) {
                                //console.log("_analyzeDeep: Failed to parse cleaned content as JSON, treating as text/markdown.", e.message);
                            }

                            // 3. If JSON parsed, analyze recursively
                            if (parsedJson !== null) {
                                this._analyzeDeep(parsedJson, result, path + '.parsed');
                                return;
                            }

                            // 4. If no JSON, treat *cleaned* content as markdown or raw text
                            const contentToRender = cleanedContent; // Always use the cleaned result
                            if (this._isMarkdown(contentToRender)) {
                                //console.log("_analyzeDeep: Treating cleaned content as Markdown.");
                                result.markdown.push({ content: contentToRender, path: path });
                            } else {
                                //console.log("_analyzeDeep: Treating cleaned content as Raw Text.");
                                result.rawText.push({ content: contentToRender, path: path });
                            }
                            return;
                        }
                        // --- END CORRECTED STRING HANDLING ---


                        // Handle arrays
                        if (Array.isArray(content)) {
                            if (this._isModelResultsArray(content)) {
                                content.forEach((model, index) => {
                                    if (model && typeof model === 'object') result.models.push({ ...model, _index: index, _path: `${path}[${index}]` });
                                });
                                return;
                            }
                            content.forEach((item, index) => this._analyzeDeep(item, result, `${path}[${index}]`));
                            return;
                        }

                        // Handle objects
                        if (typeof content === 'object') {
                            if (this._isModelResultObject(content)) {
                                result.models.push({ ...content, _path: path });
                                return;
                            }
                            if (this._isStatsObject(content)) {
                                result.stats = result.stats ? { ...result.stats, ...content } : content;
                                // Don't return here, still analyze deeper if necessary
                            }

                            // Store full object as JSON *unless* it was already identified as stats/model
                            if (!this._isStatsObject(content) && !this._isModelResultObject(content)) {
                                result.json.push({ content: content, path: path });
                            }


                            // Look deeper into object properties
                            for (const key in content) {
                                if (key.startsWith('_')) continue; // Skip internal keys

                                // Special handling for common keys if they weren't part of a detected object type
                                if (!this._isModelResultObject(content)) {
                                    if ((key === 'text' || key === 'content' || key === 'message') && typeof content[key] === 'string') {
                                        if (this._isMarkdown(content[key])) {
                                            result.markdown.push({ content: content[key], path: `${path}.${key}` });
                                            continue; // Don't recurse further into this specific key if handled as markdown
                                        }
                                    }
                                    if (key === 'results' && typeof content[key] === 'object') {
                                        for (const modelName in content[key]) {
                                            const modelData = content[key][modelName];
                                            if (typeof modelData === 'object') {
                                                result.models.push({ ...modelData, provider: modelName.split('/')[0], model: modelName.split('/')[1] || modelName, _path: `${path}.${key}.${modelName}` });
                                            }
                                        }
                                        // Recurse *into* the results object to find potential nested stats/markdown/etc.
                                        // This was missing before.
                                        this._analyzeDeep(content[key], result, `${path}.${key}`);
                                        continue; // Already handled the 'results' structure
                                    }
                                }

                                // Always recurse into other properties
                                this._analyzeDeep(content[key], result, `${path}.${key}`);
                            }
                            return;
                        }
                    }, // End _analyzeDeep

                    // Extract embedded JSON from strings
                    _extractJsonFromString(str) {
                        if (typeof str !== 'string') return null;
                        const jsonRegexPatterns = [/\{(?:[^{}]|(?:\{(?:[^{}]|(?:\{[^{}]*\}))*\}))*\}/g, /\[(?:[^\[\]]|(?:\[(?:[^\[\]]|(?:\[[^\[\]]*\]))*\]))*\]/g];
                        for (const pattern of jsonRegexPatterns) {
                            const matches = str.match(pattern);
                            if (!matches) continue;
                            for (const match of matches) {
                                try { if (match.length < 10) continue; const parsed = JSON.parse(match); return parsed; } catch (e) { }
                            }
                        }
                        // Removed TextContent matching here, handled by _cleanTextContentWrappers
                        return null;
                    }, // End _extractJsonFromString

                    // Clean TextContent wrappers - Using Robust Version
                    _cleanTextContentWrappers(str) {
                        if (typeof str !== 'string') return str;
                        let contentToProcess = str.trim();
                        // 1. Strip surrounding brackets first
                        if (contentToProcess.startsWith('[') && contentToProcess.endsWith(']')) {
                            contentToProcess = contentToProcess.slice(1, -1).trim();
                        }
                        // 2. Apply the more robust TextContent regex
                        const pattern = /^TextContent\(\s*(?:type\s*=\s*(['"])text\1(?:,\s*)?)?text\s*=\s*(['"])((?:\\.|(?!\2).)*?)\2(?:,\s*annotations\s*=\s*(?:None|\[\]))?\s*\)$/;
                        const match = contentToProcess.match(pattern);

                        if (match && match[3]) {
                            try {
                                let unescaped = match[3]
                                    .replace(/\\"/g, '"')
                                    .replace(/\\'/g, "'")
                                    .replace(/\\n/g, '\n')
                                    .replace(/\\\\/g, '\\');
                                unescaped = unescaped.replace(/\\u([\da-fA-F]{4})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));
                                unescaped = unescaped.replace(/\\U([\da-fA-F]{8})/g, (_, hex) => String.fromCodePoint(parseInt(hex, 16)));
                                return unescaped;
                            } catch (e) {
                                console.error("Error unescaping TextContent text:", e);
                                return match[3]; // Return raw matched text on error
                            }
                        }
                        // If pattern didn't match, return the (potentially bracket-stripped) string
                        return contentToProcess;
                    }, // End _cleanTextContentWrappers

                    // Check if string contains markdown
                    _isMarkdown(str) {
                        if (typeof str !== 'string' || str.length <= 20) return false;
                        const markdownPatterns = [/^#{1,6}\s+.+$/m, /^[-*+]\s+.+$/m, /^>\s+.+$/m, /^```[\s\S]*?```$/m, /^(?:\d+\.)\s+.+$/m, /\*\*.*?\*\*/, /_.*?_/, /`.*?`/, /\[.*?\]\(.*?\)/, /!\[.*?\]\(.*?\)/, /\|[^|]+\|[^|]+\|/, /^---+$/m, /^===+$/m];
                        return markdownPatterns.some(pattern => pattern.test(str));
                    }, // End _isMarkdown

                    // Check if object is a model result
                    _isModelResultObject(obj) {
                        if (!obj || typeof obj !== 'object') return false;
                        const modelProperties = ['model', 'provider', 'text', 'tokens', 'cost', 'processing_time', 'success'];
                        return ('text' in obj || 'content' in obj) && modelProperties.filter(prop => prop in obj).length >= 2;
                    }, // End _isModelResultObject

                    // Check if an array contains model results
                    _isModelResultsArray(arr) {
                        return Array.isArray(arr) && arr.length > 0 && arr.some(item => this._isModelResultObject(item));
                    }, // End _isModelResultsArray

                    // Check if object contains statistics
                    _isStatsObject(obj) {
                        if (!obj || typeof obj !== 'object') return false;
                        const statsProps = ['tokens', 'cost', 'processing_time', 'total_requests', 'successful_requests', 'failed_requests', 'total_cost', 'average_processing_time'];
                        return statsProps.filter(prop => prop in obj).length >= 2;
                    }, // End _isStatsObject

                    // Determine the primary content type based on the analysis - Using IMPROVED VERSION
                    _determineContentType(result) {
                        // Give priority to complex structures detected directly in the first JSON block
                        if (result.json && result.json.length > 0) {
                            const jsonData = result.json[0].content; // Analyze the primary JSON data found

                            if (jsonData) { // Check if jsonData is valid
                                // Check for multi-provider results with aggregate stats (highest priority)
                                if (jsonData.results && typeof jsonData.results === 'object' &&
                                    Object.keys(jsonData.results).length > 0 &&
                                    jsonData.aggregate_stats && typeof jsonData.aggregate_stats === 'object') {
                                    return 'multi_provider';
                                }

                                // Standard model comparison (multiple models without aggregate stats)
                                if (jsonData.results && typeof jsonData.results === 'object' &&
                                    Object.keys(jsonData.results).length > 1) {
                                    return 'model_comparison';
                                }

                                // Check for providers status information
                                if (jsonData.providers && typeof jsonData.providers === 'object') {
                                    return 'providers_status';
                                }

                                // Check for models list
                                if (jsonData.models && typeof jsonData.models === 'object') {
                                    return 'models_list';
                                }

                                // Check if it's a single model result *within* the JSON
                                if ((jsonData.text || jsonData.content) && jsonData.model && jsonData.provider) {
                                    return 'single_model';
                                }

                                // Check for simple message object
                                if (jsonData.message && typeof jsonData.message === 'string' &&
                                    Object.keys(jsonData).length === 1) {
                                    return 'simple_message';
                                }
                            }
                        }

                        // Fallback to checking collected arrays/types
                        if (result.models.length > 1) {
                            return 'models'; // Multiple models implies comparison or list
                        }

                        if (result.models.length === 1) {
                            return 'single_model'; // Only one model found
                        }

                        if (result.markdown.length > 0) {
                            return 'markdown';
                        }

                        if (result.json.length > 0) {
                            return 'json'; // Generic JSON if no specific structure matched
                        }

                        if (result.rawText.length > 0) {
                            return 'text'; // Plain text
                        }

                        return 'unknown'; // Default if nothing substantial was found
                    } // End _determineContentType
                }, // End contentInspector


                // ===== VISUAL RENDERING ENGINE (REVISED & COMPLETE) =====
                visualRenderer: {

                // Highlight code with proper language detection
                highlight(code, forcedLanguage = null) {
                    // Use global hljs and DOMPurify directly
                    if (typeof hljs === 'undefined' || typeof DOMPurify === 'undefined') {
                        console.error("highlight error: hljs or DOMPurify not loaded");
                        return String(code || '');
                    }
                    if (!code) return DOMPurify.sanitize(String(code || ''));

                    const codeStr = typeof code === 'object' ? JSON.stringify(code, null, 2) : String(code);
                    let language = forcedLanguage;
                    if (!language) {
                        // Basic language detection
                        if (codeStr.trim().startsWith('{') || codeStr.trim().startsWith('[')) language = 'json';
                        else if (/^(function|const|let|var|import|class)\s/.test(codeStr)) language = 'javascript';
                        else if (/^(def|class|import|from|print)\s/.test(codeStr)) language = 'python';
                        else if (/^<\?xml/.test(codeStr.trim()) || /^<[a-zA-Z]/.test(codeStr.trim())) language = 'xml'; // Basic XML/HTML check
                        else language = 'plaintext';
                    }
                    try {
                        // Check if language is supported before highlighting
                        if (hljs.getLanguage(language)) {
                            return hljs.highlight(codeStr, { language, ignoreIllegals: true }).value;
                        } else {
                            console.warn(`Highlight.js language "${language}" not supported, using plaintext.`);
                            return hljs.highlight(codeStr, { language: 'plaintext', ignoreIllegals: true }).value;
                        }
                    } catch (e) {
                        console.error("Highlighting error:", e, "Lang:", language, "Code:", codeStr.substring(0, 50) + "...");
                        // Fallback: Sanitize and wrap in plain code tags
                        return DOMPurify.sanitize(codeStr);
                    }
                },

                // Render markdown content
                renderMarkdown(markdownInput) {
                    // Use global marked and DOMPurify directly
                    const inputType = typeof markdownInput;
                    const mdSample = String(markdownInput || '').substring(0, 70).replace(/\n/g, '\\n'); // Log with visible newlines

                    if (typeof marked === 'undefined' || typeof DOMPurify === 'undefined') {
                        console.error("[visualRenderer.renderMarkdown] Missing marked or DOMPurify!");
                        return `<div>${DOMPurify.sanitize(String(markdownInput || ''))}</div>`;
                    }

                    if (markdownInput === null || typeof markdownInput === 'undefined') {
                        return '';
                    }

                    try {
                        // Extract text content if it's a standard block structure
                        let contentToParse = markdownInput;
                        if (typeof markdownInput === 'object' && markdownInput !== null && markdownInput.type === 'text' && typeof markdownInput.text === 'string') {
                            contentToParse = markdownInput.text;
                        } else if (Array.isArray(markdownInput) && markdownInput.length === 1 && markdownInput[0]?.type === 'text' && typeof markdownInput[0].text === 'string') {
                            // Handle cases where a single text block is passed in an array
                            contentToParse = markdownInput[0].text;
                        }

                        // Ensure we are parsing a string
                        const stringContent = String(contentToParse);

                        const html = marked.parse(stringContent); // Use global marked

                        if (typeof html !== 'string') {
                            console.error("[visualRenderer.renderMarkdown] marked.parse returned non-string:", html);
                            return `<div>${DOMPurify.sanitize(stringContent)}</div>`; // Sanitize original string
                        }

                        const sanitizedHtml = DOMPurify.sanitize(html, { USE_PROFILES: { html: true } }); // Use global DOMPurify
                        return sanitizedHtml; // Return raw sanitized HTML
                    } catch (e) {
                        console.error("[visualRenderer.renderMarkdown] FAILED:", e, "Input was:", markdownInput);
                        return `<div class="text-error p-1">Markdown Render Error</div><div>${DOMPurify.sanitize(String(markdownInput))}</div>`; // Use global DOMPurify
                    }
                },

                // Helper function to render a code block with syntax highlighting
                renderCodeBlock(code, language, title = null) {
                    // Use global hljs and DOMPurify and global createCopyButton
                    if (typeof hljs === 'undefined' || typeof DOMPurify === 'undefined') {
                        console.error("renderCodeBlock error: hljs or DOMPurify not loaded");
                        return String(code || '');
                    }

                    try {
                        const codeString = (typeof code === 'object' ? JSON.stringify(code, null, 2) : String(code)) || '';
                        let highlightedCode = '';

                        // Check if language is supported before highlighting
                        if (language && hljs.getLanguage(language)) {
                            highlightedCode = hljs.highlight(codeString.trim(), { language, ignoreIllegals: true }).value;
                        } else {
                            // Fallback to plaintext if language is not supported or not provided
                            language = 'plaintext';
                            highlightedCode = hljs.highlight(codeString.trim(), { language: 'plaintext', ignoreIllegals: true }).value;
                        }

                        const titleHtml = title ? `<div class="tool-code-title">${DOMPurify.sanitize(title)}</div>` : '';
                        // Use global createCopyButton function
                        const copyButton = createCopyButton(codeString.trim()); // Defined globally

                        return `
                <div class="tool-code-container my-2">
                ${titleHtml}
                <div class="tool-code-block-wrapper relative group">
                <pre class="tool-code-block"><code class="language-${language} hljs">${highlightedCode}</code></pre>
                ${copyButton}
                </div>
                </div>`;
                    } catch (e) {
                        console.error("Code highlighting/rendering error:", e);
                        const safeCode = DOMPurify.sanitize(typeof code === 'object' ? JSON.stringify(code) : String(code));
                        const copyButtonFallback = createCopyButton(safeCode); // Use global function
                        return `<div class="tool-code-container my-2"><div class="tool-code-block-wrapper relative group"><pre class="tool-code-block"><code>${safeCode}</code></pre>${copyButtonFallback}</div></div>`;
                    }
                },

                // Helper method to render formatted text with parameter highlighting
                renderFormattedText(text) {
                    // Use global DOMPurify
                    if (typeof DOMPurify === 'undefined') {
                        console.error("renderFormattedText error: DOMPurify not loaded");
                        return String(text || '');
                    }
                    if (!text) return '';
                    text = text.trim();
                    const backtickParamRegex = /`([a-zA-Z_][a-zA-Z0-9_]*)`/g;
                    text = text.replace(backtickParamRegex, '<span class="font-mono text-info">$1</span>');
                    const paramRegex = /^\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*:\s*(.*)/gm;
                    text = text.replace(paramRegex, '<span class="font-mono text-info">$1</span>: $2');
                    const lines = text.split('\n');
                    const paragraphs = [];
                    let currentParagraph = [];
                    let inCodeBlock = false;
                    let codeContent = '';

                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];
                        const isIndented = line.startsWith('    ');
                        if (!inCodeBlock && isIndented) {
                            if (currentParagraph.length > 0) { paragraphs.push({ type: 'paragraph', content: currentParagraph.join('\n') }); currentParagraph = []; }
                            inCodeBlock = true; codeContent = line.substring(4);
                        } else if (inCodeBlock && !isIndented) {
                            if (codeContent.trim()) { paragraphs.push({ type: 'code', content: codeContent }); }
                            inCodeBlock = false; if (line.trim()) { currentParagraph.push(line); }
                        } else if (inCodeBlock) {
                            codeContent += '\n' + (isIndented ? line.substring(4) : line);
                        } else {
                            if (!line.trim() && currentParagraph.length > 0) {
                                paragraphs.push({ type: 'paragraph', content: currentParagraph.join('\n') }); currentParagraph = [];
                            } else if (line.trim()) { currentParagraph.push(line); }
                        }
                    }
                    if (inCodeBlock && codeContent.trim()) { paragraphs.push({ type: 'code', content: codeContent }); }
                    else if (currentParagraph.length > 0) { paragraphs.push({ type: 'paragraph', content: currentParagraph.join('\n') }); }
                    let html = '';
                    paragraphs.forEach(item => {
                        if (item.type === 'paragraph') {
                            html += `<p>${DOMPurify.sanitize(item.content)}</p>`; // Use global DOMPurify
                        } else if (item.type === 'code') {
                            let language = 'python';
                            if (item.content.includes('function') && (item.content.includes('{') || item.content.includes('=>'))) { language = 'javascript'; }
                            else if (item.content.includes('class ') || item.content.includes('def ')) { language = 'python'; }
                            // Call the corrected renderCodeBlock within this object
                            html += this.renderCodeBlock(item.content, language);
                        }
                    });
                    return html;
                },

                // --- Remaining visualRenderer methods (formatValue, createBadge, _isMarkdown, renderModelResult) ---
                formatValue(value, type) {
                    // This function was self-contained and likely correct already
                    if (value === undefined || value === null) return 'N/A';
                    try {
                        switch (type) {
                            case 'cost': const cost = parseFloat(value); if (isNaN(cost)) return 'N/A'; if (cost < 0.0001 && cost !== 0) return `${(cost * 1000000).toFixed(2)}Âµ$`; if (cost < 0.01 && cost !== 0) return `${(cost * 1000).toFixed(2)}m$`; return `$${cost.toFixed(6)}`;
                            case 'time': const time = parseFloat(value); if (isNaN(time)) return 'N/A'; if (time < 0.1) return `${(time * 1000).toFixed(0)}ms`; if (time < 60) return `${time.toFixed(2)}s`; const mins = Math.floor(time / 60); const secs = Math.round(time % 60); return `${mins}m ${secs}s`;
                            case 'number': const num = parseInt(value); return isNaN(num) ? 'N/A' : num.toLocaleString();
                            default: return String(value);
                        }
                    } catch (e) { console.error("Error formatting value:", value, type, e); return 'N/A'; }
                },

                createBadge(text, type = 'default') {
                    // Use global DOMPurify
                    if (typeof DOMPurify === 'undefined') {
                        console.error("createBadge error: DOMPurify not loaded");
                        return String(text || '');
                    }
                    const classMap = { 'success': 'tool-badge-success', 'error': 'tool-badge-error', 'warning': 'tool-badge-warning', 'info': 'tool-badge-info', 'default': 'tool-badge-default' };
                    const className = classMap[type] || classMap['default'];
                    return `<span class="tool-badge ${className}">${DOMPurify.sanitize(String(text))}</span>`;
                },

                _isMarkdown(str) {
                    // This function was self-contained and likely correct already
                    if (typeof str !== 'string' || str.length <= 20) return false;
                    // More robust checks, including lists, blockquotes, etc.
                    const markdownPatterns = [
                        /^#{1,6}\s+.+$/m,         // Headers
                        /^\s*[-*+]\s+.+$/m,       // Unordered lists
                        /^\s*\d+\.\s+.+$/m,      // Ordered lists
                        /^>\s*.+$/m,            // Blockquotes
                        /^```[\s\S]*?^```$/m,   // Fenced code blocks
                        /^(?:-{3,}|_{3,}|\*{3,})$/m, // Horizontal rules
                        /!\[.*?\]\(.*?\)/,     // Images
                        /\[.*?\]\(.*?\)/,       // Links
                        /`[^`]+`/,            // Inline code
                        /(?<!\\)\*\*[\s\S]+?\*\*(?!\\)|(?<!\\)__[\s\S]+?__(?!\\)/, // Bold
                        /(?<!\\)\*[\s\S]+?\*(?!\\)|(?<!\\)_[\s\S]+?_(?!\\)/,   // Italic
                        /\|.*\|.*\|/            // Basic table structure indicator
                    ];
                    return markdownPatterns.some(pattern => pattern.test(str));
                },

                renderModelResult(model, indexOrName = null) {
                    // Use global DOMPurify
                    if (typeof DOMPurify === 'undefined') {
                        console.error("renderModelResult error: DOMPurify not loaded");
                        return '<div class="text-error">Render Error</div>';
                    }
                    if (!model || typeof model !== 'object') {
                        return '<div class="text-error">Invalid model data</div>';
                    }

                    const { provider = 'unknown', model: modelName = 'unknown', text, content, message, tokens, cost, processing_time, success = true, error = null } = model;
                    const modelContent = text || content || message || (error ? `Error: ${error}` : '');
                    const badgeProvider = this.createBadge(DOMPurify.sanitize(provider), 'info');
                    const badgeStatus = success ? this.createBadge('Success', 'success') : this.createBadge(DOMPurify.sanitize(error || 'Error'), 'error');
                    // Use this.renderMarkdown to call corrected version
                    const renderedContent = this._isMarkdown(modelContent) ? this.renderMarkdown(modelContent) : `<pre class="tool-model-text whitespace-pre-wrap">${DOMPurify.sanitize(modelContent)}</pre>`;
                    const metricTokens = tokens ? `<div class="tool-metric"><i class="fas fa-hashtag tool-metric-icon"></i> <span class="tool-metric-value">${typeof tokens === 'object' ? this.formatValue(tokens.total || tokens.output || tokens.input || 0, 'number') : this.formatValue(tokens, 'number')}</span><span class="tool-metric-label">tokens</span></div>` : '';
                    const metricCost = cost !== undefined ? `<div class="tool-metric"><i class="fas fa-dollar-sign tool-metric-icon"></i> <span class="tool-metric-value">${this.formatValue(cost, 'cost')}</span><span class="tool-metric-label">cost</span></div>` : '';
                    const metricTime = processing_time !== undefined ? `<div class="tool-metric"><i class="fas fa-clock tool-metric-icon"></i> <span class="tool-metric-value">${this.formatValue(processing_time, 'time')}</span><span class="tool-metric-label">time</span></div>` : '';
                    const indexHtml = indexOrName !== null ? `<div class="tool-model-index">#${indexOrName}</div>` : '';

                    // Main card structure
                    return `
                <div class="tool-model-card" data-provider="${DOMPurify.sanitize(provider.toLowerCase())}">
                <div class="tool-model-header">
                <div class="tool-model-info">
                ${badgeProvider}
                <div class="tool-model-name">${DOMPurify.sanitize(modelName)}</div>
                ${indexHtml}
                </div>
                <div class="tool-model-status">
                ${badgeStatus}
                </div>
                </div>
                <div class="tool-model-content">
                ${renderedContent}
                </div>
                ${(metricTokens || metricCost || metricTime) ? `<div class="tool-model-metrics"> ${metricTokens} ${metricCost} ${metricTime} </div>` : ''}
                </div>`;
                } 


                }, // End visualRenderer
                renderUserProvidedToolResult(block, message) {
                    if (!this.uiSettings.showToolDataMessages) return '<!-- tool message hidden -->';
                    const inspector = this.contentInspector;
                    try {
                        const rawBlockContent = block?.content;
                        const payload = this._extractAndUnescapePayload(rawBlockContent);
                        if (payload === null || typeof payload === 'undefined') {
                            return '<div class="tool-message opacity-70 italic">[Empty Tool Result]</div>';
                        }
                        let contentHTML = '';
                        let isStringPayload = typeof payload === 'string';
                        if (isStringPayload) {
                            const markdownInputString = payload.replace(/\\n/g, '\n');
                            const markdownOutputHTML = this.visualRenderer.renderMarkdown(markdownInputString);
                            contentHTML = `<div class="tool-markdown prose prose-sm max-w-none prose-invert">${markdownOutputHTML}</div>`;
                        } else {
                            const analysisResult = inspector.inspectContent(payload);
                            switch (analysisResult.detectedType) {
                                case 'multi_provider':
                                    contentHTML = (payload && typeof payload === 'object' && payload.results) ? this.visualRenderer.renderMultiProviderResults(payload.results, payload.aggregate_stats) : this.visualRenderer.renderCodeBlock(payload, 'json', 'Multi-Provider Results');
                                    break;
                                case 'model_comparison':
                                    if (payload && typeof payload === 'object' && payload.results) {
                                        const modelsList = Object.entries(payload.results || {}).map(([name, data]) => {
                                            if (!data || typeof data !== 'object') return {
                                                provider: 'unknown',
                                                model: name
                                            };
                                            const nameParts = String(name).split('/');
                                            return {
                                                provider: data.provider || (nameParts.length > 1 ? nameParts[0] : name),
                                                model: data.model || (nameParts.length > 1 ? nameParts[1] : name),
                                                ...data
                                            };
                                        }).filter(Boolean);
                                        if (modelsList.length > 1) {
                                            contentHTML += this.visualRenderer.renderComparisonTable(modelsList, 'Model Comparison Results');
                                        }
                                        modelsList.forEach((model, index) => {
                                            contentHTML += this.visualRenderer.renderModelResult(model, index + 1);
                                        });
                                        if (payload.aggregate_stats && typeof payload.aggregate_stats === 'object') {
                                            contentHTML += this.visualRenderer.renderStatsDashboard(payload.aggregate_stats, 'Aggregate Performance');
                                        }
                                    } else {
                                        contentHTML = this.visualRenderer.renderCodeBlock(payload, 'json', 'Comparison Data');
                                    }
                                    break;
                                case 'single_model':
                                case 'models':
                                    const modelsToRender = analysisResult.models?.length > 0 ? analysisResult.models : (typeof payload === 'object' && ((payload.text && payload.model) || (payload.content && payload.model)) ? [payload] : []);
                                    modelsToRender.forEach((modelData, index) => {
                                        if (modelData) {
                                            contentHTML += this.visualRenderer.renderModelResult(modelData, modelsToRender.length > 1 ? index + 1 : null);
                                        }
                                    });
                                    if (analysisResult.stats) {
                                        contentHTML += this.visualRenderer.renderStatsDashboard(analysisResult.stats);
                                    }
                                    break;
                                case 'providers_status':
                                    contentHTML = (payload && typeof payload === 'object' && payload.providers) ? this.visualRenderer.renderProvidersStatus(payload.providers) : this.visualRenderer.renderCodeBlock(payload, 'json', 'Provider Status Data');
                                    break;
                                case 'models_list':
                                    contentHTML = (payload && typeof payload === 'object' && payload.models) ? this.visualRenderer.renderModelsList(payload.models) : this.visualRenderer.renderCodeBlock(payload, 'json', 'Models List Data');
                                    break;
                                case 'simple_message':
                                    contentHTML = (typeof payload === 'object' && payload.message) ? this.visualRenderer.renderSimpleMessage(payload) : this.visualRenderer.renderCodeBlock(payload, 'json', 'Message Data');
                                    break;
                                case 'json':
                                    contentHTML = (analysisResult.json?.length > 0) ? this.visualRenderer.renderCodeBlock(analysisResult.json[0].content, 'json', 'JSON Data') : this.visualRenderer.renderCodeBlock(payload, 'json', 'JSON Data');
                                    if (analysisResult.stats) contentHTML += this.visualRenderer.renderStatsDashboard(analysisResult.stats);
                                    break;
                                default:
                                    console.warn(`renderUserProvidedToolResult: Unknown/unhandled object type: ${analysisResult.detectedType}. Rendering as JSON.`);
                                    contentHTML += this.visualRenderer.renderCodeBlock(payload, 'json', 'Raw Data');
                                    break;
                            }
                        }
                        return `<div class="tool-result-container"><div class="tool-result-header"><div class="tool-result-title"><svg xmlns="http://www.w3.org/2000/svg" class="tool-result-icon" viewBox="0 0 24 24" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2.5 17a2.4 2.4 0 0 1 0-4.8V7a2.4 2.4 0 0 1 4.8 0v5.2a2.4 2.4 0 0 1 0 4.8z"/><path d="M16.5 17a2.4 2.4 0 0 1 0-4.8V7a2.4 2.4 0 0 1 4.8 0v5.2a2.4 2.4 0 0 1 0 4.8zM5 12h14"/></svg><span>Tool Data (User Provided)</span> ${message?.tool_name ? `<span class="text-xs opacity-70 ml-2">(${DOMPurify.sanitize(message.tool_name)})</span>` : ''}</div><div class="tool-result-actions">${createCopyButton(rawBlockContent || '', 'Copy Raw')}</div></div><div class="tool-result-content p-4 bg-gray-800 text-gray-200">${contentHTML}</div></div>`;
                    } catch (error) {
                        console.error("Tool result rendering failed:", error, block);
                        return `<div class="bg-error/10 p-4 rounded border border-error/30 text-error"><h3 class="font-medium mb-2">Tool Data Rendering Error</h3><p>Failed to render tool result: ${error.message}</p></div>`;
                    }
                },
                renderTextContent(content, message) {
                    const parsedJson = this.tryParseJson(content);
                    if (parsedJson !== null) {
                        if (message.content_type === 'tool_result') {
                            return this.renderToolResult(parsedJson, message);
                        }
                        return this.renderJsonWithToggle(parsedJson, message.id);
                    }
                    return this.visualRenderer.renderMarkdown(content);
                },
                renderArrayContent(content, message) {
                    if (Array.isArray(content) && content.length === 1 && content[0] && typeof content[0] === 'object' && content[0].type === 'text' && typeof content[0].text === 'string') {
                        console.log("Found single text block, rendering text directly");
                        return this.visualRenderer.renderMarkdown(content[0].text);
                    }
                    const hasMixedContent = content.some(item => item && typeof item === 'object' && (item.type === 'tool_use' || item.type === 'tool_result'));
                    if (hasMixedContent) {
                        return this.renderMixedMessageContent(message.content);
                    }
                    if (this.isProbablyTableData(content)) {
                        return this.renderTable(content);
                    }
                    console.log("Falling back to JSON rendering for array");
                    return this.renderJson(content);
                },
                renderObjectContent(content, message) {
                    if (message.role === 'user' && message.content_type === 'tool_result') {
                        return this.renderToolResult(content, message);
                    }
                    if (Object.prototype.toString.call(content) === '[object Object]') {
                        if (content.title || content.heading) {
                            return `<div class="prose prose-sm max-w-none"><h3 class="font-medium text-base">${DOMPurify.sanitize(content.title || content.heading)}</h3>${content.content ? this.visualRenderer.renderMarkdown(content.content) : ''}${content.sections ? this.renderSections(content.sections) : ''}</div>`;
                        }
                        return this.renderJsonWithToggle(content, message.id);
                    }
                    return this.renderJsonWithToggle(content, message.id);
                },
                renderSections(sections) {
                    if (!Array.isArray(sections)) return '';
                    let html = '<div class="space-y-3">';
                    sections.forEach(section => {
                        if (typeof section === 'string') {
                            html += `<p>${DOMPurify.sanitize(section)}</p>`;
                        } else if (section && typeof section === 'object') {
                            if (section.title || section.heading) {
                                html += `<h4 class="font-medium mt-2">${DOMPurify.sanitize(section.title || section.heading)}</h4>`;
                            }
                            if (section.content) {
                                html += this.visualRenderer.renderMarkdown(section.content);
                            } else if (Object.keys(section).length > 0) {
                                const content = Object.entries(section).filter(([k]) => k !== 'title' && k !== 'heading').map(([k, v]) => {
                                    if (typeof v === 'string') return v;
                                    if (typeof v === 'object') return JSON.stringify(v);
                                    return String(v);
                                }).join('\n\n');
                                html += this.visualRenderer.renderMarkdown(content);
                            }
                        }
                    });
                    html += '</div>';
                    return html;
                },
                renderToolResult(content, message) {
                    const isError = message.is_error || content?.error || false;
                    const statusClass = isError ? 'text-error' : 'text-success';
                    const statusIcon = isError ? 'fa-exclamation-circle' : 'fa-check-circle';
                    let resultContent = content?.error?.message || content?.error || content;
                    try {
                        const highlightedContent = hljs.highlight(resultContent, {
                            language: 'json',
                            ignoreIllegals: true
                        }).value;
                        return `<div class="not-prose my-1 space-y-2"><div class="flex items-center gap-2 ${statusClass} font-medium"><i class="fas ${statusIcon} fa-fw"></i><span>${isError ? 'Tool Error' : 'Tool Result'}: ${DOMPurify.sanitize(message.tool_name || '')}</span></div><div class="relative group bg-base-200 p-3 rounded-md"><pre><code class="language-json hljs whitespace-pre-wrap break-all">${highlightedContent}</code></pre>${createCopyButton(resultContent)}</div></div>`;
                    } catch (e) {
                        return `<div class="not-prose my-1 p-3 bg-base-200 rounded-md">${DOMPurify.sanitize(resultContent)}</div>`;
                    }
                },
                renderJson(data) {
                    try {
                        const jsonString = JSON.stringify(data, null, 2);
                        const highlightedJson = hljs.highlight(jsonString, {
                            language: 'json',
                            ignoreIllegals: true
                        }).value;
                        return `<div class="relative group my-1"><pre class="bg-base-200 rounded-md overflow-x-auto p-3"><code class="language-json hljs">${highlightedJson}</code></pre>${createCopyButton(jsonString)}</div>`;
                    } catch (e) {
                        console.error("JSON rendering error:", e);
                        return `<pre class="text-error p-2 bg-error/10 rounded-md">Error rendering JSON: ${e.message}</pre>`;
                    }
                },
                tryParseJson(str) {
                    if (typeof str !== 'string') return null;
                    const trimmed = str.trim();
                    if (!((trimmed.startsWith('{') && trimmed.endsWith('}')) || (trimmed.startsWith('[') && trimmed.endsWith(']')))) {
                        return null;
                    }
                    try {
                        return JSON.parse(trimmed);
                    } catch (e) {
                        return null;
                    }
                },
                isProbablyTableData(data) {
                    if (!Array.isArray(data) || data.length === 0) return false;
                    return data.every(item => typeof item === 'object' && item !== null && !Array.isArray(item));
                },
                renderStructuredData(data, level = 0) {
                    const maxDepth = 5;
                    if (level > maxDepth) return '<span class="italic opacity-50">[Max depth reached]</span>';
                    const indentStyle = `style="padding-left: ${level * 1}em;"`;
                    if (Array.isArray(data)) {
                        if (data.length === 0) return `<div ${indentStyle} class="opacity-50">[Empty Array]</div>`;
                        let listHtml = `<ul class="list-disc list-inside space-y-1 my-1 bg-base-200/50 rounded-md p-2" ${indentStyle}>`;
                        data.forEach(item => {
                            listHtml += `<li class="break-words">${this.renderStructuredData(item, level + 1)}</li>`;
                        });
                        listHtml += `</ul>`;
                        return listHtml;
                    } else if (typeof data === 'object' && data !== null) {
                        const keys = Object.keys(data);
                        if (keys.length === 0) return `<div ${indentStyle} class="opacity-50">[Empty Object]</div>`;
                        let objHtml = `<div class="space-y-1 my-1 ${level > 0 ? 'bg-base-200/30 rounded-md p-2' : ''}" ${indentStyle}>`;
                        keys.forEach(key => {
                            objHtml += `<div class="flex flex-wrap gap-x-2"><strong class="font-medium text-base-content/80">${DOMPurify.sanitize(key)}:</strong><div class="flex-1 min-w-0">${this.renderStructuredData(data[key], level + 1)}</div></div>`;
                        });
                        objHtml += `</div>`;
                        return objHtml;
                    } else {
                        if (data === null) return `<span ${indentStyle} class="italic opacity-60">null</span>`;
                        if (typeof data === 'boolean') return `<span ${indentStyle} class="font-mono ${data ? 'text-success' : 'text-error'}">${data}</span>`;
                        if (typeof data === 'number') return `<span ${indentStyle} class="font-mono text-accent">${data}</span>`;
                        if (typeof data === 'string') {
                            if (/[*#`[\]]/.test(data)) {
                                try {
                                    return `<span ${indentStyle}>${DOMPurify.sanitize(marked.parseInline(data || ''), { USE_PROFILES: { html: true } })}</span>`;
                                } catch (e) {
                                    return `<span ${indentStyle}>${DOMPurify.sanitize(data)}</span>`;
                                }
                            } else {
                                return `<span ${indentStyle}>${DOMPurify.sanitize(data)}</span>`;
                            }
                        }
                        return `<span ${indentStyle}>${DOMPurify.sanitize(String(data))}</span>`;
                    }
                },
                renderTable(data) {
                    if (!this.isProbablyTableData(data)) return '<!-- Not table data -->';
                    const uniqueHeaders = new Set();
                    data.forEach(row => {
                        Object.keys(row).forEach(key => uniqueHeaders.add(key));
                    });
                    const sortedHeaders = Array.from(uniqueHeaders).sort();
                    if (sortedHeaders.length === 0) return '<!-- Empty table -->';
                    let tableHtml = `<div class="overflow-x-auto my-2 bg-base-100/50 rounded-md shadow-sm border border-base-300/30"><table class="table table-zebra table-sm w-full"><thead><tr class="bg-base-300/20">`;
                    sortedHeaders.forEach(header => {
                        tableHtml += `<th class="sticky top-0 z-10 bg-inherit">${DOMPurify.sanitize(header)}</th>`;
                    });
                    tableHtml += `</tr></thead><tbody>`;
                    data.forEach(row => {
                        tableHtml += `<tr class="hover:bg-base-content/5">`;
                        sortedHeaders.forEach(header => {
                            const cellValue = row[header];
                            let cellContent = '';
                            if (cellValue === null || typeof cellValue === 'undefined') {
                                cellContent = '<span class="italic opacity-50">null</span>';
                            } else if (typeof cellValue === 'object') {
                                cellContent = `<pre class="text-xs !p-0 !bg-transparent !whitespace-pre-wrap">${DOMPurify.sanitize(JSON.stringify(cellValue))}</pre>`;
                            } else {
                                cellContent = DOMPurify.sanitize(String(cellValue));
                            }
                            tableHtml += `<td class="whitespace-normal break-words max-w-xs">${cellContent}</td>`;
                        });
                        tableHtml += `</tr>`;
                    });
                    tableHtml += `</tbody></table></div>`;
                    return tableHtml;
                },
                diagnoseBadRendering() {
                    const problematicMessage = this.currentConversation.find(msg => Array.isArray(msg.content) && msg.content.some(item => item && item.type === 'text'));
                    if (!problematicMessage) {
                        console.log("No text block message found");
                        return;
                    }
                    const textBlock = problematicMessage.content.find(item => item && item.type === 'text');
                    if (!textBlock || !textBlock.text) {
                        console.log("Text block not found or has no text");
                        return;
                    }
                    const hasObjectString = textBlock.text.includes('[object Object]');
                    console.log(`TEXT ALREADY CONTAINS [object Object]: ${hasObjectString}`);
                    console.log("RAW TEXT CONTENT BY LINE:");
                    textBlock.text.split('\n').forEach((line, i) => {
                        if (line.includes('[object Object]') || line.includes('{') || line.includes('}')) {
                            console.log(`LINE ${i} [SUSPICIOUS]: ${line}`);
                        } else {
                            console.log(`LINE ${i}: ${line}`);
                        }
                    });
                    console.log("CHECKING RENDERING PIPELINE...");
                    try {
                        const parsedContent = marked.parse(textBlock.text);
                        console.log(`MARKED PARSING CREATES [object Object]: ${parsedContent.includes('[object Object]')}`);
                    } catch (e) {
                        console.error("Error in marked.parse:", e);
                    }
                },
                renderToolResultContent(content) {
                    if (content === null || content === undefined) return '[No Content]';
                    if (typeof content === 'string') {
                        try {
                            if ((content.startsWith('{') && content.endsWith('}')) || (content.startsWith('[') && content.endsWith(']'))) {
                                return JSON.stringify(JSON.parse(content), null, 2);
                            }
                            return content;
                        } catch {
                            return content;
                        }
                    }
                    try {
                        return JSON.stringify(content, null, 2);
                    } catch (e) {
                        console.error("Error stringifying tool result content:", e);
                        return String(content);
                    }
                },
                messageRoleIcon(role, contentType = null) {
                    if (contentType === 'tool_result') return 'fas fa-wrench';
                    switch (role) {
                        case 'user':
                            return 'fas fa-user';
                        case 'assistant':
                            return 'fas fa-robot';
                        case 'system':
                            return 'fas fa-info-circle';
                        default:
                            return 'fas fa-question-circle';
                    }
                },
                messageRoleDisplayName(role, contentType = null) {
                    if (contentType === 'tool_result') return 'Tool Result';
                    switch (role) {
                        case 'user':
                            return 'User';
                        case 'assistant':
                            return 'Model';
                        case 'system':
                            return 'System';
                        default:
                            return role;
                    }
                }, // Changed 'Claude' to 'Model'
                formatTimestamp(isoString) {
                    if (!isoString) return '';
                    try {
                        const date = new Date(isoString);
                        if (isNaN(date.getTime())) return '';
                        return date.toLocaleTimeString([], {
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                    } catch {
                        return '';
                    }
                },                
                getFormattedModelName(modelId) {
                    const originalModelId = modelId; // Keep original for fallback on error
                    try {
                        if (!modelId || typeof modelId !== 'string' || modelId.trim() === '') {
                            return 'Select Model'; // Fallback display text
                        }

                        let name = modelId.trim();

                        // 1. Preserve the full original model ID for special case handling later
                        const fullModelId = name;

                        // 2. Remove known provider prefixes (case-insensitive)
                        const prefixesToRemove = ['openai/', 'anthropic/', 'google/', 'gemini/', 'grok/', 'deepseek/', 'mistralai/', 'groq/', 'cerebras/', 'openrouter/'];
                        for (const prefix of prefixesToRemove) {
                            if (name.toLowerCase().startsWith(prefix)) {
                                name = name.substring(prefix.length);
                                break; // Assume only one prefix
                            }
                        }

                        // 3. Capture suffixes and dates before removing them for special handling
                        const dateSuffixMatch = name.match(/[-_](\d{8})$/);
                        const dateSuffix = dateSuffixMatch ? dateSuffixMatch[1] : null;
                        
                        // Special handling for experimental versions that should be preserved
                        const expVersionMatch = name.match(/(exp[-_]\d{2}[-_]\d{2})$/i);
                        const expVersion = expVersionMatch ? expVersionMatch[1] : null;
                        
                        // 4. Remove common suffixes but with better pattern matching to avoid removing important parts
                        name = name.replace(/[-_](?:(\d{8})|(v\d+(\.\d+)?)|(latest)|(preview)|(alpha)|(beta)|(instruct)|(chat)|(versatile)|(scout)|(16e))$/i, '');
                        
                        // KEEP certain meaningful suffixes like "reasoner" for Deepseek models
                        const preserveSuffixes = ["reasoner", "thinking", "chat"];
                        const hasPreserveSuffix = preserveSuffixes.some(suffix => 
                            name.toLowerCase().includes(suffix)
                        );

                        // 5. Replace separators with spaces, but preserve decimals in version numbers
                        name = name.replace(/(?<!\.)-|(?<!\.|\d)_(?!\d)/g, ' ');

                        // 6. Special handling for specific model families BEFORE general formatting
                        
                        // Handle Claude models - preserve decimal point in version
                        if (name.toLowerCase().includes('claude')) {
                            // Fix the Claude 3.7 becoming "Claude 3 7" issue
                            name = name.replace(/claude[\s-_]*(\d+)[\s-_]*(\d+)/i, 'Claude $1.$2');
                        }
                        
                        // Handle DeepSeek models - make sure the suffixes are preserved
                        if (name.toLowerCase().includes('deepseek')) {
                            // If it ends with "chat", preserve it
                            if (name.toLowerCase().endsWith('chat')) {
                                name = 'Deepseek Chat';
                            } 
                            // If it contains "reasoner", make it explicit
                            else if (name.toLowerCase().includes('reasoner')) {
                                name = 'Deepseek Reasoner';
                            }
                            // Generic Deepseek model
                            else {
                                name = 'Deepseek';
                            }
                        }
                        
                        // Handle Gemini models - ensure proper spacing and version formatting
                        if (name.toLowerCase().includes('gemini')) {
                            // Preserve "thinking" in Gemini models
                            if (name.toLowerCase().includes('thinking')) {
                                // Check if we have the exp version to add
                                if (expVersion) {
                                    name = name.replace(/gemini[\s-_]*(\d+\.\d+)[\s-_]*flash[\s-_]*thinking/i, 
                                                    'Gemini $1 Flash Thinking ' + expVersion.replace(/-/g, ' ').toUpperCase());
                                } else {
                                    name = name.replace(/gemini[\s-_]*(\d+\.\d+)[\s-_]*flash[\s-_]*thinking/i, 
                                                    'Gemini $1 Flash Thinking');
                                }
                            }
                            // Handle Gemini Pro models with experimental versions
                            else if (name.toLowerCase().includes('pro') && expVersion) {
                                name = name.replace(/gemini[\s-_]*(\d+\.\d+)[\s-_]*pro/i, 
                                                'Gemini $1 Pro ' + expVersion.replace(/-/g, ' ').toUpperCase());
                            }
                            // Standard Gemini model with version number
                            else {
                                name = name.replace(/gemini[\s-_]*(\d+\.\d+)/i, 'Gemini $1');
                                
                                // Handle Flash suffix
                                if (name.toLowerCase().includes('flash')) {
                                    name = name.replace(/(gemini\s\d+\.\d+)[\s-_]*flash[\s-_]*lite/i, '$1 Flash Lite');
                                    name = name.replace(/(gemini\s\d+\.\d+)[\s-_]*flash/i, '$1 Flash');
                                }
                            }
                        }
                        
                        // Handle GPT models
                        if (name.toLowerCase().includes('gpt')) {
                            // O1/O3 models
                            if (name.match(/^o[13]/i)) {
                                name = name.replace(/^o(\d+)[-_]?(.+)/i, 'O$1 $2');
                                name = name.replace(/o(\d+)[\s-_]*(.+)/i, 'O$1 $2');
                                // Capitalize first letter of each word after O1/O3
                                name = name.replace(/\b\w+\b/g, (word) => {
                                    return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
                                });
                            } 
                            // Standard GPT models
                            else {
                                name = name.replace(/gpt[\s-_]*(\d+)\.(\d+)/i, 'GPT-$1.$2');
                                name = name.replace(/gpt[\s-_]*(\d+)o/i, 'GPT-$1O');
                                name = name.replace(/gpt[\s-_]*(\d+)/i, 'GPT-$1');
                                
                                // Handle Mini/Nano suffixes
                                name = name.replace(/(gpt-\d+\.?\d*o?)[\s-_]*mini/i, '$1 Mini');
                                name = name.replace(/(gpt-\d+\.?\d*)[\s-_]*nano/i, '$1 Nano');
                            }
                        }
                        
                        // Handle Grok models
                        if (name.toLowerCase().includes('grok')) {
                            name = name.replace(/grok[\s-_]*(\d+)/i, 'Grok $1');
                            
                            // Handle Mini/Fast suffixes
                            if (name.toLowerCase().includes('mini') && name.toLowerCase().includes('fast')) {
                                name = name.replace(/(grok\s\d+)[\s-_]*mini[\s-_]*fast/i, '$1 Mini Fast');
                            } else if (name.toLowerCase().includes('mini')) {
                                name = name.replace(/(grok\s\d+)[\s-_]*mini/i, '$1 Mini');
                            } else if (name.toLowerCase().includes('fast')) {
                                name = name.replace(/(grok\s\d+)[\s-_]*fast/i, '$1 Fast');
                            }
                        }
                        
                        // Handle Mistral models
                        if (name.toLowerCase().includes('mistral')) {
                            if (name.toLowerCase().includes('nemo')) {
                                name = 'Mistral Nemo';
                            } else if (name.toLowerCase().includes('large')) {
                                name = 'Mistral Large';
                            } else {
                                name = name.replace(/mistral[\s-_]*(\w+)/i, 'Mistral $1');
                            }
                        }
                        
                        // 7. If we haven't handled this as a special case, do generic formatting
                        if (name === fullModelId || (
                            !name.includes('Claude') && 
                            !name.includes('Deepseek') && 
                            !name.includes('Gemini') && 
                            !name.includes('GPT') && 
                            !name.includes('Grok') && 
                            !name.includes('Mistral') &&
                            !name.includes('O1') &&
                            !name.includes('O3'))) {
                            
                            // Split and remove empty parts
                            const parts = name.split(' ').filter(p => p);
                            
                            const formattedParts = parts.map(part => {
                                const lowerPart = part.toLowerCase();
                                
                                // Keep numbers/sizes like 70b, 1.5, 8x7b
                                if (/^\d+(\.\d+)?(x\d+)?[bmk]?$/.test(lowerPart)) {
                                    return part; // Return original to keep 'b' etc.
                                }
                                
                                // Default: Capitalize first letter
                                // Avoid capitalizing already fully uppercase parts
                                if (part === part.toUpperCase() && part.length > 1) {
                                    return part;
                                }
                                
                                return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
                            });
                            
                            name = formattedParts.join(' ');
                        }
                        
                        // 8. Final cleanup and polish
                        // Remove any double spaces
                        name = name.replace(/\s{2,}/g, ' ').trim();
                        
                        // 9. Truncate if necessary
                        const maxLength = 35;
                        return name.length > maxLength ? name.substring(0, maxLength - 3) + '...' : name;
                        
                    } catch (e) {
                        console.error(`Error in getFormattedModelName for ID: '${originalModelId}'`, e);
                        return originalModelId; // Return the original model ID so at least something is displayed
                    }
                },
                currentStatusIcon() {
                    const msg = this.currentStatusMessage?.toLowerCase() || "";
                    if (msg.includes("error") || msg.includes("fail")) return "fas fa-exclamation-circle text-error";
                    if (msg.includes("success") || msg.includes("complete")) return "fas fa-check-circle text-success";
                    if (msg.includes("cache")) return "fas fa-database text-info";
                    if (msg.includes("tool") || msg.includes("execut")) return "fas fa-terminal text-accent";
                    if (msg.includes("stop")) return "fas fa-stop-circle text-warning";
                    return msg ? "fas fa-spinner fa-spin text-info" : "";
                },
                scrollToBottom(force = false) {
                    this.$nextTick(() => {
                        if (this.$refs.chatbox) {
                            const isScrolledToBottom = this.$refs.chatbox.scrollHeight - this.$refs.chatbox.scrollTop <= this.$refs.chatbox.clientHeight + 150;
                            if (force || isScrolledToBottom) {
                                this.$refs.endofchat?.scrollIntoView({
                                    behavior: 'smooth',
                                    block: 'end'
                                });
                            }
                        }
                    });
                },
                adjustTextareaHeight(el) {
                    if (!el) return;
                    const maxHeight = 200;
                    el.style.height = 'auto';
                    el.style.height = Math.min(el.scrollHeight, maxHeight) + 'px';
                },
                getProviderIcon(modelName) {
                    try {
                    if (!modelName) return 'fa-question-circle';
                    const lowerModel = modelName.toLowerCase();
                    // Order matters slightly - check for full provider names first
                    if (lowerModel.includes('anthropic') || lowerModel.startsWith('claude-')) return 'fab fa-autoprefixer text-purple-500'; // Anthropic
                    if (lowerModel.includes('openai') || lowerModel.startsWith('gpt-') || lowerModel.startsWith('o1-') || lowerModel.startsWith('o3-')) return 'fas fa-brain text-green-500'; // OpenAI
                    if (lowerModel.includes('google') || lowerModel.startsWith('gemini-')) return 'fab fa-google text-blue-500'; // Gemini
                    if (lowerModel.includes('grok')) return 'fa-bolt text-blue-400'; // Grok
                    if (lowerModel.includes('deepseek')) return 'fa-water text-cyan-600'; // DeepSeek
                    if (lowerModel.includes('mistral')) return 'fa-wind text-indigo-400'; // Mistral
                    if (lowerModel.includes('groq')) return 'fa-rocket text-red-500'; // Groq
                    if (lowerModel.includes('cerebras')) return 'fa-microchip text-gray-500'; // Cerebras
                    if (lowerModel.includes('openrouter')) return 'fa-route text-purple-500'; // OpenRouter
                    return 'fa-robot'; // Default
                    } catch (e) {
                        console.error(`!!! Error in getProviderIcon for modelName: '${modelName}'`, e); // Log the specific ID
                        return 'fa-question-circle';
                    }
                },
                renderDocstring(docstring) { // Implementation for docstring rendering
                    if (!docstring) return '<div class="text-base-content/50 italic">No documentation available</div>';
                    const sectionHeaders = ['Description:', 'Args:', 'Arguments:', 'Parameters:', 'Returns:', 'Raises:', 'Exceptions:', 'Example:', 'Examples:', 'Notes:', 'References:', 'See Also:'];
                    const hasSections = sectionHeaders.some(header => docstring.includes('\n' + header) || docstring.startsWith(header));
                    if (!hasSections) {
                        return this.renderSections([{
                            title: 'Description',
                            content: docstring
                        }]);
                    }
                    const sections = [];
                    let currentSection = {
                        title: 'Description',
                        content: ''
                    };
                    const lines = docstring.split('\n');
                    let inSectionHeader = false;
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];
                        const isHeader = sectionHeaders.some(header => line.trim() === header || line.trim().toLowerCase() === header.toLowerCase());
                        let headerText = '';
                        if (isHeader) {
                            headerText = line.trim().replace(/:$/, '');
                            inSectionHeader = true;
                        } else if (inSectionHeader && (line.trim() === '' || line.startsWith('    '))) {
                            continue;
                        } else {
                            inSectionHeader = false;
                            const headerMatch = line.match(/^([A-Za-z][A-Za-z\s_]+):$/);
                            if (headerMatch && sectionHeaders.some(h => h.toLowerCase() === (headerMatch[1].toLowerCase() + ':'))) {
                                if (currentSection.content.trim()) {
                                    sections.push({
                                        ...currentSection
                                    });
                                }
                                currentSection = {
                                    title: headerMatch[1],
                                    content: ''
                                };
                                continue;
                            }
                            currentSection.content += line + '\n';
                        }
                        if (isHeader) {
                            if (currentSection.content.trim()) {
                                sections.push({
                                    ...currentSection
                                });
                            }
                            currentSection = {
                                title: headerText.replace(/:$/, ''),
                                content: ''
                            };
                        }
                    }
                    if (currentSection.content.trim()) {
                        sections.push(currentSection);
                    }
                    return this.renderSections(sections);
                },
                renderBranchNode(nodeId, level) {
                    const node = this.getNodeById(nodeId);
                    if (!node || typeof node.id === 'undefined') {
                        console.error(`Node not found: ${nodeId}`);
                        return '';
                    }
                    const template = document.getElementById('branch-node-template')?.innerHTML;
                    if (!template) {
                        console.error("Branch template missing!");
                        return '';
                    }
                    const nodeName = (node.name || 'Unnamed').replace(/"/g, '"');
                    const children = node.childrenIds || [];
                    const childrenJson = JSON.stringify(children).replace(/"/g, '"');
                    const hasChildren = children.length > 0;
                    let rendered = template.replace('<li ', `<li data-nodeid="${node.id}" data-nodename="${nodeName}" data-level="${level}" data-haschildren="${hasChildren}" data-children="${childrenJson}" `);
                    return rendered;
                },
                async executeToolDirectly() {
                    if (!this.selectedTool) return; let params;
                    try { params = JSON.parse(this.directToolParams || '{}'); this.directToolError = null; }
                    catch (e) { this.directToolError = `Invalid JSON parameters: ${e.message}`; this.directToolResult = null; this.$nextTick(() => this.initHighlighting(document.getElementById('toolDetailsModal'))); return; }
                    this.isLoadingDirectTool = true; this.directToolResult = null; this.directToolError = null;
                    try {
                        const payload = { tool_name: this.selectedTool.name, server_name: this.selectedTool.server_name, params: params };
                        const result = await this.apiFetch('/tool/execute', { method: 'POST', body: JSON.stringify(payload) });
                        if (result && (result.is_error || result.error || (result.status && result.status !== 'success' && result.status !== 200))) { this.directToolError = `Tool execution failed: ${JSON.stringify(result.content || result.error || result.detail || result)}`; this.directToolResult = null; }
                        else {
                            this.directToolResult = result;
                            this.addNotification(`Tool '${this.selectedTool.name}' executed successfully.`, 'success', 2000);
                            this.addToRecentTools(this.selectedTool); // Add to recents on success
                        }
                    } catch (e) { this.directToolError = `Execution request failed: ${e.message}`; this.directToolResult = null; this.addNotification(`Failed to execute tool '${this.selectedTool.name}'.`, 'error'); }
                    finally { this.isLoadingDirectTool = false; this.$nextTick(() => this.initHighlighting(document.getElementById('toolDetailsModal'))); }
                },
                async applyPrompt(promptName) { // Make it async
                    if (!promptName) return;
                    const selectedPrompt = this.prompts.find(p => p.name === promptName);
                    if (!selectedPrompt) { console.error(`Prompt ${promptName} not found.`); this.addNotification(`Prompt '${promptName}' not found.`, 'error'); return; }

                    // Optional: Ask for confirmation?
                    // if (!confirm(`Apply system prompt '${selectedPrompt.shortName}' to the current conversation? This modifies the history.`)) return;

                    console.log(`Applying prompt '${promptName}' via API...`);
                    this.isLoading = true; // Indicate activity

                    try {
                        // Call the new API endpoint
                        const result = await this.apiFetch('/conversation/apply_prompt', {
                            method: 'POST',
                            body: JSON.stringify({ prompt_name: promptName }) // Send the full name
                        });
                        this.addNotification(result.message || `Prompt '${selectedPrompt.shortName}' applied successfully.`, 'success');
                        // Optionally, refresh the conversation view immediately, though the next query will use it
                        // await this.fetchConversation();
                    } catch (e) {
                        this.addNotification(`Failed to apply prompt '${selectedPrompt.shortName}': ${e.message}`, 'error');
                    } finally {
                        this.isLoading = false;
                    }
                },

                
                // --- CHAT ---
                sendMessage() {
                    if (!this.userInput.trim() || !this.wsConnected) { if (!this.wsConnected) this.addNotification('Chat not connected. Cannot send.', 'error'); else if (!this.userInput.trim()) this.addNotification('Cannot send an empty message.', 'warning'); return; }
                    if (this.isSendingMessage && !this.config.enableStreaming) { this.addNotification('Please wait for the previous response (streaming disabled).', 'warning'); return; }
                    const text = this.userInput; this.userInput = ''; this.adjustTextareaHeight(this.$refs.inputarea);
                    this.addMessageToConversation('user', text);
                    this.isSendingMessage = true; 
                    this.currentStatusMessage = `Sending to ${this.getFormattedModelName(this.currentModel)}...`;
                    this.currentAssistantMessageId = null;
                    const messagePayload = { type: 'query', payload: text, model: this.currentModel, config: { max_tokens: this.config.maxTokens, temperature: this.config.temperature, stream: this.config.enableStreaming } };
                    this.stopController = new AbortController();
                    this.sendWebSocketMessage(messagePayload);
                },
                shouldHideToolMessage(message) {
                    // Always show if the toggle is ON
                    if (this.uiSettings.showToolDataMessages) {
                        return false;
                    }

                    // If toggle is OFF, check conditions to HIDE:

                    // 1. Check explicit content_type
                    if (message.content_type === 'tool_result' || message.content_type === 'tool_use') {
                        // console.log(`Hiding message ${message.id} due to content_type: ${message.content_type}`);
                        return true;
                    }

                    // 2. Check if message.content is an array containing ONLY tool-related blocks
                    if (Array.isArray(message.content) && message.content.length > 0) {
                        const containsOnlyToolBlocks = message.content.every(
                            block => block && (block.type === 'tool_use' || block.type === 'tool_result')
                        );
                        if (containsOnlyToolBlocks) {
                            // console.log(`Hiding message ${message.id} because it contains ONLY tool blocks.`);
                            return true;
                        }

                        // 3. Check for the specific user message structure containing ONLY a tool_result block
                        const isUserToolResult = message.role === 'user' &&
                            message.content.length === 1 &&
                            message.content[0]?.type === 'tool_result';
                        if (isUserToolResult) {
                            // console.log(`Hiding message ${message.id} because it's a user tool result message.`);
                            return true;
                        }
                    }

                    // If none of the above conditions to hide were met, DO NOT HIDE the message
                    return false;
                },
                async abortQuery() {
                    console.log("UI requesting query abort...");
                    if (!this.isSendingMessage) {
                        console.warn("abortQuery called but no message is being sent.");
                        return;
                    }

                    this.addNotification("Attempting to abort query...", "warning", 2000);

                    try {
                        // Call the backend API endpoint to signal cancellation
                        const result = await this.apiFetch('/query/abort', { method: 'POST' });
                        console.log("Abort API response:", result);
                        // Even if the API call succeeds, the stream might take a moment to stop.
                        // The primary state change (isSendingMessage=false) should happen
                        // when the WebSocket receives query_complete or closes.
                        // However, we can update the status message immediately for feedback.
                        this.currentStatusMessage = "Query abort requested...";
                        this.addNotification(result.message || "Abort signal sent.", "info");

                        // Optionally, force UI state update sooner rather than waiting for WS close/complete
                        // Uncomment the following lines if immediate UI feedback is desired,
                        // but be aware the backend might still be processing briefly.
                        // this.isSendingMessage = false;
                        // this.isLoading = false;
                        // this.currentAssistantMessageId = null; // Reset stream tracking
                        // if (this.currentConversation.length > 0) {
                        //     const lastMsg = this.currentConversation[this.currentConversation.length - 1];
                        //     if (lastMsg.role === 'assistant') {
                        //         lastMsg.content += "\n\n[Aborted by User]"; // Append to partial message
                        //         this.currentConversation = [...this.currentConversation]; // Trigger reactivity
                        //     }
                        // }

                    } catch (error) {
                        // Error notification is handled by apiFetch
                        console.error("Failed to send abort signal:", error);
                        // Don't necessarily change isSendingMessage here, as the query might still be running
                        this.addNotification(`Failed to send abort signal: ${error.message || 'Unknown error'}`, 'error');
                    }
                    // Note: No 'finally' block setting isSendingMessage = false here.
                    // Rely on WebSocket 'query_complete', 'stream_end', or 'onclose' event
                    // to definitively reset the sending state.
                },
                // --- End new function ---

                stopGeneration() { // Keep this one for the ESC key functionality for now
                    if (this.isSendingMessage) {
                        console.log("stopGeneration (likely ESC key) triggered, calling abortQuery...");
                        this.abortQuery(); // Delegate to the new function
                    }
                },
                toggleDataView(messageId) {
                    if (!messageId) return;

                    // Initialize the display mode if it doesn't exist
                    if (typeof this[`${messageId}_displayMode`] === 'undefined') {
                        this[`${messageId}_displayMode`] = 'raw';
                    }

                    // Toggle between raw and structured
                    this[`${messageId}_displayMode`] = this[`${messageId}_displayMode`] === 'raw'
                        ? 'structured'
                        : 'raw';

                    // Re-initialize highlighting
                    this.$nextTick(() => {
                        this.initHighlighting(this.$refs.chatbox);
                        this.initTippy();
                    });
                },
                addMessageToConversation(role, content, metadata = {}) {
                    // *** No filter needed here anymore ***

                    const tempId = `${role}_${Date.now()}_${Math.random().toString(16).slice(2)}`;

                    const newMessage = {
                        role: role,
                        content: content,
                        id: metadata.id || tempId,
                        timestamp: metadata.timestamp || new Date().toISOString(),
                        model: metadata.model || (role === 'assistant' ? this.currentModelShort : null),
                        content_type: metadata.content_type || null,
                        tool_name: metadata.tool_name,
                        is_error: metadata.is_error,
                        // Remove internal flags like _applyProse if they still exist
                        ...metadata
                    };

                    // Add/Update message in conversation array
                    const existingIndex = this.currentConversation.findIndex(m => m.id === newMessage.id);
                    if (existingIndex === -1) {
                        this.currentConversation.push(newMessage);
                    } else {
                        this.currentConversation[existingIndex] = { ...this.currentConversation[existingIndex], ...newMessage };
                        this.currentConversation = [...this.currentConversation];
                    }

                    // --- MODIFY THIS PART ---
                    this.$nextTick(() => {
                        setTimeout(() => {
                            const messageElement = document.getElementById(`message-${newMessage.id}`);

                            // --- ADD THIS CHECK ---
                            if (messageElement) {
                                const bubbleElement = messageElement.querySelector('.chat-bubble');
                                if (bubbleElement) {
                                    // console.log("Running contrast fix for newly added/updated bubble:", bubbleElement); // Keep for debug if needed
                                    if (this.contrastOptimizer) { // Add safety check
                                        this.contrastOptimizer.fixContrastRecursively(bubbleElement, bubbleElement);
                                    }
                                } else {
                                    // This specific warning is less likely if messageElement exists, but safe to keep
                                    console.warn("Could not find BUBBLE element inside message element for contrast fix:", newMessage.id);
                                }
                            } else {
                                // Element was removed before timeout - log gracefully, don't error
                                console.log(`Message element ${newMessage.id} not found for contrast fix (likely removed before check).`);
                            }
                            // --- END ADDED CHECK ---

                        }, 150); // 150ms delay
                    });
                    // --- END MODIFICATION ---

                    this.scrollToBottom();

                }, // End addMessageToConversation

                // --- UTILITY / RENDERING HELPERS ---

                // Debugging version of renderMessageContent that logs the full structure
                debugRenderMessage(message) {
                    console.log('====== BEGIN FULL MESSAGE DEBUG ======');
                    console.log(`Message role: ${message.role}`);
                    console.log(`Message content type: ${typeof message.content}`);
                    console.log(`Is Array: ${Array.isArray(message.content)}`);
                    console.log('Full content structure:');
                    console.log(safeDebugStringify(message.content));
                    if (Array.isArray(message.content)) {
                        console.log('Array items:');
                        message.content.forEach((item, index) => {
                            console.log(`\n=== Item ${index} ===`);
                            console.log(`Type: ${typeof item}`);
                            console.log(`Content: ${safeDebugStringify(item)}`);
                        });
                    }
                    console.log('====== END FULL MESSAGE DEBUG ======');
                    const rendered = this.renderMessageContent(message);
                    console.log('debugRenderMessage output type:', typeof rendered); // Optional: keep for deeper debugging
                    console.log('debugRenderMessage output:', rendered); // Optional: keep for deeper debugging
                    return rendered;
                },
                showToolDetails(tool) {
                    this.selectedTool = tool;
                    this.directToolParams = '{}';
                    this.directToolResult = null;
                    this.directToolError = null;
                    this.isLoadingDirectTool = false;
                    this.showToolDetailsModal = true;

                    // Initialize the highlighting on next tick to ensure content is rendered
                    this.$nextTick(() => {
                        // Add a small delay to make sure the content is fully rendered
                        setTimeout(() => {
                            this.initHighlighting(document.getElementById('toolDetailsModal'));
                        }, 100);
                    });
                },
                getNodeById(id) {
                    if (!id) return null;
                    const nodes = Alpine.store('conversation')?.conversationNodes || [];
                    if (!Array.isArray(nodes) || nodes.length === 0) {
                        return null;
                    }
                    return nodes.find(n => n.id === id) || null;
                },
                async checkoutBranch(nodeId) {
                    if (typeof nodeId === 'object' && nodeId !== null && nodeId.id) {
                        nodeId = nodeId.id;
                    }
                    if (!nodeId || typeof nodeId !== 'string' || nodeId === this.currentNodeId) return;
                    console.log(`Executing checkoutBranch for Node ID: ${nodeId}`);
                    this.isLoading = true;
                    try {
                        await this.apiFetch('/conversation/checkout', {
                            method: 'POST',
                            body: JSON.stringify({
                                node_id: nodeId
                            })
                        });
                        const node = this.getNodeById(nodeId);
                        this.addNotification(`Switched to branch: ${node?.name || nodeId.slice(0, 8)}...`, 'success');
                        await this.fetchConversation();
                        this.loadConversationTags();
                    } catch (e) {
                        this.addNotification(`Failed to checkout branch ${nodeId.slice(0, 8)}...: ${e.message}`, 'error');
                        console.error(`Error in checkoutBranch API call for ${nodeId}:`, e);
                    } finally {
                        this.isLoading = false;
                    }
                },
                async forkConversation() {
                    if (this.currentConversation.length === 0 && this.currentNodeId === 'root') {
                        this.addNotification("Cannot fork an empty root conversation.", "warning");
                        return;
                    }
                    const forkName = prompt("Enter name for new branch (optional):", `Fork of ${this.getNodeById(this.currentNodeId)?.name || this.currentNodeId.slice(-6)}`);
                    if (forkName === null) return;
                    this.isLoading = true;
                    try {
                        const result = await this.apiFetch('/conversation/fork', {
                            method: 'POST',
                            body: JSON.stringify({
                                name: forkName
                            })
                        });
                        this.addNotification(`Fork created: ${result.newNodeName || result.newNodeId.slice(-6)}`, 'success');
                        await this.fetchConversation();
                    } catch (e) {
                        this.addNotification('Failed to fork conversation.', 'error');
                    } finally {
                        this.isLoading = false;
                    }
                },
                async optimizeConversation() {
                    if (this.currentConversation.length < 2) {
                        this.addNotification("Not enough messages to optimize.", "warning");
                        return;
                    }
                    if (!confirm('This will attempt to summarize and optimize the current conversation context, potentially replacing the history in this branch. Proceed?')) return;
                    this.isLoading = true;
                    try {
                        const result = await this.apiFetch('/conversation/optimize', {
                            method: 'POST'
                        });
                        if (result && typeof result.initialTokens !== 'undefined' && typeof result.finalTokens !== 'undefined') {
                            this.addNotification(`Context optimized: ${result.initialTokens} -> ${result.finalTokens} tokens`, 'success');
                        } else {
                            this.addNotification('Context optimization requested.', 'info');
                        }
                        await this.fetchConversation();
                    } catch (e) {
                        this.addNotification('Failed to optimize context.', 'error');
                    } finally {
                        this.isLoading = false;
                    }
                },
                async clearConversation() {
                    if (confirm('Are you sure you want to clear all messages in the current branch and reset it to an empty state based on its parent (or root)?')) {
                        this.isLoading = true;
                        try {
                            await this.apiFetch('/conversation/clear', {
                                method: 'POST'
                            });
                            this.addNotification(`Conversation branch cleared.`, 'warning');
                            await this.fetchConversation();
                        } catch (e) {
                            this.addNotification('Failed to clear conversation.', 'error');
                        } finally {
                            this.isLoading = false;
                        }
                    }
                },
                async importConversationAPI(file) {
                    if (!file) return;
                    if (!file.type.match('application/json')) {
                        this.addNotification('Import failed: Please select a valid JSON file.', 'error');
                        return;
                    }
                    const fileInput = this.$el.querySelector('input[type="file"][accept=".json"]');
                    console.log('Importing conversation via API...', file.name);
                    this.isLoadingImport = true;
                    const formData = new FormData();
                    formData.append('file', file);
                    try {
                        const response = await fetch(`${API_BASE_URL}/conversation/import`, {
                            method: 'POST',
                            body: formData
                        });
                        if (!response.ok) {
                            let errorDetail = `Import failed (HTTP ${response.status})`;
                            try {
                                const errJson = await response.json();
                                errorDetail = errJson.detail || errorDetail;
                            } catch (e) {
                                /* Ignore */
                            }
                            throw new Error(errorDetail);
                        }
                        const data = await response.json();
                        this.addNotification(data.message || `Conversation imported successfully.`, 'success');
                        await this.fetchConversation();
                    } catch (error) {
                        console.error("Import failed:", error);
                        this.addNotification(`Import failed: ${error.message}`, 'error');
                    } finally {
                        this.isLoadingImport = false;
                        if (fileInput) {
                            fileInput.value = '';
                        }
                    }
                },
                copyToClipboard(encodedText) {
                    try {
                        // Decode the detail received from the event
                        const decodedText = JSON.parse(decodeURIComponent(atob(encodedText))); // ENSURE decodeURIComponent is used
                        navigator.clipboard.writeText(decodedText)
                            .then(() => {
                                this.addNotification('Copied to clipboard!', 'success', 200);
                            })
                            .catch(err => {
                                console.error('Clipboard write failed: ', err);
                                this.addNotification('Failed to copy to clipboard.', 'error');
                            });
                    } catch (e) {
                        console.error('Failed to decode/copy text: ', e, "Encoded text:", encodedText);
                        this.addNotification('Failed to copy (decode/parse error).', 'error');
                    }
                },
                addNotification(message, type = 'info', duration = 3500) {
                    const id = Date.now() + Math.random();
                    const maxNotifications = 5;
                    while (this.notifications.filter(n => n.visible).length >= maxNotifications) {
                        const oldestVisibleIndex = this.notifications.findIndex(n => n.visible);
                        if (oldestVisibleIndex !== -1) {
                            this.notifications.splice(oldestVisibleIndex, 1);
                        } else {
                            break;
                        }
                    }
                    const notification = {
                        id,
                        message,
                        type,
                        visible: true
                    };
                    this.notifications.push(notification);
                    const timer = setTimeout(() => {
                        this.dismissNotification(id);
                    }, duration);
                    notification._timer = timer;
                },
                dismissNotification(id, fadeDuration = 500) {
                    const index = this.notifications.findIndex(n => n.id === id);
                    if (index !== -1 && this.notifications[index].visible) {
                        clearTimeout(this.notifications[index]._timer);
                        this.notifications[index].visible = false;
                        setTimeout(() => {
                            const removeIndex = this.notifications.findIndex(n => n.id === id);
                            if (removeIndex !== -1) {
                                this.notifications.splice(removeIndex, 1);
                            }
                        }, fadeDuration);
                    }
                },
                notificationIcon(type) {
                    switch (type) {
                        case 'success':
                            return 'fas fa-check-circle';
                        case 'error':
                            return 'fas fa-exclamation-circle';
                        case 'warning':
                            return 'fas fa-exclamation-triangle';
                        default:
                            return 'fas fa-info-circle';
                    }
                }
            })); // End Alpine.data
        }); // End alpine:init listener
    </script>

    <!-- System Status Bar -->
    <div class="system-status-bar" :class="{'hidden': !uiSettings.showStatusBar}">
        <!-- Left section -->
        <div class="flex items-center gap-3">
            <div class="status-item"> <i class="fas fa-server fa-fw text-info"></i> <span
                    x-text="`Servers: ${connectedServersCount}/${servers.length}`"></span> </div>
            <div class="status-item"> <i class="fas" :class="getProviderIcon(currentModel)"></i> <span
                    x-text="currentModelShort"></span> </div>
            <div class="status-item"> <i class="fas fa-network-wired fa-fw text-success"></i> <span
                    x-text="`Branch: ${getNodeById(currentNodeId)?.name || 'root'}`"></span></div>
        </div>
        <!-- Right section -->
        <div class="flex items-center gap-3">
            <div class="status-item" title="Session Token Usage"> <i class="fas fa-arrow-right text-cyan-500 fa-fw"></i>
                <span x-text="`In: ${tokenUsage.input_tokens?.toLocaleString() || 0}`"></span>
            </div>
            <div class="status-item" title="Session Token Output"> <i
                    class="fas fa-arrow-left text-purple-500 fa-fw"></i> <span
                    x-text="`Out: ${tokenUsage.output_tokens?.toLocaleString() || 0}`"></span> </div>
            <div class="status-item" title="Session Cost"> <i class="fas fa-dollar-sign text-amber-500 fa-fw"></i> <span
                    x-text="`$${(tokenUsage.total_cost || 0).toFixed(4)}`"></span> </div>
            <div class="status-item cursor-pointer" @click="toggleSystemStats"> <i class="fas fa-chart-line fa-fw"></i>
                <span>Stats</span>
            </div>
            <div class="status-item" x-show="showSystemStats"> <i class="fas fa-memory fa-fw"></i> <span
                    x-text="`Mem: ${systemStats.memory}MB`"></span> </div>
            <div class="status-item" x-show="showSystemStats"> <i class="fas fa-clock fa-fw"></i> <span
                    x-text="`Uptime: ${systemStats.uptime}`"></span> </div>
        </div>
    </div>

    <!-- Container for the teleported template -->
    <div id="branch-node-template-container" class="hidden"></div>
</body>

</html>