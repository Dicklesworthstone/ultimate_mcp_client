<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>⚡ Ultimate MCP Client UI</title>

    <!-- Favicon (Example using FontAwesome) -->
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚡</text></svg>">

    <!-- FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- Animate.css -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    <!-- Tippy.js CSS -->
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/animations/scale.css" />
    <!-- highlight.js Theme (Atom One Dark for dark themes, maybe switch dynamically?) -->
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"
        id="hljs-theme-dark" media="(prefers-color-scheme: dark)">
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css"
        id="hljs-theme-light" media="(prefers-color-scheme: light)">
    <!-- DaisyUI -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/daisyui/4.4.19/full.min.css" rel="stylesheet" type="text/css" />
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Extend Tailwind theme to include Montserrat globally
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Montserrat', 'sans-serif'], // Make Montserrat the default sans-serif font
                        // You could add serif/mono here too if needed
                    },
                }
            }
        }
    </script>
    <!-- Tabulator CSS (choose a theme, e.g., tabulator_modern.min.css) -->
    <link href="https://unpkg.com/tabulator-tables@5.6.1/dist/css/tabulator_modern.min.css" rel="stylesheet">
    <!-- Tabulator JS -->
    <script type="text/javascript" src="https://unpkg.com/tabulator-tables@5.6.1/dist/js/tabulator.min.js"></script>
    <!-- JS Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- Alpine.js -->
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/alpinejs/3.13.3/cdn.min.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap"
        rel="stylesheet">

    <style>
        :root {
            --sidebar-width: 30rem;
        }

        .sidebar {
            width: var(--sidebar-width);
        }

        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: hsl(var(--b2) / 0.5);
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: hsl(var(--bc) / 0.5);
            border-radius: 3px;
        }

        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: hsl(var(--p) / 1);
        }

        dialog {
            z-index: 50;
        }

        .fa-fw {
            width: 1.25em;
        }

        .tippy-box {
            font-size: 0.8rem;
            max-width: 300px !important;
        }

        /* Smaller tooltips */

        /* Custom Chat Bubble Styles */
        .chat-bubble {
            max-width: 90%;
            /* Prevent bubbles from getting too wide */
            overflow-wrap: break-word;
        }

        .chat-bubble.prose {
            font-size: 0.95rem;
            /* Slightly larger text in bubbles */
            --tw-prose-code: hsl(var(--ac));
            /* Accent color for inline code */
            --tw-prose-pre-bg: hsl(var(--n) / 0.7);
            /* Neutral background for code blocks */
            --tw-prose-pre-code: hsl(var(--nc));
            /* Neutral content color for code blocks */
        }

        .chat-bubble.prose h1,
        .chat-bubble.prose h2,
        .chat-bubble.prose h3 {
            margin-top: 0.8em;
            margin-bottom: 0.4em;
        }

        .chat-bubble.prose p {
            margin-top: 0.5em;
            margin-bottom: 0.5em;
        }

        .chat-bubble.prose ul,
        .chat-bubble.prose ol {
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            padding-left: 1.2em;
        }

        .chat-bubble.prose pre {
            position: relative;
            /* For copy button positioning */
            border-radius: 0.375rem;
            /* Rounded corners */
            padding: 0.75rem 1rem;
            white-space: pre-wrap;
            /* Allow wrapping */
            word-break: break-all;
            /* Break long words/tokens */
            max-height: 400px;
            overflow-y: auto;
            background-color: var(--tw-prose-pre-bg) !important;
            /* Ensure bg color override */
            color: var(--tw-prose-pre-code) !important;
            /* Ensure text color override */
        }

        .chat-bubble.prose pre code.hljs {
            /* Target highlighted code */
            background-color: transparent !important;
            /* hljs might add its own bg */
            color: inherit !important;
            /* Inherit color from pre */
            padding: 0;
            /* Reset hljs padding */
        }

        .chat-bubble.prose code:not(pre *) {
            /* Inline code */
            color: var(--tw-prose-code);
            background-color: hsl(var(--b2));
            padding: 0.1em 0.3em;
            border-radius: 0.25rem;
            font-size: 0.85rem;
        }

        .copy-code-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: hsl(var(--b1) / 0.6);
            color: hsl(var(--bc) / 0.8);
            border: none;
            padding: 0.2rem 0.4rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.7rem;
            opacity: 0;
            transition: opacity 0.2s ease-in-out, background-color 0.2s, color 0.2s;
            z-index: 10;
            /* Ensure it's above code content */
        }

        .chat-bubble.prose pre:hover .copy-code-btn,
        .modal-box pre:hover .copy-code-btn {
            opacity: 1;
        }

        .copy-code-btn:hover {
            background-color: hsl(var(--b3) / 0.8);
            color: hsl(var(--bc) / 1);
        }

        /* Ensure modal code blocks also get copy button hover */
        .modal-box pre code.hljs {
            background-color: transparent !important;
            color: inherit !important;
        }

        .modal-box pre {
            position: relative;
        }

        /* For copy button */

        /* Streaming Status */
        .streaming-status {
            color: hsl(var(--nc) / 0.6);
            /* Neutral content, semi-transparent */
            font-style: italic;
            font-size: 0.75rem;
            margin-top: 0.2rem;
            text-align: right;
            /* Align to the right under the bubble */
        }

        /* Adjust sidebar lists for better density and hover */
        .sidebar-list-item {
            transition: background-color 0.15s ease-in-out, opacity 0.2s ease-in-out;
        }

        /* Loading overlay (optional, if needed for full-blocking actions) */
        .loading-overlay {
            position: fixed;
            inset: 0;
            background-color: hsl(var(--b1) / 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        /* Fix Tippy arrow color if needed, although DaisyUI themes might handle this */
        .tippy-box[data-theme^='light'] .tippy-arrow {
            color: #333;
        }

        .tippy-box[data-theme^='dark'] .tippy-arrow {
            color: #eee;
        }

        .tippy-box[data-theme="light"] {
            background-color: #333;
            color: white;
        }

        .tippy-box[data-theme="dark"] {
            background-color: #eee;
            color: black;
        }


        /* Adjust branch list indentation */
        #branch-list ul {
            padding-left: 0;
            list-style: none;
        }

        #branch-list li {
            padding-left: var(--indent-level, 0em);
        }

        /* Override Non-Error Tool Result Bubble Color */
        .chat-bubble.chat-bubble-accent {
            background-color: hsl(var(--in));
            /* Use Info background */
            color: hsl(var(--inc));
            /* Use Info content text color */
        }

        /* Ensure the corresponding avatar uses the same info colors */
        .chat-image .bg-accent {
            background-color: hsl(var(--in));
            color: hsl(var(--inc));
        }

        .chat-image .avatar .w-8 {
            position: relative;
            /* Needed for absolute positioning of child */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chat-image .avatar .w-8 i {
            line-height: 1;
            /* Helps vertical alignment */
            display: block;
            /* Treat icon as a block */
        }

        .tabulator {
            border: 1px solid hsl(var(--b3) / 0.4);
            background-color: hsl(var(--b1));
            /* Explicit base background */
            color: hsl(var(--bc));
            /* Explicit base text color */
            border-radius: var(--rounded-box, 0.5rem);
            /* Use DaisyUI variable or fallback */
            font-size: 0.75rem;
            /* text-xs */
            overflow: hidden;
            /* Prevents weird overlaps */
        }

        .tabulator .tabulator-header {
            background-color: hsl(var(--b2));
            /* Base-200 for header */
            border-bottom: 1px solid hsl(var(--b3) / 0.4);
            color: hsl(var(--bc));
            font-weight: 600;
            /* Make header text bolder */
        }

        /* Ensure header columns inherit background */
        .tabulator .tabulator-header .tabulator-col {
            background-color: inherit;
        }

        /* Ensure header filter inputs match theme */
        .tabulator .tabulator-header .tabulator-col .tabulator-header-filter input,
        .tabulator .tabulator-header .tabulator-col .tabulator-header-filter select {
            background-color: hsl(var(--b1));
            border: 1px solid hsl(var(--b3) / 0.5);
            border-radius: var(--rounded-input, 0.25rem);
            /* Use DaisyUI variable or fallback */
            padding: 0.1rem 0.4rem;
            font-size: 0.7rem;
            color: hsl(var(--bc));
            margin-top: 2px;
            /* Add slight margin */
        }

        /* Style rows */
        .tabulator .tabulator-tableholder .tabulator-table {
            background-color: hsl(var(--b1));
            /* Ensure table background */
            color: hsl(var(--bc));
        }

        .tabulator .tabulator-row {
            background-color: hsl(var(--b1));
            color: hsl(var(--bc));
            border-bottom: 1px solid hsl(var(--b3) / 0.2) !important;
            /* Ensure border */
            min-height: 28px;
            /* Ensure rows have some min height */
        }

        .tabulator .tabulator-row.tabulator-row-odd {
            background-color: hsl(var(--b2) / 0.4);
            /* Slightly different odd row */
        }

        .tabulator .tabulator-row:hover {
            background-color: hsl(var(--b3) / 0.3);
            /* Use base-300 for hover */
        }

        /* Style the placeholder text when table is empty */
        .tabulator .tabulator-placeholder {
            display: flex;
            /* Use flexbox for centering */
            justify-content: center;
            align-items: center;
            color: hsl(var(--bc) / 0.5);
            /* Base content color, semi-transparent */
            font-style: italic;
            background-color: hsl(var(--b1) / 0.7);
            /* Semi-transparent base background */
            width: 100%;
            /* Ensure it spans the width */
            min-height: 60px;
            /* Give placeholder some height */
        }

        /* Remove potential extra span wrapper styling if Tabulator adds one */
        .tabulator .tabulator-placeholder span {
            color: inherit;
            font-style: inherit;
            background-color: transparent;
        }

        /* Adjust button padding in table cells */
        .tabulator .tabulator-row .tabulator-cell button.btn-xs {
            padding-left: 0.4rem;
            padding-right: 0.4rem;
            min-height: 1.2rem;
            height: 1.2rem;
            line-height: 1;
        }

        .tabulator .tabulator-row .tabulator-cell i.fas {
            font-size: 0.7rem;
            margin-right: 0 !important;
        }
    </style>
</head>

<body class="h-screen flex flex-col bg-base-300/30" x-data="mcpClientUI">

    <!-- Header -->
    <header
        class="bg-base-100 shadow-md p-2 flex justify-between items-center flex-shrink-0 border-b border-base-300/50">
        <h1 class="text-xl font-bold flex items-center gap-2 text-base-content">
            <i class="fas fa-plug text-primary animate-pulse"></i> Ultimate MCP Client UI
        </h1>
        <div class="flex items-center gap-4 text-base-content/80">
            <!-- Connection Status -->
            <div class="tooltip tooltip-bottom" :data-tip="wsStatus">
                <i class="fas fa-circle text-xs transition-colors duration-500" :class="{
                    'text-success animate-pulse': wsConnected,
                    'text-warning': !wsConnected && wsConnecting,
                    'text-error': !wsConnected && !wsConnecting
                }"></i>
            </div>
            <!-- Server Status -->
            <div class="tooltip tooltip-bottom" data-tip="Servers">
                <i class="fas fa-server fa-fw"></i> <span x-text="`${connectedServersCount}/${servers.length}`"></span>
            </div>
            <!-- Tool Status -->
            <div class="tooltip tooltip-bottom" data-tip="Tools">
                <i class="fas fa-tools fa-fw"></i> <span x-text="tools.length"></span>
            </div>
            <!-- Model Selector -->
            <div class="dropdown dropdown-end">
                <label tabindex="0" class="btn btn-xs btn-ghost flex items-center gap-1 px-1">
                    <i class="fas fa-robot text-info"></i>
                    <span class="text-xs font-medium" x-text="currentModelShort"></span>
                    <i class="fas fa-chevron-down text-xs opacity-60"></i>
                </label>
                <ul tabindex="0"
                    class="dropdown-content z-[20] menu p-1 shadow bg-base-200 rounded-box w-52 max-h-60 overflow-y-auto text-xs">
                    <template x-for="model in availableModels" :key="model">
                        <li><a @click="setModel(model)" class="text-xs px-2 py-1"
                                :class="{'bg-primary text-primary-content': model === currentModel}" x-text="model"></a>
                        </li>
                    </template>
                    <div class="divider my-1"></div>
                    <li><input type="text" placeholder="Custom model..." class="input input-xs input-bordered w-full"
                            @change="setCustomModel($event.target.value)"
                            @keyup.enter="setCustomModel($event.target.value); $event.target.blur()"></li>
                </ul>
            </div>
            <!-- Theme Selector -->
            <div class="dropdown dropdown-end">
                <label tabindex="0" class="btn btn-xs btn-ghost px-1" data-tippy-content="Change Theme">
                    <i class="fas fa-palette"></i>
                </label>
                <ul tabindex="0"
                    class="dropdown-content z-[20] menu p-1 shadow bg-base-200 rounded-box w-40 max-h-60 overflow-y-auto">
                    <template x-for="theme in availableThemes" :key="theme">
                        <li><a @click="setTheme(theme)" class="text-xs capitalize px-2 py-1"
                                :class="{'bg-primary text-primary-content': theme === currentTheme}" x-text="theme"></a>
                        </li>
                    </template>
                </ul>
            </div>
        </div>
    </header>

    <!-- Main Content Area -->
    <div class="flex flex-1 overflow-hidden">

        <!-- Sidebar -->
        <aside class="sidebar bg-base-100 flex flex-col h-full border-r border-base-300/50 shadow-lg flex-shrink-0">
            <!-- Tabs -->
            <div role="tablist" class="tabs tabs-bordered tabs-lg flex-shrink-0">
                <a role="tab" class="tab flex-1"
                    :class="{ 'tab-active font-semibold !border-primary text-primary': activeTab === 'servers' }"
                    @click="activeTab = 'servers'" data-tippy-content="Servers"><i class="fas fa-server fa-fw"></i></a>
                <a role="tab" class="tab flex-1"
                    :class="{ 'tab-active font-semibold !border-primary text-primary': activeTab === 'tools' }"
                    @click="activeTab = 'tools'" data-tippy-content="Capabilities"><i
                        class="fas fa-tools fa-fw"></i></a>
                <a role="tab" class="tab flex-1"
                    :class="{ 'tab-active font-semibold !border-primary text-primary': activeTab === 'conversation' }"
                    @click="activeTab = 'conversation'" data-tippy-content="Conversation"><i
                        class="fas fa-comments fa-fw"></i></a>
                <a role="tab" class="tab flex-1"
                    :class="{ 'tab-active font-semibold !border-primary text-primary': activeTab === 'config' }"
                    @click="activeTab = 'config'" data-tippy-content="Settings"><i class="fas fa-cog fa-fw"></i></a>
            </div>

            <!-- Tab Content -->
            <div class="flex-1 p-3 overflow-y-auto space-y-5">

                <!-- Servers Tab -->
                <div x-show="activeTab === 'servers'" x-transition.opacity>
                    <!-- MODIFIED Header Section -->
                    <div class="flex justify-between items-center mb-3">
                        <h2 class="text-base font-semibold flex items-center"><i
                                class="fas fa-server mr-2 text-primary"></i>Servers</h2>
                        <!-- Wrap buttons in a div for grouping -->
                        <div class="flex gap-2">
                            <!-- NEW Reload Button -->
                            <button class="btn btn-xs btn-outline btn-warning" @click="reloadAllServers()"
                                :disabled="isLoadingServers"
                                data-tippy-content="Disconnect & Reload All Configured Servers">
                                <i class="fas fa-sync" :class="{'fa-spin': isLoadingServers}"></i>
                                <!-- Icon spins when loading -->
                            </button>
                            <!-- Existing Add Button (UNTOUCHED) -->
                            <button class="btn btn-xs btn-outline btn-primary" @click="showAddServerModal = true">
                                <i class="fas fa-plus mr-1"></i> Add
                            </button>
                        </div>
                    </div>
                    <!-- End MODIFIED Header Section -->

                    <!-- Server List Section (UNTOUCHED FROM YOUR ORIGINAL) -->
                    <div class="space-y-2.5">
                        <div x-show="isLoadingServers" class="text-center p-4"><span
                                class="loading loading-dots loading-md"></span></div>
                        <template x-for="server in servers" :key="server.name">
                            <div class="card card-compact bg-base-200/60 hover:bg-base-200 shadow-sm p-3 transition-all duration-150 ease-in-out sidebar-list-item"
                                :class="{'opacity-60': !server.enabled}">
                                <div class="flex justify-between items-center mb-1.5">
                                    <span class="font-semibold text-sm flex items-center gap-2">
                                        <i
                                            :class="server.type === 'stdio' ? 'fas fa-terminal text-accent' : 'fas fa-network-wired text-info'"></i>
                                        <span x-text="server.name"></span>
                                    </span>

                                    <div class="flex items-center gap-2">
                                        <!-- Server Status/Health Indicator -->
                                        <span class="tooltip tooltip-left text-xs"
                                            :data-tip="server.statusText || (server.isConnected ? 'Connected' : 'Disconnected')">
                                            <!-- Simple icon based on connectivity/loading -->
                                            <i :class="serverStatusIcon(server)" class="text-lg"></i>
                                        </span>
                                        <input type="checkbox" class="toggle toggle-xs toggle-success"
                                            title="Connect/Disconnect" :checked="server.isConnected"
                                            :disabled="server.isLoading || !server.enabled"
                                            @change="toggleServerConnection(server)"
                                            data-tippy-content="Connect/Disconnect" />
                                    </div>
                                </div>
                                <p class="text-xs text-base-content/60 mb-2 truncate" x-text="server.path"
                                    :data-tippy-content="server.path"></p>
                                <div class="flex justify-between items-center text-xs">
                                    <div class="flex items-center gap-2">
                                        <span data-tippy-content="Enable/Disable">
                                            <input type="checkbox" class="toggle toggle-xs" :checked="server.enabled"
                                                @change="toggleServerEnabled(server)" title="Enable/Disable" />
                                        </span>
                                        <button
                                            class="btn btn-xs btn-ghost text-info/70 hover:text-info hover:bg-info/10 p-1"
                                            @click="fetchServerDetails(server.name)" data-tippy-content="View Details">
                                            <i class="fas fa-info-circle fa-fw"></i>
                                        </button>
                                        <button
                                            class="btn btn-xs btn-ghost text-error/70 hover:text-error hover:bg-error/10 p-1"
                                            @click="removeServer(server.name)" data-tippy-content="Remove Server">
                                            <i class="fas fa-trash-alt fa-fw"></i>
                                        </button>
                                    </div>
                                    <span class="badge badge-outline badge-xs opacity-70"
                                        x-text="`${server.tools?.length || 0} tools`"></span>
                                </div>
                            </div>
                        </template>
                        <div x-show="servers.length === 0 && !isLoadingServers"
                            class="text-center text-base-content/50 py-4 text-sm">No servers configured.</div>
                    </div>
                    <!-- End Server List Section -->

                    <!-- Discovery Section (INSIDE Servers Tab) -->
                    <div class="mt-6 border-t border-base-300/50 pt-4">
                        <div class="flex justify-between items-center mb-3">
                            <h3 class="text-base font-semibold flex items-center"><i
                                    class="fas fa-search-location mr-2 text-primary"></i>Discovery</h3>
                            <button class="btn btn-xs btn-outline btn-primary" @click="triggerDiscovery()"
                                :disabled="isLoadingDiscovery" :class="{'loading': isLoadingDiscovery}"
                                data-tippy-content="Scan filesystem, registry, mDNS, and ports based on settings">
                                <i class="fas fa-sync mr-1" x-show="!isLoadingDiscovery"></i> Scan Network
                            </button>
                        </div>
                        <div x-show="isLoadingDiscovery" class="text-center p-4"><span
                                class="loading loading-dots loading-sm"></span> Scanning...</div>
                        <div id="discovered-servers-table" class="mt-2 text-xs border border-base-300/30 rounded"
                            x-show="!isLoadingDiscovery && discoveredServers.length >= 0">
                            <!-- Tabulator populates this -->
                        </div>
                        <div x-show="!isLoadingDiscovery && discoveredServers.length < 0"
                            class="text-center text-base-content/40 text-xs py-3 italic">Click 'Scan Network' to find
                            servers.</div>
                    </div>
                    <!-- End Discovery Section -->
                </div>
                <!-- End Servers Tab -->

                <!-- Tools Tab (Capabilities - Grouped Layout) -->
                <div x-show="activeTab === 'tools'" x-transition.opacity class="space-y-4">
                    <!-- Tab Header -->
                    <div class="flex justify-between items-center">
                        <h2 class="text-base font-semibold flex items-center"><i
                                class="fas fa-puzzle-piece mr-2 text-primary"></i>Capabilities</h2>
                        <span class="text-xs text-base-content/60" x-text="`(${totalCapabilities} total)`"></span>
                    </div>

                    <!-- Filter Input -->
                    <div class="sticky top-0 bg-base-100 py-2 z-10 -mt-2 -mx-3 px-3">
                        <div class="relative">
                            <input type="text" placeholder="Filter by server, name, or description..."
                                class="input input-sm input-bordered w-full pr-8 text-xs"
                                x-model.debounce.300ms="capabilitySearchTerm">
                            <i class="fas fa-search absolute right-3 top-1/2 -translate-y-1/2 text-base-content/40"></i>
                        </div>
                    </div>

                    <!-- Loading Indicator -->
                    <div x-show="isLoadingTools" class="text-center p-4"><span
                            class="loading loading-dots loading-md"></span> Loading Capabilities...</div>

                    <!-- Server Group Iteration -->
                    <div x-show="!isLoadingTools && filteredServerCapabilities.length > 0" class="space-y-4">
                        <template x-for="serverGroup in filteredServerCapabilities" :key="serverGroup.serverName">
                            <div class="card card-compact bg-base-200/50 border border-base-300/30 shadow-sm">
                                <div class="card-body p-3">
                                    <!-- Server Header -->
                                    <div class="flex items-center gap-2 mb-2 border-b border-base-300/20 pb-1.5">
                                        <i :class="serverStatusIcon(getServerByName(serverGroup.serverName))"
                                            class="text-lg"
                                            :data-tippy-content="getServerByName(serverGroup.serverName)?.isConnected ? 'Connected' : 'Disconnected'"></i>
                                        <h3 class="card-title text-sm font-semibold" x-text="serverGroup.serverName">
                                        </h3>
                                        <span class="text-xs opacity-60">
                                            (<span x-text="serverGroup.tools.length"></span> <i
                                                class="fas fa-hammer fa-xs"></i>,
                                            <span x-text="serverGroup.resources.length"></span> <i
                                                class="fas fa-book fa-xs"></i>,
                                            <span x-text="serverGroup.prompts.length"></span> <i
                                                class="fas fa-lightbulb fa-xs"></i>)
                                        </span>
                                    </div>

                                    <!-- Tools Section -->
                                    <template x-if="serverGroup.tools.length > 0">
                                        <div class="collapse collapse-arrow bg-base-100/50 border border-base-300/20 rounded-md text-xs"
                                            x-data="{ open: true }">
                                            <input type="checkbox" x-model="open" class="!min-h-0 peer" />
                                            <div class="collapse-title text-xs font-medium min-h-0 py-1.5 px-3 peer-checked:bg-base-300/10 peer-checked:border-b peer-checked:border-base-300/30 cursor-pointer"
                                                @click.prevent="open = !open">
                                                <i class="fas fa-hammer fa-fw mr-1 opacity-70"></i> Tools (<span
                                                    x-text="serverGroup.tools.length"></span>)
                                            </div>
                                            <div class="collapse-content !p-0">
                                                <div class="p-2 space-y-1.5 max-h-60 overflow-y-auto">
                                                    <template x-for="tool in serverGroup.tools" :key="tool.name">
                                                        <div class="p-1.5 bg-base-100 hover:bg-primary/10 rounded cursor-pointer transition-colors sidebar-list-item"
                                                            @click="showToolDetails(tool)">
                                                            <div class="flex justify-between items-center">
                                                                <span class="font-medium truncate text-xs"
                                                                    x-text="tool.shortName"
                                                                    :data-tippy-content="tool.name"></span>
                                                                <i class="fas fa-info-circle text-info/60 hover:text-info text-xs"
                                                                    data-tippy-content="View Details & Execute"></i>
                                                            </div>
                                                            <p class="text-xs text-base-content/60 truncate mt-0.5"
                                                                x-text="tool.description"
                                                                :data-tippy-content="tool.description || 'No description'">
                                                            </p>
                                                        </div>
                                                    </template>
                                                </div>
                                            </div>
                                        </div>
                                    </template>

                                    <!-- Resources Section -->
                                    <template x-if="serverGroup.resources.length > 0">
                                        <div class="collapse collapse-arrow bg-base-100/50 border border-base-300/20 rounded-md text-xs"
                                            x-data="{ open: false }">
                                            <input type="checkbox" x-model="open" class="!min-h-0 peer" />
                                            <div class="collapse-title text-xs font-medium min-h-0 py-1.5 px-3 peer-checked:bg-base-300/10 peer-checked:border-b peer-checked:border-base-300/30 cursor-pointer"
                                                @click.prevent="open = !open">
                                                <i class="fas fa-book fa-fw mr-1 opacity-70"></i> Resources (<span
                                                    x-text="serverGroup.resources.length"></span>)
                                            </div>
                                            <div class="collapse-content !p-0">
                                                <div class="p-2 space-y-1.5 max-h-40 overflow-y-auto">
                                                    <template x-for="resource in serverGroup.resources"
                                                        :key="resource.name">
                                                        <div class="p-1.5 bg-base-100 hover:bg-secondary/10 rounded sidebar-list-item"
                                                            :data-tippy-content="resource.description || 'No description'">
                                                            <div class="font-medium truncate text-xs"
                                                                x-text="resource.shortName"></div>
                                                            <p class="text-xs text-info truncate mt-0.5"
                                                                x-text="resource.template"
                                                                :data-tippy-content="'Template/URI: ' + resource.template">
                                                            </p>
                                                        </div>
                                                    </template>
                                                </div>
                                            </div>
                                        </div>
                                    </template>

                                    <!-- Prompts Section -->
                                    <template x-if="serverGroup.prompts.length > 0">
                                        <div class="collapse collapse-arrow bg-base-100/50 border border-base-300/20 rounded-md text-xs"
                                            x-data="{ open: false }">
                                            <input type="checkbox" x-model="open" class="!min-h-0 peer" />
                                            <div class="collapse-title text-xs font-medium min-h-0 py-1.5 px-3 peer-checked:bg-base-300/10 peer-checked:border-b peer-checked:border-base-300/30 cursor-pointer"
                                                @click.prevent="open = !open">
                                                <i class="fas fa-lightbulb fa-fw mr-1 opacity-70"></i> Prompts (<span
                                                    x-text="serverGroup.prompts.length"></span>)
                                            </div>
                                            <div class="collapse-content !p-0">
                                                <div class="p-2 space-y-1.5 max-h-40 overflow-y-auto">
                                                    <template x-for="prompt in serverGroup.prompts" :key="prompt.name">
                                                        <div class="p-1.5 bg-base-100 hover:bg-accent/10 rounded cursor-pointer transition-colors sidebar-list-item"
                                                            @click="applyPrompt(prompt.name)"
                                                            data-tippy-content="Apply Prompt">
                                                            <div class="font-medium truncate text-xs"
                                                                x-text="prompt.shortName"></div>
                                                            <p class="text-xs text-base-content/60 truncate mt-0.5"
                                                                x-text="prompt.description"
                                                                :data-tippy-content="prompt.description || 'No description'">
                                                            </p>
                                                        </div>
                                                    </template>
                                                </div>
                                            </div>
                                        </div>
                                    </template>

                                </div> <!-- End card-body -->
                            </div> <!-- End server card -->
                        </template>
                    </div>

                    <!-- No Results Message -->
                    <div x-show="!isLoadingTools && filteredServerCapabilities.length === 0"
                        class="text-center text-base-content/50 py-6 text-sm">
                        <span x-show="!capabilitySearchTerm">No capabilities found.</span>
                        <span x-show="capabilitySearchTerm">No capabilities match filter.</span>
                    </div>
                </div>
                <!-- END Tools Tab -->

                <!-- Conversation Tab -->
                <div x-show="activeTab === 'conversation'" x-transition.opacity>
                    <h2 class="text-base font-semibold mb-3 flex items-center"><i
                            class="fas fa-comments mr-2 text-primary"></i>Conversation</h2>
                    <div class="space-y-2.5">
                        <button class="btn btn-sm btn-block btn-outline" @click="forkConversation"
                            :disabled="isLoading || currentConversation.length === 0"><i
                                class="fas fa-code-branch mr-1.5"></i> Fork Branch</button>
                        <button class="btn btn-sm btn-block btn-outline" @click="optimizeConversation"
                            :disabled="isLoading || currentConversation.length < 2"><i class="fas fa-magic mr-1.5"></i>
                            Optimize Context</button>
                        <button class="btn btn-sm btn-block btn-outline btn-warning" @click="clearConversation"
                            :disabled="isLoading"><i class="fas fa-eraser mr-1.5"></i> Clear Context</button>
                        <div class="flex gap-2">
                            <button class="btn btn-sm flex-1 btn-outline btn-info" @click="exportConversationAPI()"
                                :disabled="isLoading || !currentNodeId || (currentNodeId === 'root' &&
                            currentConversation.length === 0)" data-tippy-content="Export current branch">
                                <i class="fas fa-file-export mr-1.5"></i> Export
                            </button>
                            <label class="btn btn-sm flex-1 btn-outline btn-accent"
                                :class="{'loading': isLoadingImport, 'btn-disabled': isLoadingImport || isLoading}"
                                data-tippy-content="Import conversation as a new branch under current node">
                                <i class="fas fa-file-import mr-1.5" x-show="!isLoadingImport"></i> Import
                                <input type="file" class="hidden" accept=".json"
                                    @change="importConversationAPI($event.target.files[0])"
                                    :disabled="isLoadingImport || isLoading">
                            </label>
                        </div>

                        <!-- Branch Management -->
                        <h3 class="text-sm font-semibold pt-3 mb-1 border-t border-base-300/50 opacity-80"><i
                                class="fas fa-network-wired mr-1.5"></i> Branches</h3>
                        <div id="branch-list" class="max-h-56 overflow-y-auto p-1 bg-base-200/60 rounded text-xs">
                            <ul class="list-none space-y-1">
                                <!-- Recursive template for tree structure -->
                                <template x-teleport="#branch-node-template-container">
                                    <div id="branch-node-template">
                                        <li x-data="{ open: $el.dataset.nodeid === $store.conversation.currentNodeId || ($el.dataset.nodeid === 'root' && $store.conversation.conversationNodes.length > 1) }"
                                            :style="{'--indent-level': ($el.dataset.level || 0) * 1 + 'em'}">
                                            <div @click="checkoutBranch($el.dataset.nodeid)"
                                                class="flex items-center gap-1 cursor-pointer hover:bg-base-300/80 rounded p-1"
                                                :class="{ 'bg-primary/10 text-primary font-semibold': $el.dataset.nodeid === $store.conversation.currentNodeId }">
                                                <!-- Toggle Icon -->
                                                <i x-show="$el.dataset.haschildren === 'true'"
                                                    class="fas fa-fw text-xs opacity-50 cursor-pointer hover:opacity-100 w-4 text-center"
                                                    :class="open ? 'fa-chevron-down' : 'fa-chevron-right'"
                                                    @click.stop="open = !open"></i>
                                                <i x-show="$el.dataset.haschildren !== 'true'"
                                                    class="fas fa-fw fa-circle-dot text-xs w-4 opacity-40"></i>
                                                <!-- Placeholder dot -->
                                                <!-- Node Icon & Name -->
                                                <i class="fas fa-code-branch text-xs opacity-60"
                                                    x-show="$el.dataset.level > 0"></i>
                                                <span class="truncate"
                                                    x-text="$el.dataset.nodename || 'Unnamed'"></span>
                                                <span class="text-base-content/50 ml-1"
                                                    x-text="$el.dataset.nodeid ? ' (...'+($el.dataset.nodeid.slice(-5))+')'  : ''"></span>
                                            </div>
                                            <!-- Children -->
                                            <ul x-show="open" x-transition.opacity
                                                class="mt-1 space-y-1 list-none pl-0">
                                                <template x-for="childId in JSON.parse($el.dataset.children || '[]')"
                                                    :key="childId">
                                                    <li
                                                        x-html="renderBranchNode(childId, parseInt($el.dataset.level || 0) + 1)">
                                                    </li>
                                                </template>
                                            </ul>
                                        </li>
                                    </div>
                                </template>
                                <!-- Initial Root Render -->
                                <li x-html="renderBranchNode('root', 0)"></li>
                            </ul>
                            <!-- No branches message that only shows when there are truly no branches -->
                            <div x-show="$store.conversation.conversationNodes.length <= 1 || ($store.conversation.conversationNodes.length === 1 && $store.conversation.conversationNodes[0].id === 'root' && !$store.conversation.conversationNodes[0].childrenIds.length)"
                                class="text-center text-base-content/50 py-2 text-xs">No branches yet. Fork to create
                                more.</div>
                        </div>
                        <!-- Container for the teleported template -->
                        <div id="branch-node-template-container" class="hidden"></div>
                    </div>
                    <!-- End Conversation Tab -->

                    <!-- Config Tab -->
                    <div x-show="activeTab === 'config'" x-transition.opacity>
                        <h2 class="text-base font-semibold mb-3 flex items-center"><i
                                class="fas fa-cog mr-2 text-primary"></i>Settings
                        </h2>
                        <div class="space-y-3 text-sm">
                            <div class="form-control">
                                <label class="label py-1"><span class="label-text text-xs font-medium"
                                        data-tippy-content="Your Anthropic API Key (Keep Secret!)">Anthropic API
                                        Key</span></label>
                                <input type="password" placeholder="sk-ant-..." class="input input-bordered input-sm"
                                    x-model="config.apiKey"
                                    @input.debounce.500ms="saveConfigField('apiKey', $event.target.value)">
                            </div>
                            <div class="form-control">
                                <label class="label py-1"><span class="label-text text-xs font-medium"
                                        data-tippy-content="Default model for new conversations">Default
                                        Model</span></label>
                                <input type="text" placeholder="claude-3-..." class="input input-bordered input-sm"
                                    x-model="config.defaultModel"
                                    @input.debounce.500ms="saveConfigField('defaultModel', $event.target.value); setModel($event.target.value)">
                            </div>
                            <div class="form-control">
                                <label class="label py-1"><span class="label-text text-xs font-medium"
                                        data-tippy-content="Max tokens for Claude's response">Max Tokens</span></label>
                                <input type="number" class="input input-bordered input-sm w-24"
                                    x-model.number="config.maxTokens"
                                    @input.debounce.500ms="saveConfigField('maxTokens', $event.target.value)">
                            </div>
                            <div class="form-control">
                                <label class="label py-1"><span class="label-text text-xs font-medium"
                                        data-tippy-content="Response creativity (0=deterministic, 1=max creative)">Temperature
                                        (<span class="font-mono"
                                            x-text="config.temperature?.toFixed(1)"></span>)</span></label>
                                <input type="range" min="0" max="1" step="0.1" class="range range-xs range-primary"
                                    x-model.number="config.temperature"
                                    @change="saveConfigField('temperature', $event.target.value)" />
                            </div>
                            <div class="grid grid-cols-2 gap-x-4">
                                <label class="cursor-pointer label justify-start gap-2 py-1"
                                    data-tippy-content="Stream responses word by word"><input type="checkbox"
                                        class="toggle toggle-primary toggle-sm" x-model="config.enableStreaming"
                                        @change="saveConfigField('enableStreaming', $event.target.checked)"><span
                                        class="label-text text-xs">Streaming</span></label>
                                <label class="cursor-pointer label justify-start gap-2 py-1"
                                    data-tippy-content="Cache tool results locally"><input type="checkbox"
                                        class="toggle toggle-primary toggle-sm" x-model="config.enableCaching"
                                        @change="saveConfigField('enableCaching', $event.target.checked)"><span
                                        class="label-text text-xs">Caching</span></label>
                                <label class="cursor-pointer label justify-start gap-2 py-1"
                                    data-tippy-content="Automatically look for servers at startup"><input
                                        type="checkbox" class="toggle toggle-primary toggle-sm"
                                        x-model="config.autoDiscover"
                                        @change="saveConfigField('autoDiscover', $event.target.checked)"><span
                                        class="label-text text-xs">Auto Discover</span></label>
                                <label class="cursor-pointer label justify-start gap-2 py-1"
                                    data-tippy-content="Look for servers on local network via mDNS/Zeroconf"><input
                                        type="checkbox" class="toggle toggle-primary toggle-sm"
                                        x-model="config.enableLocalDiscovery"
                                        @change="saveConfigField('enableLocalDiscovery', $event.target.checked)"><span
                                        class="label-text text-xs">mDNS</span></label>
                            </div>
                            <div class="form-control">
                                <label class="label py-1"><span class="label-text text-xs font-medium"
                                        data-tippy-content="How often to refresh server status (seconds)">Dashboard
                                        Refresh
                                        (s)</span></label>
                                <input type="number" class="input input-bordered input-sm w-24"
                                    x-model.number="config.dashboardRefreshRate"
                                    @input.debounce.500ms="saveConfigField('dashboardRefreshRate', $event.target.value)"
                                    min="0.5" step="0.1">
                            </div>
                            <button class="btn btn-xs btn-outline btn-error mt-4" @click="resetConfig"><i
                                    class="fas fa-undo mr-1"></i>
                                Reset Settings</button>
                        </div>

                        <div class="mt-6 border-t border-base-300/50 pt-4">
                            <h2 class="text-base font-semibold mb-3 flex items-center"><i
                                    class="fas fa-database mr-2 text-primary"></i>Cache Management</h2>

                            <div class="flex flex-wrap gap-2 mb-4">
                                <button class="btn btn-xs btn-outline" @click="fetchCacheData()"
                                    :disabled="isLoadingCache" :class="{'loading': isLoadingCache}">
                                    <i class="fas fa-sync mr-1" x-show="!isLoadingCache"></i> Refresh Cache Info
                                </button>
                                <button class="btn btn-xs btn-outline btn-warning" @click="cleanCacheAPI()"
                                    :disabled="isLoadingCache">
                                    <i class="fas fa-broom mr-1"></i> Clean Expired
                                </button>
                                <button class="btn btn-xs btn-outline btn-error" @click="clearAllCacheAPI()"
                                    :disabled="isLoadingCache">
                                    <i class="fas fa-trash-alt mr-1"></i> Clear All Cache
                                </button>
                            </div>

                            <!-- Cache Entries Table -->
                            <h3 class="text-sm font-semibold mb-2 opacity-80"><i class="fas fa-list-ul mr-1.5"></i>
                                Cached
                                Entries</h3>
                            <div x-show="isLoadingCache && cacheEntries.length === 0" class="text-center p-4"><span
                                    class="loading loading-dots loading-sm"></span> Loading Cache...</div>
                            <div id="cache-entries-table" class="text-xs border border-base-300/30 rounded mb-4"
                                x-show="!isLoadingCache">
                            </div>

                            <!-- Cache Dependencies Table -->
                            <h3 class="text-sm font-semibold mb-2 opacity-80"><i
                                    class="fas fa-project-diagram mr-1.5"></i>
                                Tool Dependencies</h3>
                            <div x-show="isLoadingCache && Object.keys(cacheDependencies).length === 0"
                                class="text-center p-4">
                                <span class="loading loading-dots loading-sm"></span> Loading
                                Dependencies...
                            </div>
                            <div id="cache-dependencies-table" class="text-xs border border-base-300/30 rounded"
                                x-show="!isLoadingCache">
                            </div>
                        </div>
                    </div>
                    <!-- End Config Tab -->

                </div>
                <!-- End Tab Content -->
        </aside>

        <!-- Chat Area -->
        <main class="flex-1 flex flex-col h-full bg-gradient-to-b from-base-200 to-base-300/50">
            <!-- Messages Display -->
            <div class="flex-1 p-4 overflow-y-auto chat-messages" x-ref="chatbox">
                <template x-for="(message, index) in currentConversation" :key="message.id || index">
                    <div class="chat" :class="message.role === 'user' ? 'chat-end' : 'chat-start'">
                        <div class="chat-image avatar" x-show="message.role !== 'user'">
                            <!-- System/Assistant Avatar -->
                            <div class="w-8 rounded-full flex items-center justify-center" :class="{
                                    'bg-secondary text-secondary-content': message.role === 'assistant',
                                    'bg-neutral text-neutral-content': message.role === 'system',
                                    'bg-accent text-accent-content': message.content_type === 'tool_result' && !message.is_error,
                                    'bg-warning text-warning-content': message.content_type === 'tool_result' && message.is_error
                                  }">
                                <i :class="messageRoleIcon(message.role, message.content_type)" class="text-sm"></i>
                            </div>
                        </div>
                        <div class="chat-image avatar" x-show="message.role === 'user'"> <!-- User Avatar -->
                            <div
                                class="w-8 rounded-full bg-primary text-primary-content flex items-center justify-center">
                                <i :class="messageRoleIcon(message.role)" class="text-sm"></i>
                            </div>
                        </div>
                        <div class="chat-header text-xs opacity-60 mb-0.5 ml-1"
                            :class="{'text-right mr-1': message.role === 'user'}">
                            <span x-text="messageRoleDisplayName(message.role, message.content_type)"></span>
                            <span x-show="message.model" class="opacity-70"
                                x-text="message.model ? (' (' + message.model + ')') : ''"></span>
                            <time class="text-xs opacity-50 ml-1" x-text="formatTimestamp(message.timestamp)"></time>
                        </div>
                        <!-- Main Chat Bubble -->
                        <!-- We apply highlight.js classes manually within renderMessageContent -->
                        <div class="chat-bubble max-w-3xl" :class="{
                            'chat-bubble-primary text-primary-content': message.role === 'user' && message.content_type !== 'tool_result', // Standard User
                            'bg-neutral text-neutral-content': message.role === 'assistant' && !message.current_status && message.content_type !== 'tool_result', // Standard Assistant
                            'chat-bubble-info text-info-content': message.role === 'system', // Standard System
                            'chat-bubble-info text-info-content': message.role === 'assistant' && message.current_status, // Streaming assistant uses info
                            // Specific Tool Result Styles (These override base styles)
                            'chat-bubble-warning text-warning-content': message.content_type === 'tool_result' && message.is_error,
                            'bg-info text-info-content': message.content_type === 'tool_result' && !message.is_error,
                            // Animation
                            'animate__animated animate__fadeInUp animate__faster': shouldAnimate(message.id || index)
                         }" x-html="debugRenderMessage(message)">
                        </div>
                        <!-- Status Updates -->
                        <div class="chat-footer" x-show="message.role === 'assistant' && message.current_status">
                            <span class="streaming-status opacity-70" x-text="message.current_status"></span>
                        </div>
                    </div>
                </template>
                <!-- Loading Indicator -->
                <div x-show="isSendingMessage && !currentStatusMessage" class="chat chat-start">
                    <div class="chat-image avatar">
                        <div
                            class="w-8 rounded-full bg-secondary text-secondary-content flex items-center justify-center">
                            <i class="fas fa-robot text-sm"></i>
                        </div>
                    </div>
                    <div class="chat-bubble chat-bubble-secondary animate-pulse"><span
                            class="loading loading-dots loading-sm"></span></div>
                </div>
                <div x-ref="endofchat" class="h-1"></div> <!-- Scroll target -->
            </div>

            <!-- Input Area -->
            <div class="p-3 border-t border-base-300/50 bg-base-100 flex-shrink-0 shadow-inner">
                <!-- Status Message -->
                <div x-show="currentStatusMessage"
                    class="text-xs text-info mb-1.5 flex items-center gap-1.5 animate__animated animate__fadeIn animate__faster">
                    <i :class="currentStatusIcon()"></i> <span x-text="currentStatusMessage"></span>
                </div>
                <!-- Input -->
                <div class="flex items-end gap-2">
                    <textarea class="textarea textarea-bordered w-full resize-none text-sm leading-tight pt-2 pb-2"
                        placeholder="Ask Claude anything... (Shift+Enter for newline)" rows="1" x-model="userInput"
                        @keydown.enter.exact.prevent.stop="sendMessage"
                        @keydown.shift.enter.exact.prevent="userInput += '\n'; adjustTextareaHeight($el)"
                        @input="adjustTextareaHeight($event.target)" x-ref="inputarea"
                        :disabled="isSendingMessage && !config.enableStreaming"></textarea>
                    <button x-show="isSendingMessage" class="btn btn-warning btn-square btn-sm" @click="stopGeneration"
                        data-tippy-content="Stop Generation">
                        <i class="fas fa-stop"></i>
                    </button>
                    <button x-show="!isSendingMessage" class="btn btn-primary btn-square btn-sm" @click="sendMessage"
                        :disabled="!userInput.trim()">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </main>

    </div>

    <!-- Modals -->
    <dialog id="addServerModal" class="modal" :class="{ 'modal-open': showAddServerModal }"
        @keydown.escape.window="showAddServerModal = false">
        <div class="modal-box bg-base-100">
            <h3 class="font-bold text-lg mb-4">Add New MCP Server</h3>
            <form @submit.prevent="addServer">
                <div class="form-control mb-2">
                    <label class="label"><span class="label-text">Name</span></label>
                    <input type="text" placeholder="e.g., my-local-agent" class="input input-bordered"
                        x-model="newServer.name" required x-ref="addServerNameInput" @keydown.enter.prevent>
                </div>
                <div class="form-control mb-2">
                    <label class="label"><span class="label-text">Type</span></label>
                    <select class="select select-bordered" x-model="newServer.type" required>
                        <option value="stdio">STDIO</option>
                        <option value="sse">SSE (HTTP)</option>
                    </select>
                </div>
                <div class="form-control mb-2">
                    <label class="label"><span class="label-text"
                            x-text="newServer.type === 'stdio' ? 'Command/Path' : 'URL'"></span></label>
                    <input type="text"
                        :placeholder="newServer.type === 'stdio' ? '/path/to/server.py or python -m my_module' : 'http://localhost:8000/mcp'"
                        class="input input-bordered" x-model="newServer.path" required @keydown.enter.prevent>
                </div>
                <div class="form-control mb-4" x-show="newServer.type === 'stdio'">
                    <label class="label"><span class="label-text">Arguments (optional, space-separated)</span></label>
                    <input type="text" placeholder="--port 8080 --debug" class="input input-bordered"
                        x-model="newServer.argsString" @keydown.enter.prevent>
                </div>
                <div class="modal-action">
                    <button type="button" class="btn btn-ghost" @click="showAddServerModal = false">Cancel</button>
                    <button type="submit" class="btn btn-primary">Add Server</button>
                </div>
            </form>
        </div>
        <form method="dialog" class="modal-backdrop"> <button @click="showAddServerModal = false">close</button> </form>
    </dialog>

    <dialog id="toolDetailsModal" class="modal" :class="{ 'modal-open': showToolDetailsModal }"
        @keydown.escape.window="showToolDetailsModal = false">
        <div class="modal-box w-11/12 max-w-2xl bg-base-100">
            <h3 class="font-bold text-lg mb-2 flex items-center gap-2"><i class="fas fa-info-circle text-info"></i><span
                    x-text="selectedTool?.name || 'Tool Details'"></span></h3>
            <p class="text-sm mb-1">Server: <span class="badge badge-ghost" x-text="selectedTool?.server_name"></span>
            </p>
            <p class="text-sm mb-4 opacity-80" x-text="selectedTool?.description"></p>
            <h4 class="font-semibold mb-2">Input Schema:</h4>
            <div class="bg-base-200 p-3 rounded max-h-60 overflow-y-auto text-xs relative group">
                <pre><code class="language-json" x-text="JSON.stringify(selectedTool?.input_schema || {}, null, 2)"></code></pre>
                <button class="copy-code-btn" x-data="{ copied: false }"
                    @click.stop="copyToClipboard(btoa(JSON.stringify(selectedTool?.input_schema || {}, null, 2))); copied = true; setTimeout(() => copied = false, 1500)">
                    <i class="fas mr-1" :class="copied ? 'fa-check text-success' : 'fa-copy'"></i> <span
                        x-text="copied ? 'Copied!' : 'Copy'"></span>
                </button>
            </div>
            <div class="mt-4 border-t border-base-300/50 pt-4">
                <h4 class="font-semibold mb-2">Execute Tool Directly:</h4>
                <textarea class="textarea textarea-bordered w-full text-xs font-mono" rows="5"
                    placeholder='Enter JSON parameters... e.g., {"query": "example"}'
                    x-model="directToolParams"></textarea>
                <button class="btn btn-sm btn-primary mt-2" @click="executeToolDirectly"
                    :disabled="!selectedTool || isLoadingDirectTool" :class="{'loading': isLoadingDirectTool}">
                    <i class="fas fa-play mr-1"></i> Execute
                </button>
                <div x-show="directToolResult || directToolError"
                    class="mt-2 text-xs bg-base-200 p-3 rounded max-h-40 overflow-y-auto relative group">
                    <h5 class="font-semibold mb-1" :class="directToolError ? 'text-error' : 'text-success'"
                        x-text="directToolError ? 'Error:' : 'Result:'"></h5>
                    <pre><code class="language-json whitespace-pre-wrap break-all" x-text="directToolError ? directToolError : JSON.stringify(directToolResult?.content, null, 2)"></code></pre>
                    <button x-show="!directToolError && directToolResult" class="copy-code-btn"
                        x-data="{ copied: false }"
                        @click.stop="copyToClipboard(btoa(JSON.stringify(directToolResult?.content, null, 2))); copied = true; setTimeout(() => copied = false, 1500)">
                        <i class="fas mr-1" :class="copied ? 'fa-check text-success' : 'fa-copy'"></i> <span
                            x-text="copied ? 'Copied!' : 'Copy Result'"></span>
                    </button>
                </div>
            </div>
            <div class="modal-action mt-4">
                <button class="btn btn-ghost" @click="showToolDetailsModal = false">Close</button>
            </div>
        </div>
        <form method="dialog" class="modal-backdrop"> <button @click="showToolDetailsModal = false">close</button>
        </form>
    </dialog>


    <!-- Server Details Modal -->
    <dialog id="serverDetailsModal" class="modal" :class="{ 'modal-open': showServerDetailsModal }"
        @keydown.escape.window="showServerDetailsModal = false">
        <div class="modal-box w-11/12 max-w-xl bg-base-100">
            <button class="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"
                @click="showServerDetailsModal = false">✕</button>
            <h3 class="font-bold text-lg mb-4 flex items-center gap-2">
                <i class="fas fa-server text-primary"></i>Server Details: <span class="font-mono"
                    x-text="selectedServerDetails?.name || 'Loading...'"></span>
            </h3>

            <div x-show="isLoadingServerDetails" class="text-center p-6"><span
                    class="loading loading-spinner loading-lg"></span></div>

            <!-- ***** START x-if WRAPPER ***** -->
            <template x-if="selectedServerDetails">
                <div class="space-y-3 text-sm" x-transition>
                    <!-- Basic Info -->
                    <div class="grid grid-cols-2 gap-x-4 gap-y-1 text-xs border-b border-base-300/30 pb-2 mb-2">
                        <!-- All the <span> and <code> elements displaying server details -->
                        <div><strong>Status:</strong> <span class="badge badge-sm"
                                :class="selectedServerDetails.is_connected ? 'badge-success' : 'badge-error'"
                                x-text="selectedServerDetails.is_connected ? 'Connected' : 'Disconnected'"></span></div>
                        <div><strong>Type:</strong> <span class="badge badge-sm badge-outline"
                                x-text="selectedServerDetails.type"></span></div>
                        <div><strong>Enabled:</strong> <span
                                x-text="selectedServerDetails.enabled ? 'Yes' : 'No'"></span></div>
                        <div><strong>Trusted:</strong> <span
                                x-text="selectedServerDetails.trusted ? 'Yes' : 'No'"></span></div>
                        <div class="col-span-2"><strong>Path/URL:</strong> <code class="text-xs break-all"
                                x-text="selectedServerDetails.path"></code></div>
                        <div class="col-span-2" x-show="selectedServerDetails.args?.length > 0"><strong>Args:</strong>
                            <code class="text-xs" x-text="selectedServerDetails.args?.join(' ')"></code>
                        </div>
                        <div class="col-span-2"><strong>Description:</strong> <span class="opacity-80"
                                x-text="selectedServerDetails.description || 'N/A'"></span></div>
                        <div x-show="selectedServerDetails.version"><strong>Version:</strong> <span
                                x-text="selectedServerDetails.version"></span></div>
                        <div x-show="selectedServerDetails.registry_url"><strong>Registry:</strong> <a
                                :href="selectedServerDetails.registry_url" target="_blank"
                                class="link link-info text-xs" x-text="selectedServerDetails.registry_url"></a></div>
                        <div><strong>Timeout:</strong> <span x-text="selectedServerDetails.timeout + 's'"></span></div>
                        <div><strong>Retries:</strong> <span x-text="selectedServerDetails.retry_count"></span></div>
                    </div>

                    <!-- Metrics -->
                    <details
                        class="collapse collapse-arrow border border-base-300/30 bg-base-200/50 rounded-md text-xs">
                        <summary class="collapse-title text-xs font-medium py-1.5 min-h-0">Metrics</summary>
                        <div class="collapse-content !px-0 !pb-0">
                            <div class="p-2 grid grid-cols-2 gap-x-3 gap-y-1">
                                <!-- ... all the spans displaying metrics ... -->
                                <div><strong>Health:</strong> <span class="uppercase font-semibold"
                                        :class="{ 'text-success': selectedServerDetails.metrics?.status === 'healthy', 'text-warning': selectedServerDetails.metrics?.status === 'degraded', 'text-error': selectedServerDetails.metrics?.status === 'error' }"
                                        x-text="selectedServerDetails.metrics?.status || 'Unknown'"></span></div>
                                <div><strong>Avg Resp:</strong> <span
                                        x-text="(selectedServerDetails.metrics?.avg_response_time_ms || 0).toFixed(1) + ' ms'"></span>
                                </div>
                                <div><strong>Requests:</strong> <span
                                        x-text="selectedServerDetails.metrics?.request_count || 0"></span></div>
                                <div><strong>Errors:</strong> <span class="font-semibold"
                                        :class="{'text-error': (selectedServerDetails.metrics?.error_count || 0) > 0}"
                                        x-text="selectedServerDetails.metrics?.error_count || 0"></span></div>
                                <div><strong>Error Rate:</strong> <span
                                        x-text="(selectedServerDetails.metrics?.error_rate || 0).toFixed(2) * 100 + '%'"></span>
                                </div>
                                <div><strong>Uptime:</strong> <span
                                        x-text="(selectedServerDetails.metrics?.uptime_minutes || 0).toFixed(1) + ' min'"></span>
                                </div>
                                <div class="col-span-2"><strong>Last Check:</strong> <span
                                        x-text="formatTimestamp(selectedServerDetails.metrics?.last_checked)"></span>
                                </div>
                            </div>
                        </div>
                    </details>

                    <!-- Process Info (STDIO Only) -->
                    <details x-show="selectedServerDetails.type === 'stdio' && selectedServerDetails.process_info"
                        class="collapse collapse-arrow border border-base-300/30 bg-base-200/50 rounded-md text-xs">
                        <summary class="collapse-title text-xs font-medium py-1.5 min-h-0">Process Info (STDIO)
                        </summary>
                        <div class="collapse-content !px-0 !pb-0">
                            <div class="p-2 grid grid-cols-2 gap-x-3 gap-y-1"
                                x-show="!selectedServerDetails.process_info?.error">
                                <!-- ... all the spans displaying process info ... -->
                                <div><strong>PID:</strong> <span
                                        x-text="selectedServerDetails.process_info?.pid"></span></div>
                                <div><strong>Status:</strong> <span
                                        x-text="selectedServerDetails.process_info?.status"></span></div>
                                <div><strong>CPU:</strong> <span
                                        x-text="(selectedServerDetails.process_info?.cpu_percent || 0).toFixed(1) + '%'"></span>
                                </div>
                                <div><strong>Memory (RSS):</strong> <span
                                        x-text="(selectedServerDetails.process_info?.memory_rss_mb || 0).toFixed(1) + ' MB'"></span>
                                </div>
                                <div class="col-span-2"><strong>Created:</strong> <span
                                        x-text="formatTimestamp(selectedServerDetails.process_info?.create_time)"></span>
                                </div>
                            </div>
                            <div class="p-2 text-error" x-show="selectedServerDetails.process_info?.error">
                                <strong>Error:</strong> <span x-text="selectedServerDetails.process_info?.error"></span>
                            </div>
                        </div>
                    </details>
                </div> <!-- This is the closing div for the main content -->
            </template>
            <!-- ***** END x-if WRAPPER ***** -->

            <div x-show="!isLoadingServerDetails && !selectedServerDetails" class="text-center text-error p-4">Failed to
                load server details.</div>

            <div class="modal-action mt-4">
                <!-- ... modal buttons ... -->
                <button class="btn btn-sm btn-ghost" @click="showServerDetailsModal = false">Close</button>
                <button class="btn btn-sm btn-outline" @click="fetchServerDetails(selectedServerDetails?.name)"
                    :disabled="isLoadingServerDetails">
                    <i class="fas fa-sync mr-1" :class="{'fa-spin': isLoadingServerDetails}"></i> Refresh
                </button>
            </div>
        </div>
        <form method="dialog" class="modal-backdrop"><button @click="showServerDetailsModal = false">close</button>
        </form>
    </dialog>

    <!-- Notifications Area -->
    <div
        class="toast toast-bottom toast-center md:toast-top md:toast-end z-[100] w-full md:w-auto max-w-xs md:max-w-sm">
        <template x-for="(notification, index) in notifications" :key="notification.id">
            <div :class="['alert', `alert-${notification.type || 'info'}`, 'shadow-lg', 'flex', '!items-start']"
                x-show="notification.visible" x-transition:enter="animate__animated animate__fadeInUp animate__faster"
                x-transition:leave="animate__animated animate__fadeOutDown animate__faster">
                <i :class="notificationIcon(notification.type)" class="text-lg mt-1"></i>
                <span class="text-sm flex-1" x-text="notification.message"></span>
                <button class="btn btn-xs btn-ghost p-0 ml-2" @click="dismissNotification(notification.id)"><i
                        class="fas fa-times"></i></button>
            </div>
        </template>
    </div>

    <!-- Global Loading Overlay (Optional) -->
    <div x-show="isLoading && !isSendingMessage" x-transition.opacity.duration.100ms
        class="loading-overlay animate__animated animate__fadeIn animate__faster">
        <span class="loading loading-ring loading-lg text-primary"></span>
    </div>

    <script>
        const API_BASE_URL = 'http://127.0.0.1:8017/api'; // Adjust if needed
        const WS_URL = 'ws://127.0.0.1:8017/ws/chat';   // Adjust if needed

        const createCopyButton = (codeToCopy, type = 'code') => {
            // Encode the code to safely pass it as a string attribute literal
            // Using JSON.stringify deals with quotes, newlines etc. then encode that.
            try {
                const encodedCode = btoa(encodeURIComponent(JSON.stringify(codeToCopy)));
                const buttonText = type === 'result' ? 'Copy Result' : 'Copy';
                return `<button class="copy-code-btn" x-data="{ copied: false }" @click.stop="copyToClipboard('${encodedCode}'); copied = true; setTimeout(() => copied = false, 1500)">
                            <i class="fas mr-1" :class="copied ? 'fa-check text-success' : 'fa-copy'"></i> <span x-text="copied ? 'Copied!' : '${buttonText}'"></span>
                        </button>`;
            } catch (e) {
                console.error("Error creating copy button data:", e);
                return '<!-- copy error -->';
            }
        };

        // Marked configuration with highlight.js

        const markedRenderer = new marked.Renderer();
        const originalCodeRenderer = markedRenderer.code; // Optional: keep if needed elsewhere, but not used in the override below
        markedRenderer.code = (code, language, isEscaped) => {
            const lang = hljs.getLanguage(language) ? language : 'plaintext';
            let codeToHighlight = ''; // Initialize
            let originalCodeForCopy = code; // Preserve original for copy button if possible

            if (typeof code === 'string') {
                codeToHighlight = code;
                originalCodeForCopy = code; // It's already a string
            } else if (code && typeof code === 'object' && typeof code.text === 'string') {
                // If it's an object with a text property (like from the log)
                codeToHighlight = code.text;
                originalCodeForCopy = code.text; // Use the extracted text for copy too
            } else {
                // Fallback: attempt stringification if it's not a string or the expected object structure
                console.warn("Marked 'code' received unexpected type, attempting stringification:", code);
                codeToHighlight = String(code); // This might result in [object Object]
                originalCodeForCopy = codeToHighlight; // Copy the stringified version
            }

            try {
                const highlightedCode = hljs.highlight(codeToHighlight, { language: lang, ignoreIllegals: true }).value;
                // Use originalCodeForCopy for the copy button to get the best representation
                const copyButtonHtml = createCopyButton(originalCodeForCopy);
                // Wrap in a div for positioning context and add hljs class for styling
                return `<div class="relative group"><pre><code class="hljs language-${lang}">${highlightedCode}</code></pre>${copyButtonHtml}</div>`;
            } catch (e) {
                console.error("Highlighting error:", e);
                // Fallback: Ensure code is stringified before sanitizing if error occurred
                const safeCode = DOMPurify.sanitize(codeToHighlight); // Sanitize the extracted/stringified code
                return `<div class="relative group"><pre><code class="hljs language-${lang}">${safeCode}</code></pre>${createCopyButton(safeCode)}</div>`;
            }
        };

        // Set Marked options using the renderer (which now lacks the paragraph override)
        marked.setOptions({
            renderer: markedRenderer,
            breaks: true, // Convert single newlines to <br>
            gfm: true, // Enable GitHub Flavored Markdown
        });

        // Global safe stringify function for debugging
        window.safeDebugStringify = function (obj, indent = 2) {
            // Keep track of objects we've already processed to avoid circular references
            const seen = new WeakSet();

            return JSON.stringify(obj, (key, value) => {
                // Handle DOM nodes and non-plain objects
                if (value && typeof value === 'object' && value.nodeType > 0) {
                    return `[DOM Node: ${value.nodeName || 'unknown'}]`;
                }

                // Handle function values
                if (typeof value === 'function') {
                    return `[Function: ${value.name || 'anonymous'}]`;
                }

                // Handle circular references
                if (value !== null && typeof value === 'object') {
                    if (seen.has(value)) {
                        return '[Circular Reference]';
                    }
                    seen.add(value);
                }

                return value;
            }, indent);
        };

        document.addEventListener('alpine:init', () => {

            // Setup Alpine store first (KEEP THIS)
            Alpine.store('conversation', {
                currentNodeId: 'root',
                conversationNodes: [{ id: 'root', name: 'Root', parentId: null, childrenIds: [] }],
                setCurrentNodeId(id) { this.currentNodeId = id; },
                setNodes(nodes) { this.conversationNodes = nodes; }
            });


            // Define the main component data
            Alpine.data('mcpClientUI', () => ({
                // --- STATE ---
                servers: [],
                discoveredServers: [],
                tools: [],
                resources: [],
                prompts: [],
                currentConversation: [],
                // conversationNodes and currentNodeId are accessed via $store.conversation
                config: { apiKey: '', defaultModel: 'claude-3-5-sonnet-20240620', maxTokens: 4096, temperature: 0.7, enableStreaming: true, enableCaching: true, autoDiscover: true, enableLocalDiscovery: true, dashboardRefreshRate: 2.0 },
                availableModels: ['claude-3-opus-20240229', 'claude-3-5-sonnet-20240620', 'claude-3-haiku-20240307'],
                currentModel: 'claude-3-5-sonnet-20240620',
                userInput: '',
                isLoading: false, // General non-chat loading
                isLoadingServers: false,
                isLoadingTools: false,
                isLoadingDiscovery: false,
                isLoadingImport: false,
                isSendingMessage: false, // Specific for chat send/response cycle
                activeTab: 'servers',
                showAddServerModal: false,
                showToolDetailsModal: false,
                selectedTool: null,
                newServer: { name: '', type: 'stdio', path: '', argsString: '' },
                notifications: [],
                availableThemes: ["light", "dark", "cupcake", "bumblebee", "emerald", "corporate", "synthwave", "retro", "cyberpunk", "valentine", "halloween", "garden", "forest", "aqua", "lofi", "pastel", "fantasy", "wireframe", "black", "luxury", "dracula", "cmyk", "autumn", "business", "acid", "lemonade", "night", "coffee", "winter"],
                currentTheme: 'light',
                capabilitySearchTerm: '',
                // --- WebSocket State ---
                ws: null, wsConnected: false, wsConnecting: false, wsStatus: 'Disconnected', wsReconnectAttempts: 0,
                currentStatusMessage: null, currentAssistantMessageId: null,
                // --- Direct Tool Execution ---
                directToolParams: '{}', directToolResult: null, directToolError: null, isLoadingDirectTool: false,
                // --- Discovery State ---
                discoveredServers: [], // Array to hold raw data fetched from API
                discoveredServersTable: null, // Will hold the Tabulator table instance                
                // --- Misc ---
                saveConfigTimer: null,
                stopController: null, // AbortController for stopping generation
                // --- Cache State ---
                cacheEntries: [],
                cacheDependencies: {},
                isLoadingCache: false,
                cacheEntriesTable: null,
                cacheDepsTable: null,
                showServerDetailsModal: false,
                isLoadingServerDetails: false,
                selectedServerDetails: null,

                // --- COMPUTED PROPERTIES ---
                get connectedServersCount() { return this.servers.filter(s => s.isConnected).length; },
                get currentModelShort() { if (!this.currentModel) return 'N/A'; return this.currentModel.split(/[-:]/).slice(0, 3).join('-').replace('-latest', '').substring(0, 25); },
                // Access store data directly where needed in templates using $store.conversation.currentNodeId etc.
                // Keep getters for data owned by this component
                get conversationNodes() { return Alpine.store('conversation').conversationNodes; },
                get currentNodeId() { return Alpine.store('conversation').currentNodeId; },

                get filteredServerCapabilities() {
                    const searchTerm = this.capabilitySearchTerm.toLowerCase().trim();
                    // Combine all capabilities, adding type and shortName
                    const allCapabilities = [
                        ...(this.tools || []).map(t => ({ ...t, type: 'tool', shortName: t.name.split(':').pop() })),
                        ...(this.resources || []).map(r => ({ ...r, type: 'resource', shortName: r.name.split(':').pop() })),
                        ...(this.prompts || []).map(p => ({ ...p, type: 'prompt', shortName: p.name.split(':').pop() }))
                    ];

                    const grouped = {};

                    // Group by server name
                    allCapabilities.forEach(cap => {
                        const serverName = cap.server_name;
                        if (!serverName) { // Handle potential missing server_name
                            console.warn("Capability missing server_name:", cap);
                            return;
                        }
                        if (!grouped[serverName]) {
                            grouped[serverName] = { serverName: serverName, tools: [], resources: [], prompts: [] };
                        }
                        // Add to the correct array within the group
                        if (cap.type === 'tool') grouped[serverName].tools.push(cap);
                        else if (cap.type === 'resource') grouped[serverName].resources.push(cap);
                        else if (cap.type === 'prompt') grouped[serverName].prompts.push(cap);
                    });

                    // Apply filtering to groups
                    const filteredGroups = Object.values(grouped).filter(group => {
                        if (!searchTerm) return true; // Keep group if no search term

                        // Keep group if server name matches
                        if (group.serverName.toLowerCase().includes(searchTerm)) {
                            return true;
                        }

                        // Keep group if any capability within it matches
                        const capabilitiesInGroup = [...group.tools, ...group.resources, ...group.prompts];
                        return capabilitiesInGroup.some(cap =>
                            (cap.name && cap.name.toLowerCase().includes(searchTerm)) ||
                            (cap.shortName && cap.shortName.toLowerCase().includes(searchTerm)) ||
                            (cap.description && cap.description.toLowerCase().includes(searchTerm)) ||
                            (cap.template && typeof cap.template === 'string' && cap.template.toLowerCase().includes(searchTerm)) // Check resource template
                        );
                    }).map(group => {
                        // If filtering, also filter capabilities *within* the matching group
                        if (searchTerm) {
                            const filterFn = cap =>
                                (cap.name && cap.name.toLowerCase().includes(searchTerm)) ||
                                (cap.shortName && cap.shortName.toLowerCase().includes(searchTerm)) ||
                                (cap.description && cap.description.toLowerCase().includes(searchTerm)) ||
                                (cap.template && typeof cap.template === 'string' && cap.template.toLowerCase().includes(searchTerm)); // Also check template here

                            return {
                                ...group,
                                tools: group.tools.filter(filterFn),
                                resources: group.resources.filter(filterFn),
                                prompts: group.prompts.filter(filterFn)
                            };
                        }
                        return group; // Return unmodified group if no search term
                    });

                    // Sort server groups alphabetically
                    filteredGroups.sort((a, b) => a.serverName.localeCompare(b.serverName));

                    // Sort capabilities within each group alphabetically by short name
                    filteredGroups.forEach(group => {
                        group.tools.sort((a, b) => a.shortName.localeCompare(b.shortName));
                        group.resources.sort((a, b) => a.shortName.localeCompare(b.shortName));
                        group.prompts.sort((a, b) => a.shortName.localeCompare(b.shortName));
                    });

                    return filteredGroups;
                },

                // Utility to get total capabilities count for display
                get totalCapabilities() {
                    return (this.tools?.length || 0) + (this.resources?.length || 0) + (this.prompts?.length || 0);
                },

                // Helper to get server object by name (used for status icon in capabilities tab)
                getServerByName(name) {
                    return this.servers.find(s => s.name === name);
                },

                // --- LIFECYCLE & INITIALIZATION ---
                init() {
                    console.log('MCP Client UI InitializingAlpine Component...');
                    try {
                        this.loadTheme(); // Load theme first
                        this.loadConfig(); // Load config, potentially overriding default model
                        // Ensure currentModel reflects loaded config or default
                        this.currentModel = this.config.defaultModel || 'claude-3-5-sonnet-20240620';

                        this.fetchInitialData();
                        this.connectWebSocket();
                        this.initTippy(); // Initialize Tippy globally

                        // Watchers for dynamic content updates needing Tippy/Highlighting
                        this.$watch('servers', () => this.$nextTick(() => this.initTippy()));
                        this.$watch('activeTab', (newTab) => {
                            this.$nextTick(() => this.initTippy());
                            if (newTab === 'config' && !this.isLoadingCache) { // <<< ADD THIS CONDITION
                                this.fetchCacheData(); // Fetch cache data when switching to config tab
                            }
                        });
                        this.$watch('activeTab', (newTab) => {
                            console.log(`Tab changed to: ${newTab}`); // Debug log
                            this.$nextTick(() => {
                                this.initTippy(); // Re-init tippy for any tab change
                                // Fetch data and initialize/update tables ONLY when config tab is selected
                                if (newTab === 'config' && !this.isLoadingCache) {
                                    console.log("Config tab active, fetching cache data...");
                                    this.fetchCacheData(); // Fetch cache data which will then init/update tables
                                } else if (newTab !== 'config') {
                                    // Optional: Destroy tables when navigating away to free resources?
                                    // if (this.cacheEntriesTable) { this.cacheEntriesTable.destroy(); this.cacheEntriesTable = null; }
                                    // if (this.cacheDepsTable) { this.cacheDepsTable.destroy(); this.cacheDepsTable = null; }
                                }
                            });
                        });
                        this.$el.addEventListener('checkout-branch', (event) => {
                            // Add log to confirm listener fires
                            console.log('checkout-branch event received, ID:', event.detail?.id);
                            if (event.detail?.id) {
                                this.checkoutBranch(event.detail.id);
                            } else {
                                console.error("checkout-branch event received without ID in detail.");
                            }
                        });

                        // Watch conversation changes for highlighting new messages
                        this.$watch('currentConversation', (newVal, oldVal) => {
                            // Only highlight if the length changed or last message content updated significantly
                            if (newVal.length !== oldVal.length || (newVal.length > 0 && newVal[newVal.length - 1].content !== oldVal[oldVal.length - 1]?.content)) {
                                this.$nextTick(() => this.initHighlighting(this.$refs.chatbox));
                            }
                        }, { deep: true });

                        // Set initial focus in Add Server Modal when shown
                        this.$watch('showAddServerModal', (value) => {
                            if (value) { this.$nextTick(() => this.$refs.addServerNameInput?.focus()); }
                        });

                        this.addMessageToConversation('system', 'Welcome! Connecting to backend...');

                        // Setup dynamic Highlight.js theme switching
                        this.setupHljsThemeSwitcher();

                        console.log('MCP Client UI Component Initialized Successfully.');

                    } catch (e) {
                        console.error("Error during MCP Client UI init:", e);
                        this.addNotification("UI Initialization Error. Check console.", "error", 10000);
                    }
                }, // End init

                setupHljsThemeSwitcher() {
                    const lightThemeLink = document.getElementById('hljs-theme-light');
                    const darkThemeLink = document.getElementById('hljs-theme-dark');
                    if (!lightThemeLink || !darkThemeLink) {
                        console.warn("Highlight.js theme links not found.");
                        return;
                    }
                    const matcher = window.matchMedia('(prefers-color-scheme: dark)');
                    const updateHljsTheme = (isSystemDark) => {
                        // Determine if current DaisyUI theme is dark
                        const currentDaisyTheme = document.documentElement.getAttribute('data-theme') || 'light';
                        const isDaisyDark = ['dark', 'synthwave', 'halloween', 'forest', 'black', 'luxury', 'dracula', 'night', 'coffee', 'business'].includes(currentDaisyTheme);

                        // Prefer DaisyUI theme's setting over OS setting
                        lightThemeLink.disabled = isDaisyDark;
                        darkThemeLink.disabled = !isDaisyDark;
                        // console.log(`HighlightJS theme set to: ${isDaisyDark ? 'dark' : 'light'}`);
                    };
                    // Listen to OS changes (optional, as we primarily follow DaisyUI theme)
                    // matcher.addEventListener('change', e => updateHljsTheme(e.matches));
                    // Initial check based on current theme
                    updateHljsTheme(matcher.matches);
                }, // Added comma

                initTippy() {
                    // Destroy previous instances first to avoid duplicates
                    if (this._tippyInstances) {
                        this._tippyInstances.forEach(instance => instance.destroy());
                    }
                    this._tippyInstances = tippy('[data-tippy-content]', {
                        animation: 'scale',
                        theme: document.documentElement.getAttribute('data-theme') === 'light' ? 'dark' : 'light',
                        arrow: true,
                        allowHTML: true,
                        interactive: false,
                        placement: 'top',
                        // Delay prevents flickering on quick mouseovers
                        delay: [150, 0], // 150ms delay on show, 0ms on hide
                        onCreate(instance) {
                            // Workaround for Tippy/Tailwind JIT issue where max-width might not apply initially
                            instance.popper.style.maxWidth = '300px';
                        }
                    });
                }, // Added comma

                initHighlighting(container = document) {
                    this.$nextTick(() => { // Ensure DOM is updated
                        if (typeof hljs === 'undefined') {
                            console.warn("highlight.js not loaded.");
                            return;
                        }
                        // Use try-catch for safety during highlighting
                        try {
                            const blocks = container.querySelectorAll('pre code:not(.hljs)');
                            // console.log(`Attempting to highlight ${blocks.length} blocks in:`, container);
                            blocks.forEach((block) => {
                                // Prevent re-highlighting if it somehow still has the class
                                if (!block.classList.contains('hljs')) {
                                    hljs.highlightElement(block);
                                    // Add copy button if missing (robust check)
                                    const preElement = block.closest('pre');
                                    if (preElement && !preElement.querySelector('.copy-code-btn')) {
                                        const codeContent = block.textContent || "";
                                        const copyBtnHtml = createCopyButton(codeContent); // Generate button HTML
                                        if (copyBtnHtml !== '<!-- copy error -->') {
                                            preElement.insertAdjacentHTML('beforeend', copyBtnHtml);
                                        }
                                    }
                                }
                            });
                        } catch (e) {
                            console.error("Error during highlighting:", e);
                        }
                    });
                }, // Added comma


                // --- THEME ---
                loadTheme() { const savedTheme = localStorage.getItem('mcp_client_theme') || 'light'; this.setTheme(savedTheme, false); },
                setTheme(themeName, save = true) {
                    this.currentTheme = themeName;
                    document.documentElement.setAttribute('data-theme', themeName);
                    if (save) localStorage.setItem('mcp_client_theme', themeName);
                    // Update hljs theme link based on the chosen DaisyUI theme
                    this.setupHljsThemeSwitcher(); // Use the dedicated function

                    this.$nextTick(() => this.initTippy()); // Re-init tippy after theme change
                }, // Added comma

                // --- API & WebSocket ---
                async apiFetch(endpoint, options = {}) {
                    // Indicate loading state - use global isLoading for now
                    this.isLoading = true;
                    // Use a local AbortController if one isn't passed or managed globally
                    const controller = this.stopController || new AbortController();
                    const signal = controller.signal;

                    try {
                        const response = await fetch(`${API_BASE_URL}${endpoint}`, {
                            signal: signal, // Pass the signal
                            headers: { 'Content-Type': 'application/json', ...options.headers },
                            ...options,
                        });

                        if (response.status === 499) { // Specific code for client cancellation often used by Nginx etc.
                            throw new Error('Request cancelled by client.');
                        }
                        if (!response.ok) {
                            let errorDetail = `HTTP ${response.status}: ${response.statusText}`;
                            try { const errJson = await response.json(); errorDetail = errJson.detail || JSON.stringify(errJson); }
                            catch (e) { /* ignore JSON parsing error on error response */ }
                            throw new Error(errorDetail);
                        }
                        if (response.status === 204 || response.headers.get('content-length') === '0') {
                            return null; // Handle No Content response
                        }
                        return await response.json(); // Parse JSON body
                    } catch (error) {
                        if (error.name === 'AbortError') {
                            console.log(`API Fetch Aborted (${endpoint})`);
                            this.addNotification('Request cancelled.', 'warning');
                        } else {
                            console.error(`API Fetch Error (${endpoint}):`, error);
                            this.addNotification(`API Error: ${error.message}`, 'error');
                        }
                        throw error; // Re-throw for specific handlers if needed
                    } finally {
                        this.isLoading = false; // Stop loading indicator
                    }
                }, // Added comma

                connectWebSocket() {
                    if (this.wsConnected || this.wsConnecting) return;
                    console.log('Attempting WebSocket connection...');
                    this.wsConnecting = true;
                    this.wsStatus = 'Connecting...';
                    this.wsConnected = false; // Explicitly set false before attempting

                    try {
                        this.ws = new WebSocket(WS_URL);
                    } catch (e) {
                        console.error("WebSocket creation failed:", e);
                        this.wsConnecting = false;
                        this.wsStatus = 'Error (Creation Failed)';
                        this.addNotification('Failed to create WebSocket connection.', 'error');
                        return;
                    }

                    this.ws.onopen = () => {
                        console.log('WebSocket Connected!');
                        this.wsConnected = true;
                        this.wsConnecting = false;
                        this.wsStatus = 'Connected';
                        this.wsReconnectAttempts = 0;
                        this.addNotification('Chat connected.', 'success', 1500);
                    };

                    this.ws.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);
                            // console.debug("WS Received:", message); // Keep for debugging
                            this.handleWebSocketMessage(message);
                        } catch (e) {
                            console.error('Failed to parse WebSocket message:', e, event.data);
                        }
                    };

                    this.ws.onerror = (error) => {
                        console.error('WebSocket Error:', error);
                        this.wsStatus = 'Error';
                        this.addNotification('Chat connection error.', 'error');
                        this.wsConnected = false;
                        this.wsConnecting = false;
                        // The 'close' event will handle reconnection logic
                    };

                    this.ws.onclose = (event) => {
                        console.log(`WebSocket Closed: Code=${event.code}, Reason=${event.reason}, WasClean=${event.wasClean}`);
                        this.wsConnected = false;
                        this.wsConnecting = false;
                        this.wsStatus = `Disconnected (Code: ${event.code})`;
                        this.currentAssistantMessageId = null; // Reset stream tracking
                        this.isSendingMessage = false; // Ensure loading state is reset
                        this.isLoading = false;
                        this.currentStatusMessage = null;

                        // Implement reconnection logic only if not intentionally closed (e.g., code 1000/1001 might be normal)
                        if (event.code !== 1000 && event.code !== 1001) {
                            if (this.wsReconnectAttempts < 5) { // Limit retries
                                this.wsReconnectAttempts++;
                                const delay = Math.min(30000, Math.pow(2, this.wsReconnectAttempts) * 1000); // Exponential backoff up to 30s
                                this.addNotification(`Chat disconnected. Retrying in ${delay / 1000}s...`, 'warning');
                                console.log(`WebSocket reconnect attempt ${this.wsReconnectAttempts} in ${delay}ms`);
                                setTimeout(() => this.connectWebSocket(), delay);
                            } else {
                                this.addNotification('Chat disconnected. Max retries reached.', 'error');
                                console.error('WebSocket max reconnect attempts reached.');
                                this.wsStatus = 'Disconnected (Max Retries)';
                            }
                        } else {
                            this.addNotification('Chat connection closed.', 'info');
                            this.wsStatus = 'Disconnected';
                        }
                    };
                }, // Added comma

                sendWebSocketMessage(message) {
                    if (this.ws && this.wsConnected) {
                        try {
                            // console.debug("WS Sent:", message); // Keep for debugging
                            this.ws.send(JSON.stringify(message));
                        } catch (e) {
                            console.error("Failed to send WebSocket message:", e);
                            this.addNotification('Failed to send message.', 'error');
                            // Consider attempting to reconnect if send fails due to closed state
                            if (this.ws.readyState === WebSocket.CLOSED || this.ws.readyState === WebSocket.CLOSING) {
                                this.connectWebSocket();
                            }
                        }
                    } else {
                        this.addNotification('Chat not connected. Cannot send message.', 'error');
                        console.warn('WebSocket not connected, cannot send:', message);
                        // Attempt to reconnect if user tries to send while disconnected
                        if (!this.wsConnecting) {
                            this.connectWebSocket();
                        }
                    }
                }, // Added comma

                handleWebSocketMessage(message) {
                    let assistantMsg = this.currentConversation.find(m => m.id === this.currentAssistantMessageId);
                    const backendMessageId = message.message_id;

                    if (backendMessageId && (!assistantMsg || assistantMsg.id !== backendMessageId)) {
                        const existingMsg = this.currentConversation.find(m => m.id === backendMessageId);
                        if (existingMsg) {
                            assistantMsg = existingMsg;
                            this.currentAssistantMessageId = backendMessageId;
                        } else if (['stream_start', 'text_chunk', 'status', 'tool_call'].includes(message.type)) {
                            assistantMsg = { role: 'assistant', content: '', id: backendMessageId, timestamp: new Date().toISOString(), current_status: null, model: this.currentModelShort };
                            this.currentConversation.push(assistantMsg);
                            this.currentAssistantMessageId = backendMessageId;
                        }
                    }

                    switch (message.type) {
                        case 'text_chunk':
                            if (assistantMsg) {
                                let chunkText = message.payload;
                                if (typeof chunkText !== 'string') {
                                    console.warn('Non-string text_chunk received, stringifying:', chunkText);
                                    chunkText = JSON.stringify(chunkText, null, 2);
                                }
                                if (typeof assistantMsg.content !== 'string') {
                                    assistantMsg.content.push({ type: 'text', text: chunkText });
                                } else {
                                    assistantMsg.content += chunkText;
                                }
                                assistantMsg.current_status = null;
                            }
                            this.scrollToBottom();
                            break;
                        case 'tool_result_chunk':
                            if (assistantMsg) {
                                let chunkText = message.payload.content_chunk;
                                if (typeof chunkText !== 'string') {
                                    console.warn('Non-string tool_result_chunk received, stringifying:', chunkText);
                                    chunkText = JSON.stringify(chunkText, null, 2);
                                }
                                const resultPrefix = `\nTool Result Chunk (for ...${(message.payload.tool_use_id || '').slice(-4)}): `;
                                if (typeof assistantMsg.content === 'string') {
                                    assistantMsg.content += resultPrefix + chunkText;
                                } else if (Array.isArray(assistantMsg.content)) {
                                    const lastBlock = assistantMsg.content[assistantMsg.content.length - 1];
                                    if (lastBlock?.type === 'text') {
                                        lastBlock.text += (lastBlock.text.includes('Tool Result Chunk') ? '' : resultPrefix) + chunkText;
                                    } else {
                                        assistantMsg.content.push({ type: 'text', text: resultPrefix + chunkText });
                                    }
                                }
                                assistantMsg.current_status = `Receiving result for tool...`;
                            }
                            this.scrollToBottom();
                            break;
                        case 'query_complete':
                        case 'stream_end': // Treat stream_end like query_complete
                            this.isSendingMessage = false;
                            this.isLoading = false;
                            this.currentStatusMessage = null; // Clear transient status
                            this.currentAssistantMessageId = null; // Ready for next message
                            if (assistantMsg) assistantMsg.current_status = null; // Clear status on final message
                            this.$nextTick(() => this.initHighlighting(this.$refs.chatbox)); // Highlight final code
                            break;
                        case 'error':
                            this.addNotification(`Backend Error: ${message.payload}`, 'error');
                            this.isSendingMessage = false;
                            this.isLoading = false;
                            this.currentStatusMessage = null;
                            this.currentAssistantMessageId = null;
                            // Add a system message to the chat about the error
                            this.addMessageToConversation('system', `Error processing last request: ${message.payload}`);
                            break;
                        case 'state_update': // Handle full state updates if backend sends them
                            console.log("Received state update:", message.payload);
                            if (message.payload.servers) this.servers = message.payload.servers;
                            if (message.payload.tools) this.tools = message.payload.tools;
                            if (message.payload.resources) this.resources = message.payload.resources;
                            if (message.payload.prompts) this.prompts = message.payload.prompts;
                            if (message.payload.conversation) {
                                this.currentConversation = message.payload.conversation.messages || [];
                                console.log('WS state_update is SETTING nodes:', JSON.stringify(message.payload.conversation.nodes || []));
                                Alpine.store('conversation').setNodes(message.payload.conversation.nodes || [{ id: 'root', name: 'Root', parentId: null, childrenIds: [] }]);
                                Alpine.store('conversation').setCurrentNodeId(message.payload.conversation.currentNodeId || 'root');
                                this.currentModel = message.payload.conversation.model || this.config.defaultModel;
                                this.scrollToBottom();
                                this.$nextTick(() => this.initHighlighting(this.$refs.chatbox)); // Highlight potentially new messages
                            }
                            if (message.payload.config) {
                                this.config = { ...this.config, ...message.payload.config };
                                this.currentModel = this.config.defaultModel || 'claude-3-5-sonnet-20240620'; // Update model from config if needed
                            }
                            this.$nextTick(() => this.initTippy()); // Re-init Tippy after state update
                            break;
                        case 'command_response': // Generic response for non-chat commands
                            this.addNotification(message.payload.message || JSON.stringify(message.payload), message.payload.success ? 'success' : 'info');
                            break;
                        default:
                            console.warn('Received unknown WebSocket message type:', message.type, message);
                    }

                    if (message.type === 'tool_result' ||
                        (Array.isArray(message.payload) && message.payload.some(item => item?.type === 'tool_result'))) {

                        // Only add this as assistant content, not as a new user message
                        if (assistantMsg) {
                            // Add to assistant message directly
                            if (Array.isArray(assistantMsg.content)) {
                                assistantMsg.content.push(...message.payload);
                            } else if (typeof assistantMsg.content === 'string') {
                                // If content was a string, convert to block format
                                assistantMsg.content = [
                                    { type: 'text', text: assistantMsg.content },
                                    ...message.payload
                                ];
                            }
                            this.currentConversation = [...this.currentConversation];
                            return; // Skip adding as a separate message
                        }
                    }

                    // Ensure the list reference updates for Alpine's reactivity if modifying nested props
                    this.currentConversation = [...this.currentConversation];
                },


                // --- DATA FETCHING ---
                async fetchInitialData() {
                    this.isLoadingServers = true;
                    this.isLoadingTools = true;
                    try {
                        console.log("Fetching initial data...");
                        // Use Promise.allSettled to allow partial success
                        const results = await Promise.allSettled([
                            this.fetchServers(),
                            this.fetchCapabilities(),
                            this.fetchConversation()
                        ]);
                        console.log("Initial data fetch results:", results);

                        // Check results and report errors
                        results.forEach((result, index) => {
                            if (result.status === 'rejected') {
                                const endpoint = ['servers', 'capabilities', 'conversation'][index];
                                console.error(`Initial fetch failed for ${endpoint}:`, result.reason);
                                this.addNotification(`Failed to fetch initial ${endpoint}.`, 'error');
                            }
                        });

                        // Only add "Ready" message if essential data (like conversation) loaded.
                        if (results[2].status === 'fulfilled') {
                            this.addMessageToConversation('system', 'Backend connected. Ready.');
                        } else {
                            this.addMessageToConversation('system', 'Connected, but failed to load conversation state.');
                        }

                    } catch (error) {
                        // This catch is less likely with Promise.allSettled but good practice
                        console.error("Unexpected error during initial data fetch:", error);
                        this.addMessageToConversation('system', `Failed to connect or fetch initial data: ${error.message}`);
                    } finally {
                        this.isLoadingServers = false;
                        this.isLoadingTools = false;
                    }
                }, // Added comma

                async fetchServers() {
                    this.isLoadingServers = true; // Indicate loading specifically for servers
                    try {
                        const serversData = await this.apiFetch('/servers');
                        this.servers = serversData || []; // Ensure servers is always an array
                    } catch (e) {
                        this.servers = []; // Reset on error
                        // Error notification is handled by apiFetch
                    } finally {
                        this.isLoadingServers = false;
                    }
                }, // Added comma

                async fetchServerDetails(serverName) {
                    if (!serverName) return;
                    console.log(`Fetching details for server: ${serverName}`);
                    this.isLoadingServerDetails = true;
                    this.selectedServerDetails = null; // Clear previous details
                    this.showServerDetailsModal = true; // Open modal immediately

                    try {
                        const details = await this.apiFetch(`/servers/${encodeURIComponent(serverName)}/details`);
                        this.selectedServerDetails = details;
                        // Re-init Tippy if needed after modal content updates
                        this.$nextTick(() => this.initTippy());
                    } catch (e) {
                        this.addNotification(`Failed to load details for ${serverName}: ${e.message}`, 'error');
                        this.selectedServerDetails = null; // Ensure it's null on error
                        // Keep modal open to show error message inside? Or close it? Let's keep it open.
                    } finally {
                        this.isLoadingServerDetails = false;
                    }
                },

                // --- NEW: DISCOVERY METHODS ---
                async triggerDiscovery() {
                    // This now triggers the consolidated backend discovery
                    if (this.isLoadingDiscovery) return;
                    console.log(`Triggering consolidated server discovery via API...`);
                    this.isLoadingDiscovery = true;
                    this.discoveredServers = []; // Clear previous results immediately
                    if (this.discoveredServersTable) {
                        this.discoveredServersTable.clearData(); // Clear Tabulator table
                        this.discoveredServersTable.setPlaceholder("Scanning network..."); // Update placeholder
                    }
                    this.addNotification('Starting network server discovery scan...', 'info', 2500);
                    try {
                        // Call the single trigger endpoint
                        await this.apiFetch('/discover/trigger', { method: 'POST' });
                        // Wait a reasonable time for discovery to finish on backend.
                        // Adjust delay based on typical scan time (mDNS/Port Scan can take longer)
                        await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds
                        await this.fetchDiscoveryResults(); // Fetch results after waiting
                    } catch (e) {
                        this.addNotification(`Failed to initiate discovery scan: ${e.message}`, 'error');
                        this.isLoadingDiscovery = false; // Ensure loading stops on trigger error
                        if (this.discoveredServersTable) {
                            this.discoveredServersTable.setPlaceholder("Discovery failed.");
                        }
                    }
                    // isLoadingDiscovery is set to false by fetchDiscoveryResults' finally block
                },

                async fetchDiscoveryResults() {
                    console.log("Fetching discovery results for Tabulator...");
                    try {
                        const results = await this.apiFetch('/discover/results');
                        // Store raw data - Tabulator will use this
                        this.discoveredServers = results || [];
                        console.log(`Found ${this.discoveredServers.length} discovered servers.`);

                        // Initialize or update Tabulator table using the data
                        this.initOrUpdateDiscoveredTable();

                    } catch (e) {
                        this.addNotification(`Failed to fetch discovery results: ${e.message}`, 'error');
                        this.discoveredServers = []; // Clear data on error
                        if (this.discoveredServersTable) {
                            this.discoveredServersTable.clearData(); // Clear table too
                            this.discoveredServersTable.setPlaceholder("Error fetching results.");
                        }
                    } finally {
                        this.isLoadingDiscovery = false; // Stop loading indicator *after* fetching/rendering
                    }
                },

                // Tabulator Initialization/Update Function
                initOrUpdateDiscoveredTable() {
                    const tableElement = document.getElementById('discovered-servers-table');
                    if (!tableElement) {
                        console.warn("Tabulator container '#discovered-servers-table' not found in DOM yet.");
                        return;
                    }

                    // --- Define Tabulator Columns ---
                    const columns = [
                        { // Icon column
                            title: "", hozAlign: "center", width: 40, headerSort: false, cssClass: "p-1", frozen: true,
                            formatter: (cell) => `<i class="${this.serverTypeIcon(cell.getRow().getData().type)} opacity-80 text-base"></i>`
                        },
                        { title: "Name", field: "name", minWidth: 120, sorter: "string", headerFilter: "input", cssClass: "p-1 font-medium", tooltip: (cell) => cell.getValue() },
                        { title: "Path / URL", field: "path_or_url", minWidth: 180, sorter: "string", headerFilter: "input", cssClass: "p-1 text-base-content/70", tooltip: (cell) => cell.getValue() },
                        { // Source Badge column
                            title: "Source", field: "source", sorter: "string", headerFilter: "select", headerFilterParams: { values: ["", "filesystem", "registry", "mdns", "portscan"] }, width: 90, hozAlign: "center", cssClass: "p-1",
                            formatter: (cell) => `<span class="badge badge-xs capitalize ${this.discoverySourceColor(cell.getValue())}">${cell.getValue() || 'N/A'}</span>`
                        },
                        { // Action Button column
                            title: "Action", hozAlign: "center", width: 70, headerSort: false, cssClass: "p-1",
                            formatter: (cell) => {
                                const serverData = cell.getRow().getData();
                                const isDisabled = serverData.is_configured;
                                const uniqueId = `add-disc-btn-${cell.getRow().getIndex()}`;
                                // Use data attributes to store necessary info for the click handler
                                return `
                                    <button id="${uniqueId}"
                                            class="btn btn-xs btn-outline btn-success p-1"
                                            ${isDisabled ? 'disabled' : ''}
                                            data-tippy-content="${serverData.is_configured ? 'Already Configured' : 'Add & Connect'}"
                                            data-server-info="${encodeURIComponent(JSON.stringify(serverData))}"
                                            >
                                        <i class="fas fa-plus"></i>
                                    </button>
                                `;
                            },
                            cellClick: (e, cell) => { // Handle clicks within the cell
                                const button = e.target.closest('button'); // Find the clicked button
                                if (button && !button.disabled) { // If a non-disabled button was clicked
                                    const serverInfoEncoded = button.getAttribute('data-server-info');
                                    if (serverInfoEncoded) {
                                        try {
                                            const serverData = JSON.parse(decodeURIComponent(serverInfoEncoded));
                                            // Call the Alpine method, passing the button for state changes
                                            this.addAndConnectDiscoveredServer(serverData, button);
                                        } catch (parseError) {
                                            console.error("Error parsing server data from button:", parseError);
                                            this.addNotification("Internal UI error processing discovered server.", "error");
                                        }
                                    }
                                }
                            }
                        }
                    ]; // End columns definition

                    // --- Initialize or Update Table ---
                    const placeholderText = this.isLoadingDiscovery ? "Scanning..." : "No new servers found.";
                    if (this.discoveredServersTable) {
                        console.log("Tabulator: Updating data");
                        this.discoveredServersTable.setPlaceholder(placeholderText);
                        this.discoveredServersTable.setData(this.discoveredServers)
                            .then(() => { this.$nextTick(() => this.initTippy()); }) // Re-init tippy after data update
                            .catch(err => console.error("Tabulator setData error:", err));
                    } else {
                        console.log("Tabulator: Initializing new table");
                        try {
                            this.discoveredServersTable = new Tabulator("#discovered-servers-table", {
                                data: this.discoveredServers,
                                layout: "fitDataStretch",
                                placeholder: placeholderText,
                                height: "12rem",
                                // virtualDom: true, // Enable if expecting many results
                                // virtualDomBuffer: 300,
                                responsiveLayout: "hide", // Hide columns that don't fit
                                columns: columns,
                                initialSort: [{ column: "name", dir: "asc" }],
                                tableBuilt: () => { this.$nextTick(() => this.initTippy()); },
                            });
                        } catch (err) {
                            console.error("Failed to initialize Tabulator:", err);
                            this.addNotification("Error initializing discovery table.", "error");
                        }
                    }
                    // Ensure tippy runs after table potentially renders/updates outside the promises too
                    this.$nextTick(() => this.initTippy());
                }, // End initOrUpdateDiscoveredTable

                // Modified addAndConnect to handle button loading state
                async addAndConnectDiscoveredServer(dServer, buttonElement = null) {
                    if (!dServer || dServer.is_configured) return;

                    this.addNotification(`Adding & connecting to ${dServer.name}...`, 'info');

                    let originalButtonContent = null;
                    if (buttonElement) {
                        originalButtonContent = buttonElement.innerHTML;
                        buttonElement.classList.add('loading');
                        buttonElement.disabled = true;
                        buttonElement.innerHTML = ''; // Clear icon
                    } else {
                        this.isLoading = true; // Fallback global loading
                    }

                    try {
                        // Construct payload carefully matching the Pydantic model on backend
                        const payload = {
                            name: dServer.name,
                            type: dServer.type,
                            path_or_url: dServer.path_or_url, // Ensure this matches backend expectation
                            source: dServer.source,
                            description: dServer.description,
                            version: dServer.version,
                            categories: dServer.categories || [],
                            is_configured: dServer.is_configured // Send current state
                        };
                        const result = await this.apiFetch('/discover/connect', {
                            method: 'POST',
                            body: JSON.stringify(payload)
                        });
                        this.addNotification(result.message || `Successfully processed ${dServer.name}.`, 'success');

                        // Refresh main server list, capabilities, AND discovery results
                        await this.fetchServers();
                        await this.fetchCapabilities();
                        // Re-fetch discovery results - this will update the table and disable the button
                        await this.fetchDiscoveryResults();

                    } catch (e) {
                        this.addNotification(`Failed to add/connect ${dServer.name}: ${e.message}`, 'error');
                        // Reset button state on error only if element was passed
                        if (buttonElement) {
                            buttonElement.classList.remove('loading');
                            // Re-enable button only if it wasn't already configured
                            buttonElement.disabled = dServer.is_configured;
                            buttonElement.innerHTML = originalButtonContent;
                        }
                    } finally {
                        // Ensure global loading is reset if it was used
                        this.isLoading = false;
                        // Button state is reset on error above, or implicitly handled by
                        // fetchDiscoveryResults on success (which rebuilds the table)
                    }
                },

                async reloadAllServers() {
                    if (this.isLoadingServers) return;
                    if (confirm("This will disconnect and attempt to reconnect all configured servers, reloading their capabilities. Proceed?")) {
                        console.log("Reloading all servers via API...");
                        this.isLoadingServers = true; // Use server loading flag
                        this.addNotification("Reloading all servers...", "info");
                        // Clear current UI state immediately for better feedback
                        this.servers = [];
                        this.tools = [];
                        this.resources = [];
                        this.prompts = [];
                        try {
                            const result = await this.apiFetch('/runtime/reload', { method: 'POST' });
                            this.addNotification(result.message || "Server reload complete.", "success");
                        } catch (e) {
                            this.addNotification(`Server reload failed: ${e.message}`, "error");
                        } finally {
                            // Always refresh state after attempt
                            await this.fetchServers();
                            await this.fetchCapabilities();
                            this.isLoadingServers = false;
                        }
                    }
                },

                // Utility function for server type icons (ADD this or ensure it exists)
                serverTypeIcon(type) {
                    switch (type?.toLowerCase()) {
                        case 'stdio': return 'fas fa-terminal text-accent';
                        case 'sse': return 'fas fa-network-wired text-info';
                        default: return 'fas fa-question-circle text-base-content/40';
                    }
                },

                // Utility function for discovery source badge colors (ADD this or ensure it exists)
                discoverySourceColor(source) {
                    switch (source?.toLowerCase()) {
                        case 'filesystem': return 'badge-neutral';
                        case 'registry': return 'badge-secondary';
                        case 'mdns': return 'badge-accent';
                        case 'portscan': return 'badge-warning';
                        default: return 'badge-ghost';
                    }
                },

                async fetchCacheData() {
                    if (this.isLoadingCache) return;
                    // Ensure the tab is actually active before fetching/rendering
                    if (this.activeTab !== 'config') {
                        console.log("fetchCacheData called but config tab not active. Skipping.");
                        return;
                    }
                    console.log("Fetching cache data...");
                    this.isLoadingCache = true;
                    // Clear tables immediately while loading (Tabulator handles placeholder)
                    if (this.cacheEntriesTable) this.cacheEntriesTable.clearData();
                    if (this.cacheDepsTable) this.cacheDepsTable.clearData();

                    try {
                        const results = await Promise.allSettled([
                            this.apiFetch('/cache/entries'),
                            this.apiFetch('/cache/dependencies')
                        ]);

                        if (results[0].status === 'fulfilled') {
                            this.cacheEntries = results[0].value || [];
                            this.initOrUpdateCacheEntriesTable(); // Update/init table
                        } else {
                            this.addNotification('Failed to fetch cache entries.', 'error');
                            this.cacheEntries = [];
                            // No setPlaceholder here
                        }

                        if (results[1].status === 'fulfilled' && results[1].value?.dependencies) {
                            this.cacheDependencies = results[1].value.dependencies;
                            this.initOrUpdateCacheDepsTable(); // Update/init table
                        } else {
                            if (results[1].status === 'rejected') {
                                this.addNotification('Failed to fetch cache dependencies.', 'error');
                            }
                            this.cacheDependencies = {};
                            // No setPlaceholder here
                        }
                    } catch (e) {
                        console.error("Unexpected error fetching cache data:", e);
                        this.addNotification('Failed to fetch cache data.', 'error');
                    } finally {
                        this.isLoadingCache = false;
                        // Ensure placeholders are set correctly after loading (Tabulator does this)
                        if (this.cacheEntriesTable) this.cacheEntriesTable.setPlaceholder("No cache entries found.");
                        if (this.cacheDepsTable) this.cacheDepsTable.setPlaceholder("No dependencies found.");
                    }
                },

                initOrUpdateCacheEntriesTable() {
                    // Ensure tab is active before trying to init/update
                    if (this.activeTab !== 'config') {
                        console.warn("Attempted to init/update Cache Entries table when tab not active.");
                        return;
                    }
                    const tableId = 'cache-entries-table';
                    const tableElement = document.getElementById(tableId);
                    if (!tableElement) { console.warn(`Tabulator container '#${tableId}' not found.`); return; }

                    const columns = [
                        { title: "Tool Name", field: "tool_name", minWidth: 150, sorter: "string", headerFilter: "input", cssClass: "p-1 font-medium", tooltip: true },
                        { title: "Created At", field: "created_at", width: 140, sorter: "datetime", hozAlign: "center", cssClass: "p-1 text-base-content/70", sorterParams: { format: "iso" }, formatter: "datetime", formatterParams: { outputFormat: "MM/DD HH:mm:ss" }, tooltip: (cell) => { try { return new Date(cell.getValue()).toLocaleString(); } catch { return cell.getValue(); } } },
                        {
                            title: "Expires At", field: "expires_at", width: 140, sorter: "datetime", hozAlign: "center", cssClass: "p-1 text-base-content/70", sorterParams: { format: "iso" },
                            formatter: (cell) => {
                                const value = cell.getValue(); if (!value) return '<span class="italic opacity-50">Never</span>';
                                try { const table = cell.getTable(); if (table && table.modules.format) { return table.modules.format.formatters.datetime(cell, { outputFormat: "MM/DD HH:mm:ss" }); } return new Date(value).toLocaleTimeString([], { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' }); } catch { return value; }
                            },
                            tooltip: (cell) => { try { return cell.getValue() ? new Date(cell.getValue()).toLocaleString() : 'Never'; } catch { return cell.getValue(); } }
                        },
                        { title: "Key Hash", field: "key", minWidth: 100, sorter: "string", headerFilter: "input", cssClass: "p-1 font-mono text-xs opacity-60", formatter: (cell) => cell.getValue().split(':').pop()?.substring(0, 10) + '...' || '', tooltip: (cell) => cell.getValue() },
                        {
                            title: "Clear", hozAlign: "center", width: 60, headerSort: false, cssClass: "p-1",
                            formatter: (cell) => { const toolName = cell.getRow().getData().tool_name; return `<button class="btn btn-xs btn-ghost text-error/70 hover:text-error p-1" data-tool-name="${encodeURIComponent(toolName)}" data-tippy-content="Clear all for '${toolName}'"><i class="fas fa-times"></i></button>`; },
                            cellClick: (e, cell) => { const button = e.target.closest('button'); if (button) { const toolNameEncoded = button.getAttribute('data-tool-name'); if (toolNameEncoded) { this.clearCacheByToolName(decodeURIComponent(toolNameEncoded)); } } }
                        }
                    ];
                    const placeholderText = "No cache entries found.";

                    if (this.cacheEntriesTable) {
                        console.log("Tabulator (Cache Entries): Updating data");
                        this.cacheEntriesTable.setData(this.cacheEntries)
                            .then(() => { this.$nextTick(() => this.initTippy()); })
                            .catch(err => console.error("Tabulator setData (cache entries) error:", err));
                    } else {
                        console.log("Tabulator (Cache Entries): Initializing new table");
                        try {
                            this.cacheEntriesTable = new Tabulator(`#${tableId}`, { data: this.cacheEntries, layout: "fitDataStretch", placeholder: placeholderText, height: "5rem", columns: columns, initialSort: [{ column: "created_at", dir: "desc" }], tableBuilt: () => { this.$nextTick(() => this.initTippy()); }, });
                        } catch (err) { console.error("Failed to initialize Cache Entries Tabulator:", err); this.addNotification("Error initializing cache table.", "error"); }
                    }
                    this.$nextTick(() => this.initTippy());
                },

                initOrUpdateCacheDepsTable() {
                    // Ensure tab is active before trying to init/update
                    if (this.activeTab !== 'config') {
                        console.warn("Attempted to init/update Cache Deps table when tab not active.");
                        return;
                    }
                    const tableId = 'cache-dependencies-table';
                    const tableElement = document.getElementById(tableId);
                    if (!tableElement) { console.warn(`Tabulator container '#${tableId}' not found.`); return; }

                    const tableData = Object.entries(this.cacheDependencies).map(([tool, deps]) => ({ tool: tool, depends_on: Array.isArray(deps) ? deps.join(', ') : '' }));
                    const columns = [{ title: "Tool", field: "tool", minWidth: 180, sorter: "string", headerFilter: "input", cssClass: "p-1 font-medium", tooltip: true }, { title: "Depends On", field: "depends_on", minWidth: 200, sorter: "string", headerFilter: "input", cssClass: "p-1 text-base-content/80", tooltip: true }];
                    const placeholderText = "No dependencies found.";

                    if (this.cacheDepsTable) {
                        console.log("Tabulator (Cache Deps): Updating data");
                        this.cacheDepsTable.setData(tableData)
                            .then(() => { this.$nextTick(() => this.initTippy()); })
                            .catch(err => console.error("Tabulator setData (cache deps) error:", err));
                    } else {
                        console.log("Tabulator (Cache Deps): Initializing new table");
                        try {
                            this.cacheDepsTable = new Tabulator(`#${tableId}`, { data: tableData, layout: "fitDataStretch", placeholder: placeholderText, height: "4rem", columns: columns, initialSort: [{ column: "tool", dir: "asc" }], tableBuilt: () => { this.$nextTick(() => this.initTippy()); }, });
                        } catch (err) { console.error("Failed to initialize Cache Dependencies Tabulator:", err); this.addNotification("Error initializing dependencies table.", "error"); }
                    }
                    this.$nextTick(() => this.initTippy());
                },

                async clearAllCacheAPI() {
                    if (confirm("Are you sure you want to clear the ENTIRE tool result cache?")) {
                        this.isLoadingCache = true;
                        try {
                            const result = await this.apiFetch('/cache/entries', { method: 'DELETE' });
                            this.addNotification(result.message || 'Cache cleared successfully.', 'success');
                            await this.fetchCacheData(); // Refresh view
                        } catch (e) {
                            this.addNotification(`Failed to clear cache: ${e.message}`, 'error');
                        } finally {
                            this.isLoadingCache = false;
                        }
                    }
                },

                async clearSingleCacheEntry(cacheKey) {
                    // Note: The API currently supports clearing by tool_name, not specific key hash.
                    // We'll extract the tool_name from the key.
                    const toolName = cacheKey.split(':')[0];
                    if (!toolName) {
                        this.addNotification('Invalid cache key format.', 'error');
                        return;
                    }

                    if (confirm(`Clear all cache entries for tool "${toolName}"? (Cannot clear single entry via API yet)`)) {
                        this.isLoadingCache = true;
                        try {
                            const endpoint = `/cache/entries/${encodeURIComponent(toolName)}`;
                            const result = await this.apiFetch(endpoint, { method: 'DELETE' });
                            this.addNotification(result.message || `Cache cleared for tool '${toolName}'.`, 'success');
                            await this.fetchCacheData(); // Refresh view
                        } catch (e) {
                            this.addNotification(`Failed to clear cache for '${toolName}': ${e.message}`, 'error');
                        } finally {
                            this.isLoadingCache = false;
                        }
                    }
                },

                async cleanCacheAPI() {
                    if (confirm("Clean expired entries from the cache?")) {
                        this.isLoadingCache = true;
                        try {
                            const result = await this.apiFetch('/cache/clean', { method: 'POST' });
                            this.addNotification(result.message || 'Expired cache entries cleaned.', 'success');
                            await this.fetchCacheData(); // Refresh view
                        } catch (e) {
                            this.addNotification(`Failed to clean cache: ${e.message}`, 'error');
                        } finally {
                            this.isLoadingCache = false;
                        }
                    }
                },

                async fetchCapabilities() {
                    this.isLoadingTools = true; // Use this flag for all capabilities
                    try {
                        // Use allSettled again for resilience
                        const results = await Promise.allSettled([
                            this.apiFetch('/tools'),
                            this.apiFetch('/resources'),
                            this.apiFetch('/prompts')
                        ]);

                        this.tools = results[0].status === 'fulfilled' ? (results[0].value || []) : [];
                        this.resources = results[1].status === 'fulfilled' ? (results[1].value || []) : [];
                        this.prompts = results[2].status === 'fulfilled' ? (results[2].value || []) : [];

                        if (results[0].status === 'rejected') this.addNotification('Failed to load tools.', 'warning');
                        if (results[1].status === 'rejected') this.addNotification('Failed to load resources.', 'warning');
                        if (results[2].status === 'rejected') this.addNotification('Failed to load prompts.', 'warning');

                    } catch (e) {
                        // Should not be reached with allSettled, but safety net
                        this.addNotification('Failed to load capabilities.', 'error');
                        this.tools = []; this.resources = []; this.prompts = [];
                    } finally {
                        this.isLoadingTools = false;
                    }
                }, // Added comma

                async fetchConversation() {
                    try {
                        const data = await this.apiFetch('/conversation');
                        console.log('fetchConversation received data:', JSON.stringify(data));
                        if (data) {
                            console.log('fetchConversation is SETTING nodes:', JSON.stringify(data.nodes || []));
                            Alpine.store('conversation').setCurrentNodeId(data.currentNodeId || 'root');
                            this.currentConversation = data.messages || [];
                            Alpine.store('conversation').setNodes(data.nodes || [{ id: 'root', name: 'Root', parentId: null, childrenIds: [] }]);
                            this.currentModel = data.model || this.config.defaultModel; // Update model based on convo state
                            this.scrollToBottom();
                            // Ensure highlighting runs after conversation loads
                            this.$nextTick(() => this.initHighlighting(this.$refs.chatbox));
                        } else {
                            // Handle case where API returns ok but no data (e.g., new session)
                            console.log('fetchConversation received NULL data, resetting nodes.');
                            Alpine.store('conversation').setCurrentNodeId('root');
                            this.currentConversation = [];
                            Alpine.store('conversation').setNodes([{ id: 'root', name: 'Root', parentId: null, childrenIds: [] }]);
                            // Keep current model or reset to default? Keep for now.
                            // this.currentModel = this.config.defaultModel;
                        }
                    } catch (e) {
                        this.addNotification('Failed to load conversation state.', 'error');
                        // Optionally clear conversation on error? Or keep stale data? Keep for now.
                    }
                }, // Added comma


                // --- CONFIG ---
                // All config methods seem correct with commas added.
                loadConfig() {
                    this.apiFetch('/config')
                        .then(data => {
                            if (data) {
                                const defaultConfig = { apiKey: '', defaultModel: 'claude-3-5-sonnet-20240620', maxTokens: 4096, temperature: 0.7, enableStreaming: true, enableCaching: true, autoDiscover: true, enableLocalDiscovery: true, dashboardRefreshRate: 2.0 };
                                this.config = { ...defaultConfig, ...data };
                                this.currentModel = this.config.defaultModel || 'claude-3-5-sonnet-20240620';
                            } else { this.loadConfigFromLocalStorage(); }
                        })
                        .catch(() => { this.addNotification('Failed to load config from server, using defaults.', 'warning'); this.loadConfigFromLocalStorage(); });
                },
                saveConfigField(key, value) {
                    clearTimeout(this.saveConfigTimer);
                    this.saveConfigTimer = setTimeout(() => {
                        this.config[key] = value; const updatePayload = { [key]: value };
                        console.log('Saving config field via API:', updatePayload);
                        this.apiFetch('/config', { method: 'PUT', body: JSON.stringify(updatePayload), })
                            .then(() => this.addNotification(`Setting '${key}' saved.`, 'success', 1500))
                            .catch(() => { this.addNotification(`Failed to save setting '${key}'.`, 'error'); });
                    }, 750);
                },
                async resetConfig() { // Make async
                    if (confirm('Are you sure you want to reset the configuration TO DEFAULTS? This affects the server and cannot be undone easily.')) {
                        console.warn("Resetting configuration via API...");
                        this.isLoading = true; // Use global loading
                        this.addNotification("Resetting configuration to defaults...", "warning");
                        try {
                            // Call the API endpoint
                            const result = await this.apiFetch('/config/reset', { method: 'POST' });
                            this.addNotification(result.message || "Configuration reset successfully.", "success");
                            // Reload UI config state from server (which should now be default)
                            await this.loadConfig();
                            // Reload servers and capabilities as config changed drastically
                            await this.fetchServers();
                            await this.fetchCapabilities();
                            // Consider reloading the page or forcing a full state refresh if needed
                        } catch (e) {
                            this.addNotification(`Configuration reset failed: ${e.message}`, 'error');
                        } finally {
                            this.isLoading = false;
                        }
                    }
                },
                loadConfigFromLocalStorage() {
                    const savedConfig = localStorage.getItem('mcp_client_config');
                    if (savedConfig) {
                        try {
                            const parsed = JSON.parse(savedConfig);
                            const defaultConfig = { apiKey: '', defaultModel: 'claude-3-5-sonnet-20240620', maxTokens: 4096, temperature: 0.7, enableStreaming: true, enableCaching: true, autoDiscover: true, enableLocalDiscovery: true, dashboardRefreshRate: 2.0 };
                            this.config = { ...defaultConfig, ...parsed };
                            this.currentModel = this.config.defaultModel || 'claude-3-5-sonnet-20240620';
                            this.addNotification('Loaded config fallback from local storage.', 'info');
                        } catch (e) { console.error("Failed to parse saved config:", e); localStorage.removeItem('mcp_client_config'); }
                    }
                },
                setModel(modelName) {
                    if (!modelName || modelName === this.currentModel) return;
                    this.currentModel = modelName; this.config.defaultModel = modelName;
                    this.saveConfigField('defaultModel', modelName);
                    this.addNotification(`Model set to: ${this.currentModelShort}`, 'info', 1500);
                },
                setCustomModel(modelName) {
                    const trimmedName = modelName.trim();
                    if (trimmedName && trimmedName !== this.currentModel) {
                        this.currentModel = trimmedName; this.config.defaultModel = this.currentModel;
                        this.saveConfigField('defaultModel', this.currentModel);
                        if (!this.availableModels.includes(this.currentModel)) { this.availableModels.push(this.currentModel); }
                        this.addNotification(`Custom model set: ${this.currentModelShort}`, 'info', 1500);
                    }
                },

                // --- SERVER MGMT ---
                serverStatusIcon(server) {
                    const baseClasses = 'text-lg ';
                    if (!server || typeof server.enabled === 'undefined') return baseClasses + 'fas fa-question-circle text-gray-400';
                    if (!server.enabled) return baseClasses + 'fas fa-ban text-base-content/30';
                    if (server.isLoading) return baseClasses + 'fas fa-spinner fa-spin text-info';
                    if (server.isConnected) return baseClasses + 'fas fa-check-circle text-success';
                    return baseClasses + 'fas fa-times-circle text-error';
                },
                async toggleServerConnection(server) {
                    if (!server || !server.name) return; const action = server.isConnected ? 'disconnect' : 'connect';
                    const endpoint = `/servers/${encodeURIComponent(server.name)}/${action}`;
                    const serverIndex = this.servers.findIndex(s => s.name === server.name); if (serverIndex === -1) return;
                    this.servers[serverIndex].isLoading = true; this.servers[serverIndex].statusText = action === 'connect' ? 'Connecting...' : 'Disconnecting...';
                    this.servers = [...this.servers];
                    try {
                        await this.apiFetch(endpoint, { method: 'POST' });
                        this.addNotification(`Server ${server.name} ${action} requested.`, 'info');
                        setTimeout(() => this.fetchServers(), 1500); await this.fetchCapabilities();
                    } catch (e) { this.addNotification(`Failed to ${action} server ${server.name}.`, 'error'); await this.fetchServers(); }
                    finally { const finalServerState = this.servers.find(s => s.name === server.name); if (finalServerState) { finalServerState.isLoading = false; } else if (this.servers[serverIndex]) { this.servers[serverIndex].isLoading = false; } this.servers = [...this.servers]; }
                },
                async toggleServerEnabled(server) {
                    if (!server || !server.name) return; const wasEnabled = server.enabled;
                    const serverIndex = this.servers.findIndex(s => s.name === server.name); if (serverIndex === -1) return;
                    this.servers[serverIndex].enabled = !wasEnabled; this.servers = [...this.servers];
                    if (!this.servers[serverIndex].enabled && this.servers[serverIndex].isConnected && !this.servers[serverIndex].isLoading) { console.log(`Disabling server ${server.name}, requesting disconnect.`); this.toggleServerConnection(this.servers[serverIndex]).catch(e => console.warn(`Disconnect during disable failed: ${e}`)); }
                    try {
                        await this.apiFetch(`/servers/${encodeURIComponent(server.name)}/enable?enabled=${!wasEnabled}`, { method: 'PUT' });
                        this.addNotification(`Server ${server.name} ${!wasEnabled ? 'enabled' : 'disabled'}.`, 'success');
                        await this.fetchServers(); await this.fetchCapabilities();
                    } catch (e) { this.addNotification(`Failed to update enable status for ${server.name}.`, 'error'); if (this.servers[serverIndex]) { this.servers[serverIndex].enabled = wasEnabled; this.servers = [...this.servers]; } await this.fetchServers(); }
                },
                async removeServer(serverName) {
                    if (confirm(`Are you sure you want to remove server "${serverName}"? This cannot be undone.`)) {
                        try {
                            await this.apiFetch(`/servers/${encodeURIComponent(serverName)}`, { method: 'DELETE' });
                            this.addNotification(`Server ${serverName} removed.`, 'warning');
                            await this.fetchServers(); await this.fetchCapabilities();
                        } catch (e) { this.addNotification(`Failed to remove server ${serverName}.`, 'error'); }
                    }
                },
                async addServer() {
                    const trimmedName = this.newServer.name.trim(); const trimmedPath = this.newServer.path.trim();
                    if (!trimmedName || !this.newServer.type || !trimmedPath) { this.addNotification('Server name, type, and path/URL are required.', 'error'); return; }
                    if (this.servers.some(s => s.name === trimmedName)) { this.addNotification(`Server name "${trimmedName}" already exists.`, 'error'); return; }
                    if (this.newServer.type === 'sse' && !trimmedPath.match(/^https?:\/\//)) { this.addNotification('SSE server requires a valid HTTP(S) URL.', 'error'); return; }
                    this.isLoading = true;
                    try {
                        const payload = { name: trimmedName, type: this.newServer.type, path: trimmedPath, argsString: this.newServer.argsString.trim() || "" };
                        await this.apiFetch('/servers', { method: 'POST', body: JSON.stringify(payload) });
                        this.addNotification(`Server ${payload.name} added.`, 'success');
                        this.showAddServerModal = false; this.newServer = { name: '', type: 'stdio', path: '', argsString: '' };
                        await this.fetchServers();
                    } catch (e) { this.addNotification(`Failed to add server ${trimmedName}.`, 'error'); }
                    finally { this.isLoading = false; }
                },

                // --- DISCOVERY ---
                async discoverServers(type) {
                    if (type === 'mdns' && !this.config.enableLocalDiscovery) { this.addNotification('mDNS discovery is disabled in settings.', 'warning'); return; }
                    console.log(`Discovering servers (${type}) via API...`); this.isLoadingDiscovery = true; this.discoveredServers = [];
                    try {
                        const results = await this.apiFetch(`/discover?type=${type}`, { method: 'POST' });
                        this.discoveredServers = results || [];
                        this.addNotification(`${type} discovery finished. Found ${this.discoveredServers.length}.`, this.discoveredServers.length > 0 ? 'success' : 'info', 2500);
                    } catch (e) { this.addNotification(`Discovery (${type}) failed.`, 'error'); }
                    finally { this.isLoadingDiscovery = false; }
                },
                serverExists(discoveredServer) {
                    if (!discoveredServer) return false; const pathOrUrl = discoveredServer.path || discoveredServer.url;
                    return this.servers.some(s => s.name === discoveredServer.name || s.path === pathOrUrl);
                },
                addDiscoveredServer(discoveredServer) {
                    if (!discoveredServer) return;
                    this.newServer = { name: discoveredServer.name || `discovered-${discoveredServer.type || 'server'}`, type: discoveredServer.type || 'sse', path: discoveredServer.path || discoveredServer.url || '', argsString: discoveredServer.args ? discoveredServer.args.join(' ') : '' };
                    this.addServer();
                },

                // --- TOOLS ---
                showToolDetails(tool) {
                    this.selectedTool = tool; this.directToolParams = '{}'; this.directToolResult = null; this.directToolError = null; this.isLoadingDirectTool = false; this.showToolDetailsModal = true;
                },
                async executeToolDirectly() {
                    if (!this.selectedTool) return; let params;
                    try { params = JSON.parse(this.directToolParams || '{}'); this.directToolError = null; }
                    catch (e) { this.directToolError = `Invalid JSON parameters: ${e.message}`; this.directToolResult = null; this.$nextTick(() => this.initHighlighting(document.getElementById('toolDetailsModal'))); return; }
                    this.isLoadingDirectTool = true; this.directToolResult = null; this.directToolError = null;
                    try {
                        const payload = { tool_name: this.selectedTool.name, server_name: this.selectedTool.server_name, params: params };
                        const result = await this.apiFetch('/tool/execute', { method: 'POST', body: JSON.stringify(payload) });
                        if (result && (result.is_error || result.error || (result.status && result.status !== 'success' && result.status !== 200))) { this.directToolError = `Tool execution failed: ${JSON.stringify(result.content || result.error || result.detail || result)}`; this.directToolResult = null; }
                        else { this.directToolResult = result; this.addNotification(`Tool '${this.selectedTool.name}' executed successfully.`, 'success', 2000); }
                    } catch (e) { this.directToolError = `Execution request failed: ${e.message}`; this.directToolResult = null; this.addNotification(`Failed to execute tool '${this.selectedTool.name}'.`, 'error'); }
                    finally { this.isLoadingDirectTool = false; this.$nextTick(() => this.initHighlighting(document.getElementById('toolDetailsModal'))); }
                },
                async applyPrompt(promptName) { // Make it async
                    if (!promptName) return;
                    const selectedPrompt = this.prompts.find(p => p.name === promptName);
                    if (!selectedPrompt) { console.error(`Prompt ${promptName} not found.`); this.addNotification(`Prompt '${promptName}' not found.`, 'error'); return; }

                    // Optional: Ask for confirmation?
                    // if (!confirm(`Apply system prompt '${selectedPrompt.shortName}' to the current conversation? This modifies the history.`)) return;

                    console.log(`Applying prompt '${promptName}' via API...`);
                    this.isLoading = true; // Indicate activity

                    try {
                        // Call the new API endpoint
                        const result = await this.apiFetch('/conversation/apply_prompt', {
                            method: 'POST',
                            body: JSON.stringify({ prompt_name: promptName }) // Send the full name
                        });
                        this.addNotification(result.message || `Prompt '${selectedPrompt.shortName}' applied successfully.`, 'success');
                        // Optionally, refresh the conversation view immediately, though the next query will use it
                        // await this.fetchConversation();
                    } catch (e) {
                        this.addNotification(`Failed to apply prompt '${selectedPrompt.shortName}': ${e.message}`, 'error');
                    } finally {
                        this.isLoading = false;
                    }
                },

                // --- CHAT ---
                sendMessage() {
                    if (!this.userInput.trim() || !this.wsConnected) { if (!this.wsConnected) this.addNotification('Chat not connected. Cannot send.', 'error'); else if (!this.userInput.trim()) this.addNotification('Cannot send an empty message.', 'warning'); return; }
                    if (this.isSendingMessage && !this.config.enableStreaming) { this.addNotification('Please wait for the previous response (streaming disabled).', 'warning'); return; }
                    const text = this.userInput; this.userInput = ''; this.adjustTextareaHeight(this.$refs.inputarea);
                    this.addMessageToConversation('user', text);
                    this.isSendingMessage = true; this.currentStatusMessage = "Sending to Claude..."; this.currentAssistantMessageId = null;
                    const messagePayload = { type: 'query', payload: text, model: this.currentModel, config: { max_tokens: this.config.maxTokens, temperature: this.config.temperature, stream: this.config.enableStreaming } };
                    this.stopController = new AbortController(); this.sendWebSocketMessage(messagePayload);
                },
                stopGeneration() {
                    if (this.isSendingMessage) {
                        console.log("Attempting to stop generation..."); this.addNotification("Attempting to stop generation...", "warning");
                        this.sendWebSocketMessage({ type: 'stop_generation' });
                        if (this.stopController) { this.stopController.abort(); }
                        this.isSendingMessage = false; this.isLoading = false; this.currentStatusMessage = "Generation stopped by user."; this.currentAssistantMessageId = null;
                    }
                },
                toggleDataView(messageId) {
                    if (!messageId) return;

                    // Initialize the display mode if it doesn't exist
                    if (typeof this[`${messageId}_displayMode`] === 'undefined') {
                        this[`${messageId}_displayMode`] = 'raw';
                    }

                    // Toggle between raw and structured
                    this[`${messageId}_displayMode`] = this[`${messageId}_displayMode`] === 'raw'
                        ? 'structured'
                        : 'raw';

                    // Re-initialize highlighting
                    this.$nextTick(() => {
                        this.initHighlighting(this.$refs.chatbox);
                        this.initTippy();
                    });
                },
                addMessageToConversation(role, content, metadata = {}) {
                    // *** No filter needed here anymore ***

                    const tempId = `${role}_${Date.now()}_${Math.random().toString(16).slice(2)}`;

                    const newMessage = {
                        role: role,
                        content: content,
                        id: metadata.id || tempId,
                        timestamp: metadata.timestamp || new Date().toISOString(),
                        model: metadata.model || (role === 'assistant' ? this.currentModelShort : null),
                        content_type: metadata.content_type || null,
                        tool_name: metadata.tool_name,
                        is_error: metadata.is_error,
                        // Remove internal flags like _applyProse if they still exist
                        ...metadata
                    };

                    // Add/Update message in conversation array
                    const existingIndex = this.currentConversation.findIndex(m => m.id === newMessage.id);
                    if (existingIndex === -1) {
                        this.currentConversation.push(newMessage);
                    } else {
                        this.currentConversation[existingIndex] = { ...this.currentConversation[existingIndex], ...newMessage };
                        this.currentConversation = [...this.currentConversation]; // Force reactivity
                    }
                    this.scrollToBottom();

                }, // End addMessageToConversation

                shouldAnimate(messageId) { const lastMsg = this.currentConversation[this.currentConversation.length - 1]; return lastMsg && lastMsg.id === messageId; },
                // --- UTILITY / RENDERING HELPERS ---

                // Debugging version of renderMessageContent that logs the full structure
                debugRenderMessage(message) {
                    console.log('====== BEGIN FULL MESSAGE DEBUG ======');
                    console.log(`Message role: ${message.role}`);
                    console.log(`Message content type: ${typeof message.content}`);
                    console.log(`Is Array: ${Array.isArray(message.content)}`);
                    console.log('Full content structure:');
                    console.log(safeDebugStringify(message.content));
                    if (Array.isArray(message.content)) {
                        console.log('Array items:');
                        message.content.forEach((item, index) => {
                            console.log(`\n=== Item ${index} ===`);
                            console.log(`Type: ${typeof item}`);
                            console.log(`Content: ${safeDebugStringify(item)}`);
                        });
                    }
                    console.log('====== END FULL MESSAGE DEBUG ======');
                    const rendered = this.renderMessageContent(message);
                    console.log('debugRenderMessage output type:', typeof rendered); // Optional: keep for deeper debugging
                    console.log('debugRenderMessage output:', rendered); // Optional: keep for deeper debugging
                    return rendered;
                },

                // Main function to render message content
                // Add this utility function to properly inspect object structure
                isProbablyJsonString(str) {
                    if (typeof str !== 'string') return false;
                    const trimmed = str.trim();
                    // Check if it looks like JSON (starts with { or [ and ends with } or ])
                    if (!((trimmed.startsWith('{') && trimmed.endsWith('}')) ||
                        (trimmed.startsWith('[') && trimmed.endsWith(']')))) {
                        return false;
                    }
                    try {
                        return JSON.parse(trimmed);
                    } catch (e) {
                        return false;
                    }
                },

                // Utility to inspect object properties and structure - helpful for debugging
                debugObjectStructure(obj, maxDepth = 2, depth = 0) {
                    if (depth > maxDepth) return "...";
                    if (obj === null) return "null";
                    if (obj === undefined) return "undefined";
                    if (typeof obj !== 'object') return String(obj);

                    if (Array.isArray(obj)) {
                        if (obj.length === 0) return "[]";
                        return "[" + obj.slice(0, 3).map(item => this.debugObjectStructure(item, maxDepth, depth + 1)).join(", ") +
                            (obj.length > 3 ? ", ..." : "") + "]";
                    }

                    const keys = Object.keys(obj);
                    if (keys.length === 0) return "{}";
                    const keyValues = keys.slice(0, 5).map(key =>
                        `${key}: ${this.debugObjectStructure(obj[key], maxDepth, depth + 1)}`
                    );
                    return "{" + keyValues.join(", ") + (keys.length > 5 ? ", ..." : "") + "}";
                },

                renderMixedMessageContent(content, message) {
                    if (!Array.isArray(content)) {
                        // If not an array, stringify and render as text (Existing logic)
                        console.warn("renderMixedMessageContent called with non-array:", content);
                        return `<pre class="whitespace-pre-wrap">${DOMPurify.sanitize(JSON.stringify(content, null, 2))}</pre>`;
                    }

                    let html = '<div class="space-y-3">'; // Container for blocks

                    // Process each block in the mixed content array
                    content.forEach((block, index) => {
                        if (!block) return; // Skip null/undefined blocks

                        // Add a divider between tool steps (usage/result pairs) for clarity
                        // Placed before the block for better visual grouping
                        if (index > 0 && (block.type === 'tool_use' || block.type === 'tool_result')) {
                            const prevBlock = content[index - 1];
                            if (prevBlock && ((prevBlock.type === 'tool_use' && block.type === 'tool_result') || (prevBlock.type === 'tool_result' && block.type === 'tool_use'))) {
                                html += `<div class="divider my-3 text-xs opacity-50 font-sans">Tool Step</div>`;
                            } else if (block.type === 'tool_use' && (!prevBlock || prevBlock.type !== 'text')) {
                                html += `<div class="divider my-3 text-xs opacity-50 font-sans">Tool Step</div>`;
                            }
                        }

                        // --- Text Block Rendering ---
                        if (block.type === 'text') {
                            let textContent = block.text;
                            if (typeof textContent === 'object' && textContent !== null && textContent.content) {
                                textContent = textContent.content;
                            }
                            if (textContent === null || typeof textContent === 'undefined') {
                                textContent = '';
                            }
                            // Use a raw value to avoid [object Object] issues
                            let rawText;
                            if (typeof Alpine !== 'undefined' && Alpine.raw) {
                                rawText = Alpine.raw(textContent);
                            } else {
                                rawText = JSON.parse(JSON.stringify(textContent));
                            }
                            const stringToParse = String(rawText);
                            html += this.renderMarkdown(block);
                        }

                        // The rest of the block types (tool_use, tool_result, etc.) remain unchanged
                        // --- Tool Usage Block Rendering ---
                        else if (block.type === 'tool_use') {
                            const toolName = block.name || "Unknown Tool";
                            const inputData = block.input || {};
                            const inputJson = JSON.stringify(inputData, null, 2);
                            const showInputBox = inputJson !== '{}';

                            // Build the HTML for the tool usage block
                            html += `
            <div class="my-2 p-3 bg-base-100/50 dark:bg-base-100/10 border border-base-300/20 rounded-lg shadow-sm">
                <div class="flex flex-wrap items-baseline gap-x-2 gap-y-1 text-sm mb-1.5">
                    <span class="flex items-center gap-1.5 text-base-content/80 font-medium">
                        <i class="fas fa-terminal fa-fw text-info/80"></i>
                        Using Tool:
                    </span>
                    <code class="text-sm font-semibold font-mono text-base-content bg-transparent px-1 py-0 rounded">
                        ${DOMPurify.sanitize(toolName)}
                    </code>
                </div>
                ${showInputBox ? `
                <details class="bg-base-100 dark:bg-base-200/50 rounded group border border-base-300/20" open>
                    <summary class="text-xs cursor-pointer select-none p-1.5 font-mono text-base-content/70 group-open:border-b group-open:border-base-300/40 hover:bg-base-200/30 transition-colors duration-150">Input Parameters</summary>
                    <div class="p-2 max-h-60 overflow-y-auto relative">
                         <pre><code class="language-json hljs">${hljs.highlight(inputJson, { language: 'json', ignoreIllegals: true }).value}</code></pre>
                         ${this.createCopyButton(inputJson)}
                    </div>
                </details>
                ` : `
                <div class="text-xs italic text-base-content/60 mt-1 px-1">(No input parameters)</div>
                `}
            </div>`;
                        }

                        // --- Tool Result Block Rendering ---
                        else if (block.type === 'tool_result') {
                            const isError = block.is_error || false;
                            const statusClass = isError ? 'text-error' : 'text-success';
                            const statusIcon = isError ? 'fa-exclamation-circle' : 'fa-check-circle';
                            const toolUseId = block.tool_use_id || "";
                            const relatedToolName = message?.content?.find(b => b.type === 'tool_use' && b.id === toolUseId)?.name;

                            let rawResultContent = block.content;
                            let displayContent = "";
                            let language = 'plaintext';

                            try {
                                if (typeof rawResultContent === 'string' && this.isProbablyJsonString(rawResultContent)) {
                                    displayContent = JSON.stringify(JSON.parse(rawResultContent), null, 2);
                                    language = 'json';
                                } else if (typeof rawResultContent === 'string') {
                                    displayContent = rawResultContent;
                                } else {
                                    displayContent = JSON.stringify(rawResultContent, null, 2);
                                    language = 'json';
                                }
                            } catch (e) {
                                console.error("Error processing tool result content:", e);
                                displayContent = String(rawResultContent || (isError ? '[Error Content Processing Failed]' : '[Result Content Processing Failed]'));
                            }

                            const highlightedContent = hljs.highlight(displayContent, { language: language, ignoreIllegals: true }).value;

                            // Build the HTML for the tool result block
                            html += `
            <div class="my-2 p-3 ${isError ? 'bg-error/10 border-error/20' : 'bg-success/10 border-success/20'} rounded-lg border">
                <div class="flex flex-wrap items-baseline gap-x-2 gap-y-1 ${statusClass} font-medium text-sm mb-1.5">
                    <span class="flex items-center gap-1.5"><i class="fas ${statusIcon} fa-fw"></i>${isError ? 'Tool Error' : 'Tool Result'}</span>
                     ${relatedToolName ? `<span class="text-xs text-base-content/70">(from <code class="text-xs font-semibold font-mono">${DOMPurify.sanitize(relatedToolName)}</code>)</span>` : ''}
                    ${toolUseId ? `<span class="text-xs text-base-content/70">(for call <code class="text-xs font-mono">...${DOMPurify.sanitize(toolUseId.slice(-6))}</code>)</span>` : ''}
                </div>
                <div class="mt-2 bg-base-100/80 dark:bg-base-300/30 p-2 rounded-md relative group">
                    <pre class="overflow-auto max-h-60"><code class="language-${language} hljs whitespace-pre-wrap break-all">${highlightedContent}</code></pre>
                    ${this.createCopyButton(displayContent, 'result')}
                </div>
            </div>`;
                        }

                        // --- Unknown Block Type Handling ---
                        else {
                            let unknownContent;
                            try { unknownContent = JSON.stringify(block, null, 2); }
                            catch (e) { unknownContent = '[Error stringifying unknown block]'; }

                            html += `
            <div class="bg-warning/10 p-2 rounded-lg my-2 opacity-70 border border-warning/30">
                <div class="font-medium text-xs mb-1 text-warning-content/80">Unknown Content Block Type: <code class="text-xs font-bold">${block.type || 'N/A'}</code></div>
                <pre class="text-xs">${DOMPurify.sanitize(unknownContent)}</pre>
            </div>`;
                        }
                    }); // End forEach block loop

                    html += '</div>'; // Close the main space-y-3 container
                    return html;
                },

                // Render tool result
                renderToolResult(result, message) {
                    // Ensure result is an object
                    if (typeof result === 'string') {
                        try {
                            result = JSON.parse(result);
                        } catch (e) {
                            // Keep as string if parsing fails
                        }
                    }

                    // Handle when result is still a string
                    if (typeof result === 'string') {
                        return this.renderMarkdown(result);
                    }

                    // Extract information
                    const isError = message?.is_error || result?.is_error || result?.error || false;
                    const toolName = message?.tool_name || result?.tool_name || result?.name || "Tool Result";

                    // Get the actual content (handle nested content structure)
                    let resultContent = result;
                    if (result && result.content !== undefined) {
                        resultContent = result.content;
                    }

                    // Convert to formatted string representation
                    const contentStr = this.renderToolResultContent(resultContent);
                    const statusClass = isError ? 'text-error' : 'text-success';
                    const statusIcon = isError ? 'fa-exclamation-circle' : 'fa-check-circle';

                    try {
                        const highlightedContent = hljs.highlight(contentStr, { language: 'json', ignoreIllegals: true }).value;

                        return `
            <div class="my-2 p-3 ${isError ? 'bg-error/10' : 'bg-success/10'} rounded-md border ${isError ? 'border-error/20' : 'border-success/20'}">
                <div class="flex items-center gap-2 ${statusClass} font-medium">
                    <i class="fas ${statusIcon} fa-fw"></i>
                    <span>${isError ? 'Tool Error' : 'Tool Result'}: ${DOMPurify.sanitize(toolName)}</span>
                </div>
                <div class="relative group mt-2 bg-base-100/80 dark:bg-base-300/30 p-2 rounded-md">
                    <pre class="overflow-auto max-h-60"><code class="language-json hljs whitespace-pre-wrap break-all">${highlightedContent}</code></pre>
                    ${this.createCopyButton(contentStr)}
                </div>
            </div>
        `;
                    } catch (e) {
                        console.error("Error rendering tool result:", e);
                        return `<div class="p-3 ${isError ? 'bg-error/10' : 'bg-success/10'} rounded-md">
            <div class="${statusClass} font-medium mb-1">
                <i class="fas ${statusIcon} fa-fw mr-1"></i>
                ${isError ? 'Tool Error' : 'Tool Result'}: ${DOMPurify.sanitize(toolName)}
            </div>
            <pre class="text-xs whitespace-pre-wrap break-all">${DOMPurify.sanitize(contentStr)}</pre>
        </div>`;
                    }
                },


                // Add this custom renderer for structured reports
                renderStructuredReport(content) {
                    // Handle case where content is already a string
                    if (typeof content === 'string') {
                        return this.renderMarkdown(content);
                    }

                    // Handle array of mixed content
                    if (Array.isArray(content)) {
                        // Extract text content from the array
                        let combinedText = '';

                        // Go through each item in the array
                        content.forEach(item => {
                            if (typeof item === 'string') {
                                combinedText += item + '\n\n';
                            }
                            else if (item && typeof item === 'object') {
                                // Handle text blocks
                                if (item.type === 'text' && item.text) {
                                    combinedText += item.text + '\n\n';
                                }
                                // Handle other formats - extract any text properties
                                else {
                                    Object.entries(item).forEach(([key, value]) => {
                                        if (typeof value === 'string' && key !== 'type') {
                                            combinedText += value + '\n\n';
                                        }
                                    });
                                }
                            }
                        });

                        // Render the combined text
                        return this.renderMarkdown(combinedText);
                    }

                    // Handle single objects
                    if (content && typeof content === 'object') {
                        // For structured report objects
                        if (content.sections || content.content || content.text) {
                            let reportText = '';

                            // Add title if present
                            if (content.title || content.heading) {
                                reportText += `# ${content.title || content.heading}\n\n`;
                            }

                            // Add main content if present
                            if (content.content || content.text) {
                                reportText += (content.content || content.text) + '\n\n';
                            }

                            // Process sections if present
                            if (Array.isArray(content.sections)) {
                                content.sections.forEach(section => {
                                    if (typeof section === 'string') {
                                        reportText += section + '\n\n';
                                    }
                                    else if (section && typeof section === 'object') {
                                        // Section with title
                                        if (section.title || section.heading) {
                                            reportText += `## ${section.title || section.heading}\n\n`;
                                        }

                                        // Section content
                                        if (section.content || section.text) {
                                            reportText += (section.content || section.text) + '\n\n';
                                        }

                                        // Handle subsections
                                        if (Array.isArray(section.subsections)) {
                                            section.subsections.forEach(subsection => {
                                                if (typeof subsection === 'string') {
                                                    reportText += subsection + '\n\n';
                                                }
                                                else if (subsection && typeof subsection === 'object') {
                                                    if (subsection.title || subsection.heading) {
                                                        reportText += `### ${subsection.title || subsection.heading}\n\n`;
                                                    }
                                                    if (subsection.content || subsection.text) {
                                                        reportText += (subsection.content || subsection.text) + '\n\n';
                                                    }
                                                }
                                            });
                                        }
                                    }
                                });
                            }

                            return this.renderMarkdown(reportText);
                        }
                    }

                    // Fallback - convert to JSON and render as structured data
                    return this.renderJson(content);
                },

                renderUserProvidedToolResult(block, message) {
                    // block is message.content[0] which has { type: 'tool_result', content: 'STRING_OR_JSON_STRING', ... }
                    const toolUseId = block.tool_use_id || 'Unknown Tool Call';
                    let contentData = block.content; // Default to original content string
                    let parsedSuccessfully = false;
                    let isLikelyJson = false;
                    let displayAsJson = false; // Flag to decide rendering format

                    // Start with Tool Result styling (info background, may change if error detected)
                    let containerClasses = "not-prose my-2 p-3 bg-info text-info-content rounded-lg border border-info/20";
                    let headerText = '<span class="flex items-center gap-1.5"><i class="fas fa-database fa-fw"></i>Tool Data Received</span>';

                    // --- MODIFIED PARSING LOGIC ---
                    if (typeof block.content === 'string') {
                        contentData = block.content; // Keep the raw string
                        isLikelyJson = this.isProbablyJsonString(block.content); // Check if it looks like JSON

                        if (isLikelyJson) {
                            try {
                                // Try to parse, but keep the original string if it fails
                                contentData = JSON.parse(block.content);
                                parsedSuccessfully = true;
                                displayAsJson = true; // Parsed successfully, display as JSON
                                console.log("Parsed user tool result string as JSON");
                            } catch (e) {
                                console.warn("Expected JSON string in user tool result, but parsing failed:", e, block.content);
                                // Keep contentData as the original string
                                parsedSuccessfully = false;
                                displayAsJson = false; // Display as raw string
                            }
                        } else {
                            // It's a string, but doesn't look like JSON. Check if it's an error message.
                            parsedSuccessfully = false;
                            displayAsJson = false;
                            if (contentData.toLowerCase().startsWith('error:')) {
                                containerClasses = "not-prose my-2 p-3 bg-error text-error-content rounded-lg border border-error/20"; // Change style for error
                                headerText = '<span class="flex items-center gap-1.5"><i class="fas fa-exclamation-triangle fa-fw"></i>Tool Error Received</span>';
                            }
                        }
                    } else {
                        // If content was not a string (e.g., already an object/array from backend?)
                        contentData = block.content;
                        parsedSuccessfully = true; // Assume structure is valid if not string
                        displayAsJson = true; // Display as JSON
                        console.warn("Received non-string content in user tool_result block:", contentData);
                    }
                    // --- END MODIFIED PARSING LOGIC ---

                    // Build HTML container
                    let html = `<div class="${containerClasses}">`;
                    html += `<div class="flex flex-wrap items-baseline gap-x-2 gap-y-1 font-medium text-sm mb-1.5">
                    ${headerText}
                    <span class="text-xs opacity-70">(for <code class="text-xs font-mono">...${DOMPurify.sanitize(toolUseId.slice(-6))}</code>)</span>
                 </div>`;

                    // Render based on whether we should display as JSON or raw string
                    if (displayAsJson) {
                        // Parsed successfully or was already an object/array
                        // Render the potentially complex object/array as formatted JSON
                        html += `<p class="text-xs font-semibold mt-1 mb-1">Parsed Data (JSON):</p>`;
                        html += `<div class="mt-1 bg-base-100/80 dark:bg-base-300/30 p-2 rounded-md relative group">
                           <pre class="overflow-auto max-h-60"><code class="language-json hljs whitespace-pre-wrap break-all">${hljs.highlight(JSON.stringify(contentData, null, 2), { language: 'json', ignoreIllegals: true }).value}</code></pre>
                           ${this.createCopyButton(JSON.stringify(contentData, null, 2), 'result')}
                       </div>`;
                    } else {
                        // Display as raw string (might be an error message or non-JSON string)
                        html += `<p class="text-xs font-semibold mt-1 mb-1">Raw Data Received:</p>`;
                        html += `<div class="mt-1 bg-base-200/80 dark:bg-base-300/50 p-2 rounded-md relative group">
                         <pre class="text-xs whitespace-pre-wrap break-all">${DOMPurify.sanitize(contentData)}</pre>
                         ${this.createCopyButton(contentData, 'result')}
                      </div>`;
                    }

                    html += `</div>`; // Close the main container
                    return html;
                }, // End renderUserProvidedToolResult

                renderMessageContent(message) {
                    try {
                        // --- Priority Handling ---

                        // 1. Handle the SPECIFIC user-role message containing a single tool_result with string content
                        if (message.role === 'user' &&
                            Array.isArray(message.content) &&
                            message.content.length === 1 &&
                            message.content[0]?.type === 'tool_result' &&
                            typeof message.content[0]?.content === 'string') {
                            console.log("Rendering specific user tool result structure...");
                            return this.renderUserProvidedToolResult(message.content[0], message);
                        }

                        // 2. Handle explicit Assistant/System Tool Results (non-string content or explicit type)
                        const isExplicitToolResult = message.content_type === 'tool_result';
                        const isSingleBlockToolResult = Array.isArray(message.content) && message.content.length === 1 && message.content[0]?.type === 'tool_result';

                        if (isExplicitToolResult || isSingleBlockToolResult) {
                            let resultBlock = isSingleBlockToolResult ? message.content[0] : null;
                            let resultData = isSingleBlockToolResult ? resultBlock.content : message.content; // Use block content or message content

                            // Attempt to parse if the data is a JSON string
                            if (typeof resultData === 'string' && this.isProbablyJsonString(resultData)) {
                                try { resultData = JSON.parse(resultData); } catch (e) { /* Leave as string if parse fails */ }
                            }

                            // Pass combined message/block info to renderer
                            return this.renderToolResult(resultData, { ...message, ...(resultBlock || {}) });
                        }

                        // --- Standard Content Handling ---

                        // 3. Mixed Content Blocks (Assistant/System) - MUST contain at least one non-text block if it got here
                        if (Array.isArray(message.content) && message.content.some(b => typeof b === 'object' && b !== null && b.type && b.type !== 'text')) {
                            console.log("Rendering mixed content...");
                            return this.renderMixedMessageContent(message.content, message);
                        }
                        // Check if it's an array of ONLY text blocks (should be caught by _applyProse now, but belt-and-suspenders)
                        if (Array.isArray(message.content) && message.content.every(b => b && b.type === 'text')) {
                            console.log("Rendering array of text blocks as single markdown...");
                            const combinedText = message.content.map(b => b.text || '').join('\n\n');
                            return this.renderMarkdown(combinedText); // renderMarkdown adds prose
                        }


                        // 4. Simple String Content (User, Assistant, System)
                        if (typeof message.content === 'string') {
                            console.log("Rendering simple string as markdown...");
                            return this.renderMarkdown(message.content); // renderMarkdown adds prose
                        }

                        // 5. Other Objects (Non-array, non-tool-result) -> Render as JSON
                        if (typeof message.content === 'object' && message.content !== null && !Array.isArray(message.content)) {
                            console.log("Rendering object as JSON...");
                            return this.renderJson(message.content); // renderJson adds pre/code
                        }

                        // --- FINAL FALLBACK ---
                        console.warn("renderMessageContent: Fallback rendering for unknown structure:", message.content);
                        if (message.content === null || message.content === undefined) {
                            return '<span class="opacity-50 italic">[No Content]</span>'; // Handle null explicitly here too
                        }
                        // Render as string within prose paragraph
                        return `<div class="prose prose-sm max-w-none"><p>${DOMPurify.sanitize(String(message.content))}</p></div>`;

                    } catch (err) {
                        console.error('renderMessageContent() failed severely:', err, message);
                        return `<div class="text-error p-2 bg-error/10 rounded">Render error: ${DOMPurify.sanitize(err.message)}</div>`;
                    }
                }, // End renderMessageContent


                // Render text content (handle markdown and potential JSON strings)
                renderTextContent(content, message) {
                    // Check if content is a JSON string
                    const parsedJson = this.tryParseJson(content);
                    if (parsedJson !== null) {
                        // If it's a tool result, render it as tool result
                        if (message.content_type === 'tool_result') {
                            return this.renderToolResult(parsedJson, message);
                        }

                        // Otherwise render as JSON with toggle capability
                        return this.renderJsonWithToggle(parsedJson, message.id);
                    }

                    // If not JSON, render as markdown
                    return this.renderMarkdown(content);
                },

                // Render array content (mixed blocks or data)
                renderArrayContent(content, message) {
                    // Special case for arrays with a single text block (common in your app)
                    if (Array.isArray(content) && content.length === 1 &&
                        content[0] && typeof content[0] === 'object' &&
                        content[0].type === 'text' && typeof content[0].text === 'string') {

                        // This is the critical fix - directly extract the text content from 
                        // the single object in the array and render it as markdown
                        console.log("Found single text block, rendering text directly");
                        return this.renderMarkdown(content[0].text);
                    }

                    // Handle mixed content (text blocks + tool calls/results)
                    const hasMixedContent = content.some(item =>
                        item && typeof item === 'object' &&
                        (item.type === 'tool_use' || item.type === 'tool_result')
                    );

                    if (hasMixedContent) {
                        return this.renderMixedMessageContent(message.content);
                    }

                    // If it's an array of data objects that looks like a table
                    if (this.isProbablyTableData(content)) {
                        return this.renderTable(content);
                    }

                    // Default handling for arrays - render as JSON
                    console.log("Falling back to JSON rendering for array");
                    return this.renderJson(content);
                },

                // Render object content
                renderObjectContent(content, message) {
                    // Special handling for tool results from user
                    if (message.role === 'user' && message.content_type === 'tool_result') {
                        return this.renderToolResult(content, message);
                    }

                    // Check if content is just being stringified to [object Object]
                    if (Object.prototype.toString.call(content) === '[object Object]') {
                        // Add better handling for section-based content
                        if (content.title || content.heading) {
                            return `<div class="prose prose-sm max-w-none">
                <h3 class="font-medium text-base">${DOMPurify.sanitize(content.title || content.heading)}</h3>
                ${content.content ? this.renderMarkdown(content.content) : ''}
                ${content.sections ? this.renderSections(content.sections) : ''}
            </div>`;
                        }

                        // If it's just a simple object with no special structure, show it as JSON
                        return this.renderJsonWithToggle(content, message.id);
                    }

                    // Default handling for objects - render as JSON with toggle
                    return this.renderJsonWithToggle(content, message.id);
                },

                // Add a helper function to render sections
                renderSections(sections) {
                    if (!Array.isArray(sections)) return '';

                    let html = '<div class="space-y-3">';
                    sections.forEach(section => {
                        if (typeof section === 'string') {
                            html += `<p>${DOMPurify.sanitize(section)}</p>`;
                        } else if (section && typeof section === 'object') {
                            if (section.title || section.heading) {
                                html += `<h4 class="font-medium mt-2">${DOMPurify.sanitize(section.title || section.heading)}</h4>`;
                            }
                            if (section.content) {
                                html += this.renderMarkdown(section.content);
                            } else if (Object.keys(section).length > 0) {
                                // Handle other properties as content
                                const content = Object.entries(section)
                                    .filter(([k]) => k !== 'title' && k !== 'heading')
                                    .map(([k, v]) => {
                                        if (typeof v === 'string') return v;
                                        if (typeof v === 'object') return JSON.stringify(v);
                                        return String(v);
                                    })
                                    .join('\n\n');
                                html += this.renderMarkdown(content);
                            }
                        }
                    });
                    html += '</div>';
                    return html;
                },

                renderMarkdown(content) {
                    try {
                        // Extract the text content safely
                        let textContent = '';

                        if (typeof content === 'string') {
                            textContent = content;
                        } else if (content && typeof content === 'object' && content.type === 'text' && typeof content.text === 'string') {
                            textContent = content.text;
                        } else if (content && typeof content === 'object') {
                            if (content.text && typeof content.text === 'string') { // Check .text again
                                textContent = content.text;
                            } else if (content.content && typeof content.content === 'string') {
                                textContent = content.content;
                            } else if (content.message && typeof content.message === 'string') {
                                textContent = content.message;
                            } else {
                                // Fallback stringification
                                textContent = String(content);
                            }
                        } else {
                            textContent = String(content);
                        }

                        if (typeof textContent !== 'string') { textContent = String(textContent); }

                        const parsedContent = marked.parse(textContent);

                        if (typeof parsedContent !== 'string') {
                            console.error("Marked parser returned non-string content:", parsedContent);
                            // Fallback: Sanitize the original text content
                            return DOMPurify.sanitize(textContent);
                        }

                        // *** Return sanitized parsed content WITHOUT the prose wrapper ***
                        return DOMPurify.sanitize(parsedContent);

                    } catch (e) {
                        console.error("Markdown rendering failed:", e, "Original content:", content);
                        // *** Return sanitized ORIGINAL content (as string) on error ***
                        return DOMPurify.sanitize(String(content));
                    }
                }, // End renderMarkdown

                // Render tool result in a clean format
                renderToolResult(content, message) {
                    const isError = message.is_error || content?.error || false;
                    const statusClass = isError ? 'text-error' : 'text-success';
                    const statusIcon = isError ? 'fa-exclamation-circle' : 'fa-check-circle';
                    let resultContent = content?.error?.message || content?.error || content;

                    try {
                        const highlightedContent = hljs.highlight(resultContent, { language: 'json', ignoreIllegals: true }).value;
                        return `
            <div class="not-prose my-1 space-y-2">
                <div class="flex items-center gap-2 ${statusClass} font-medium">
                    <i class="fas ${statusIcon} fa-fw"></i>
                    <span>${isError ? 'Tool Error' : 'Tool Result'}: ${DOMPurify.sanitize(message.tool_name || '')}</span>
                </div>
                <div class="relative group bg-base-200 p-3 rounded-md">
                    <pre><code class="language-json hljs whitespace-pre-wrap break-all">${highlightedContent}</code></pre>
                    ${this.createCopyButton(resultContent)}
                </div>
            </div>
        `;
                    } catch (e) {
                        return `<div class="not-prose my-1 p-3 bg-base-200 rounded-md">${DOMPurify.sanitize(resultContent)}</div>`;
                    }
                },

                // Simple JSON renderer with syntax highlighting
                renderJson(data) {
                    try {
                        const jsonString = JSON.stringify(data, null, 2);
                        const highlightedJson = hljs.highlight(jsonString, { language: 'json', ignoreIllegals: true }).value;
                        return `
            <div class="relative group my-1">
                <pre class="bg-base-200 rounded-md overflow-x-auto p-3"><code class="language-json hljs">${highlightedJson}</code></pre>
                ${this.createCopyButton(jsonString)}
            </div>
        `;
                    } catch (e) {
                        console.error("JSON rendering error:", e);
                        return `<pre class="text-error p-2 bg-error/10 rounded-md">Error rendering JSON: ${e.message}</pre>`;
                    }
                },

                // Helper to try parsing JSON strings safely
                tryParseJson(str) {
                    if (typeof str !== 'string') return null;
                    const trimmed = str.trim();

                    // Check if it looks like JSON
                    if (!((trimmed.startsWith('{') && trimmed.endsWith('}')) ||
                        (trimmed.startsWith('[') && trimmed.endsWith(']')))) {
                        return null;
                    }

                    try {
                        return JSON.parse(trimmed);
                    } catch (e) {
                        return null;
                    }
                },

                // Helper to create copy button for code blocks
                createCopyButton(codeToCopy, type = 'code') {
                    try {
                        const encodedCode = btoa(encodeURIComponent(JSON.stringify(codeToCopy)));
                        const buttonText = type === 'result' ? 'Copy Result' : 'Copy';
                        return `
            <button class="copy-code-btn" x-data="{ copied: false }" 
                @click.stop="copyToClipboard('${encodedCode}'); copied = true; setTimeout(() => copied = false, 1500)">
                <i class="fas mr-1" :class="copied ? 'fa-check text-success' : 'fa-copy'"></i> 
                <span x-text="copied ? 'Copied!' : '${buttonText}'"></span>
            </button>
        `;
                    } catch (e) {
                        console.error("Error creating copy button:", e);
                        return '';
                    }
                },

                isProbablyJsonString(str) {
                    if (typeof str !== 'string') return false;
                    const trimmed = str.trim();
                    // Check if it looks like JSON (starts with { or [ and ends with } or ])
                    if (!((trimmed.startsWith('{') && trimmed.endsWith('}')) ||
                        (trimmed.startsWith('[') && trimmed.endsWith(']')))) {
                        return false;
                    }
                    try {
                        return JSON.parse(trimmed);
                    } catch (e) {
                        return false;
                    }
                },

                // Utility to inspect object properties and structure - helpful for debugging
                debugObjectStructure(obj, maxDepth = 2, depth = 0) {
                    if (depth > maxDepth) return "...";
                    if (obj === null) return "null";
                    if (obj === undefined) return "undefined";
                    if (typeof obj !== 'object') return String(obj);

                    if (Array.isArray(obj)) {
                        if (obj.length === 0) return "[]";
                        return "[" + obj.slice(0, 3).map(item => this.debugObjectStructure(item, maxDepth, depth + 1)).join(", ") +
                            (obj.length > 3 ? ", ..." : "") + "]";
                    }

                    const keys = Object.keys(obj);
                    if (keys.length === 0) return "{}";
                    const keyValues = keys.slice(0, 5).map(key =>
                        `${key}: ${this.debugObjectStructure(obj[key], maxDepth, depth + 1)}`
                    );
                    return "{" + keyValues.join(", ") + (keys.length > 5 ? ", ..." : "") + "}";
                },



                // Helper to determine if data should be rendered as a table
                isProbablyTableData(data) {
                    if (!Array.isArray(data) || data.length === 0) return false;

                    // Must be an array of objects with consistent keys
                    return data.every(item => typeof item === 'object' && item !== null && !Array.isArray(item));
                },

                // Render structured data as a tree view
                renderStructuredData(data, level = 0) {
                    const maxDepth = 5;
                    if (level > maxDepth) return '<span class="italic opacity-50">[Max depth reached]</span>';

                    const indentStyle = `style="padding-left: ${level * 1}em;"`;

                    if (Array.isArray(data)) {
                        if (data.length === 0) return `<div ${indentStyle} class="opacity-50">[Empty Array]</div>`;

                        let listHtml = `<ul class="list-disc list-inside space-y-1 my-1 bg-base-200/50 rounded-md p-2" ${indentStyle}>`;
                        data.forEach(item => {
                            listHtml += `<li class="break-words">${this.renderStructuredData(item, level + 1)}</li>`;
                        });
                        listHtml += `</ul>`;
                        return listHtml;
                    }
                    else if (typeof data === 'object' && data !== null) {
                        const keys = Object.keys(data);
                        if (keys.length === 0) return `<div ${indentStyle} class="opacity-50">[Empty Object]</div>`;

                        let objHtml = `<div class="space-y-1 my-1 ${level > 0 ? 'bg-base-200/30 rounded-md p-2' : ''}" ${indentStyle}>`;
                        keys.forEach(key => {
                            objHtml += `
                <div class="flex flex-wrap gap-x-2">
                    <strong class="font-medium text-base-content/80">${DOMPurify.sanitize(key)}:</strong>
                    <div class="flex-1 min-w-0">${this.renderStructuredData(data[key], level + 1)}</div>
                </div>
            `;
                        });
                        objHtml += `</div>`;
                        return objHtml;
                    }
                    else {
                        // Render primitives
                        if (data === null) return `<span ${indentStyle} class="italic opacity-60">null</span>`;
                        if (typeof data === 'boolean') return `<span ${indentStyle} class="font-mono ${data ? 'text-success' : 'text-error'}">${data}</span>`;
                        if (typeof data === 'number') return `<span ${indentStyle} class="font-mono text-accent">${data}</span>`;
                        if (typeof data === 'string') {
                            // Try to detect and render inline markdown for strings
                            if (/[*#`[\]]/.test(data)) {
                                try {
                                    return `<span ${indentStyle}>${DOMPurify.sanitize(marked.parseInline(data || ''), { USE_PROFILES: { html: true } })}</span>`;
                                } catch (e) {
                                    return `<span ${indentStyle}>${DOMPurify.sanitize(data)}</span>`;
                                }
                            } else {
                                return `<span ${indentStyle}>${DOMPurify.sanitize(data)}</span>`;
                            }
                        }
                        return `<span ${indentStyle}>${DOMPurify.sanitize(String(data))}</span>`;
                    }
                },

                // Render table data
                renderTable(data) {
                    if (!this.isProbablyTableData(data)) return '<!-- Not table data -->';

                    // Collect all unique headers
                    const uniqueHeaders = new Set();
                    data.forEach(row => {
                        Object.keys(row).forEach(key => uniqueHeaders.add(key));
                    });

                    const sortedHeaders = Array.from(uniqueHeaders).sort();
                    if (sortedHeaders.length === 0) return '<!-- Empty table -->';

                    let tableHtml = `
        <div class="overflow-x-auto my-2 bg-base-100/50 rounded-md shadow-sm border border-base-300/30">
            <table class="table table-zebra table-sm w-full">
                <thead>
                    <tr class="bg-base-300/20">
    `;

                    // Add headers
                    sortedHeaders.forEach(header => {
                        tableHtml += `<th class="sticky top-0 z-10 bg-inherit">${DOMPurify.sanitize(header)}</th>`;
                    });

                    tableHtml += `</tr></thead><tbody>`;

                    // Add rows
                    data.forEach(row => {
                        tableHtml += `<tr class="hover:bg-base-content/5">`;
                        sortedHeaders.forEach(header => {
                            const cellValue = row[header];
                            let cellContent = '';

                            if (cellValue === null || typeof cellValue === 'undefined') {
                                cellContent = '<span class="italic opacity-50">null</span>';
                            }
                            else if (typeof cellValue === 'object') {
                                cellContent = `<pre class="text-xs !p-0 !bg-transparent !whitespace-pre-wrap">${DOMPurify.sanitize(JSON.stringify(cellValue))}</pre>`;
                            }
                            else {
                                cellContent = DOMPurify.sanitize(String(cellValue));
                            }

                            tableHtml += `<td class="whitespace-normal break-words max-w-xs">${cellContent}</td>`;
                        });
                        tableHtml += `</tr>`;
                    });

                    tableHtml += `</tbody></table></div>`;
                    return tableHtml;
                },

                // Add this temporary diagnostic function to your Alpine component
                diagnoseBadRendering() {
                    // Find any message that has a text block
                    const problematicMessage = this.currentConversation.find(msg =>
                        Array.isArray(msg.content) &&
                        msg.content.some(item => item && item.type === 'text')
                    );

                    if (!problematicMessage) {
                        console.log("No text block message found");
                        return;
                    }

                    // Get the first text block
                    const textBlock = problematicMessage.content.find(item => item && item.type === 'text');
                    if (!textBlock || !textBlock.text) {
                        console.log("Text block not found or has no text");
                        return;
                    }

                    // Check if the raw text already contains [object Object]
                    const hasObjectString = textBlock.text.includes('[object Object]');
                    console.log(`TEXT ALREADY CONTAINS [object Object]: ${hasObjectString}`);

                    // Log the raw text content broken by line to see exactly where the issue is
                    console.log("RAW TEXT CONTENT BY LINE:");
                    textBlock.text.split('\n').forEach((line, i) => {
                        if (line.includes('[object Object]') || line.includes('{') || line.includes('}')) {
                            console.log(`LINE ${i} [SUSPICIOUS]: ${line}`);
                        } else {
                            console.log(`LINE ${i}: ${line}`);
                        }
                    });

                    // Try to analyze the rendering pipeline
                    console.log("CHECKING RENDERING PIPELINE...");
                    try {
                        // Check if marked.parse already creates [object Object]
                        const parsedContent = marked.parse(textBlock.text);
                        console.log(`MARKED PARSING CREATES [object Object]: ${parsedContent.includes('[object Object]')}`);
                    } catch (e) {
                        console.error("Error in marked.parse:", e);
                    }
                },
                // Process tool result content
                renderToolResultContent(content) {
                    if (content === null || content === undefined) return '[No Content]';

                    // Handle string content that might be JSON
                    if (typeof content === 'string') {
                        try {
                            if ((content.startsWith('{') && content.endsWith('}')) ||
                                (content.startsWith('[') && content.endsWith(']'))) {
                                return JSON.stringify(JSON.parse(content), null, 2);
                            }
                            return content;
                        } catch {
                            return content;
                        }
                    }

                    // Handle objects and arrays
                    try {
                        return JSON.stringify(content, null, 2);
                    } catch (e) {
                        console.error("Error stringifying tool result:", e);
                        return String(content);
                    }
                },
                messageRoleIcon(role, contentType = null) { if (contentType === 'tool_result') return 'fas fa-wrench'; switch (role) { case 'user': return 'fas fa-user'; case 'assistant': return 'fas fa-robot'; case 'system': return 'fas fa-info-circle'; default: return 'fas fa-question-circle'; } },
                messageRoleDisplayName(role, contentType = null) { if (contentType === 'tool_result') return 'Tool Result'; switch (role) { case 'user': return 'User'; case 'assistant': return 'Claude'; case 'system': return 'System'; default: return role; } },
                formatTimestamp(isoString) { if (!isoString) return ''; try { const date = new Date(isoString); if (isNaN(date.getTime())) return ''; return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); } catch { return ''; } },
                currentStatusIcon() { const msg = this.currentStatusMessage?.toLowerCase() || ""; if (msg.includes("error") || msg.includes("fail")) return "fas fa-exclamation-circle text-error"; if (msg.includes("success") || msg.includes("complete")) return "fas fa-check-circle text-success"; if (msg.includes("cache")) return "fas fa-database text-info"; if (msg.includes("tool") || msg.includes("execut")) return "fas fa-terminal text-accent"; if (msg.includes("stop")) return "fas fa-stop-circle text-warning"; return msg ? "fas fa-spinner fa-spin text-info" : ""; },
                scrollToBottom() { this.$nextTick(() => { this.$refs.endofchat?.scrollIntoView({ behavior: 'smooth', block: 'end' }); }); },
                adjustTextareaHeight(el) { if (!el) return; const maxHeight = 200; el.style.height = 'auto'; el.style.height = Math.min(el.scrollHeight, maxHeight) + 'px'; },

                // --- CONVERSATION MGMT ---
                renderBranchNode(nodeId, level) {
                    // Get node safely
                    const node = this.getNodeById(nodeId);

                    // If node not found, return empty string instead of throwing error
                    if (!node || typeof node.id === 'undefined') {
                        console.error(`Node not found: ${nodeId}`);
                        return ''; // Return empty instead of showing an error
                    }

                    const template = document.getElementById('branch-node-template')?.innerHTML;
                    if (!template) {
                        console.error("Branch template missing!");
                        return '';
                    }

                    // Safely get node properties with fallbacks
                    const nodeName = (node.name || 'Unnamed').replace(/"/g, '&quot;'); // Escape quotes for HTML
                    const children = node.childrenIds || [];
                    const childrenJson = JSON.stringify(children).replace(/"/g, '&quot;'); // Escape quotes  
                    const hasChildren = children.length > 0;

                    // Create safe data attributes
                    let rendered = template
                        .replace('<li ', `<li data-nodeid="${node.id}" data-nodename="${nodeName}" data-level="${level}" data-haschildren="${hasChildren}" data-children="${childrenJson}" `);

                    return rendered;
                },

                // Improved helper to find node data with better error handling
                getNodeById(id) {
                    if (!id) return null;

                    const nodes = Alpine.store('conversation')?.conversationNodes || [];
                    if (!Array.isArray(nodes) || nodes.length === 0) {
                        return null;
                    }

                    return nodes.find(n => n.id === id) || null;
                },
                // Ensure checkoutBranch is correctly defined in the main component scope
                async checkoutBranch(nodeId) {
                    // Check if event detail was dispatched (might be redundant now but safe)
                    if (typeof nodeId === 'object' && nodeId !== null && nodeId.id) {
                        nodeId = nodeId.id;
                    }
                    if (!nodeId || typeof nodeId !== 'string' || nodeId === this.currentNodeId) return;

                    // Add log before API call
                    console.log(`Executing checkoutBranch for Node ID: ${nodeId}`);

                    this.isLoading = true;
                    try {
                        await this.apiFetch('/conversation/checkout', { method: 'POST', body: JSON.stringify({ node_id: nodeId }) });
                        const node = this.getNodeById(nodeId); // Use helper
                        this.addNotification(`Switched to branch: ${node?.name || nodeId.slice(0, 8)}...`, 'success');
                        await this.fetchConversation(); // Refresh chat and potentially node list
                    }
                    catch (e) {
                        this.addNotification(`Failed to checkout branch ${nodeId.slice(0, 8)}...: ${e.message}`, 'error');
                        console.error(`Error in checkoutBranch API call for ${nodeId}:`, e); // Log error details
                    }
                    finally {
                        this.isLoading = false;
                    }
                },

                async forkConversation() {
                    if (this.currentConversation.length === 0 && this.currentNodeId === 'root') { this.addNotification("Cannot fork an empty root conversation.", "warning"); return; }
                    const forkName = prompt("Enter name for new branch (optional):", `Fork of ${this.conversationNodes.find(n => n.id === this.currentNodeId)?.name || this.currentNodeId.slice(-6)}`);
                    if (forkName === null) return; this.isLoading = true;
                    try { const result = await this.apiFetch('/conversation/fork', { method: 'POST', body: JSON.stringify({ name: forkName }) }); this.addNotification(`Fork created: ${result.newNodeName || result.newNodeId.slice(-6)}`, 'success'); await this.fetchConversation(); }
                    catch (e) { this.addNotification('Failed to fork conversation.', 'error'); } finally { this.isLoading = false; }
                },
                async checkoutBranch(nodeId) {
                    // Check if event detail was dispatched
                    if (typeof nodeId === 'object' && nodeId !== null && nodeId.id) {
                        nodeId = nodeId.id; // Extract ID if dispatched as detail object
                    }
                    if (!nodeId || typeof nodeId !== 'string' || nodeId === this.currentNodeId) return;
                    console.log(`Checking out branch: ${nodeId}`); // Add log
                    this.isLoading = true;
                    try {
                        await this.apiFetch('/conversation/checkout', { method: 'POST', body: JSON.stringify({ node_id: nodeId }) });
                        const node = this.getNodeById(nodeId); // Use helper
                        this.addNotification(`Switched to branch: ${node?.name || nodeId.slice(0, 8)}...`, 'success');
                        await this.fetchConversation(); // Refresh chat and potentially node list
                    }
                    catch (e) { this.addNotification(`Failed to checkout branch ${nodeId.slice(0, 8)}...: ${e.message}`, 'error'); }
                    finally { this.isLoading = false; }
                },
                async optimizeConversation() {
                    if (this.currentConversation.length < 2) { this.addNotification("Not enough messages to optimize.", "warning"); return; }
                    if (!confirm('This will attempt to summarize and optimize the current conversation context, potentially replacing the history in this branch. Proceed?')) return; this.isLoading = true;
                    try { const result = await this.apiFetch('/conversation/optimize', { method: 'POST' }); if (result && typeof result.initial_tokens !== 'undefined' && typeof result.final_tokens !== 'undefined') { this.addNotification(`Context optimized: ${result.initial_tokens} -> ${result.final_tokens} tokens`, 'success'); } else { this.addNotification('Context optimization requested.', 'info'); } await this.fetchConversation(); }
                    catch (e) { this.addNotification('Failed to optimize context.', 'error'); } finally { this.isLoading = false; }
                },
                async clearConversation() {
                    if (confirm('Are you sure you want to clear all messages in the current branch and reset it to an empty state based on its parent (or root)?')) {
                        this.isLoading = true;
                        try { await this.apiFetch('/conversation/clear', { method: 'POST' }); this.addNotification(`Conversation branch cleared.`, 'warning'); await this.fetchConversation(); }
                        catch (e) { this.addNotification('Failed to clear conversation.', 'error'); } finally { this.isLoading = false; }
                    }
                },
                async exportConversationAPI() {
                    if (!this.currentNodeId || (this.currentNodeId === 'root' && this.currentConversation.length === 0)) {
                        this.addNotification("Cannot export an empty root conversation.", "warning");
                        return;
                    }
                    this.isLoading = true; // Use global loading for export fetch
                    this.addNotification(`Exporting branch '${this.currentNodeId.slice(0, 8)}...'`, 'info');
                    try {
                        const endpoint = `/conversation/${encodeURIComponent(this.currentNodeId)}/export`;
                        // Fetch the data as JSON first
                        const dataToExport = await this.apiFetch(endpoint); // apiFetch handles loading state reset on finish/error

                        if (!dataToExport) {
                            throw new Error("Received no data from export endpoint.");
                        }

                        // Now create the blob and save using FileSaver.js
                        const blob = new Blob([JSON.stringify(dataToExport, null, 2)], { type: "application/json;charset=utf-8" });
                        const nodeName = dataToExport.name || this.currentNodeId.slice(0, 6);
                        const sanitizedName = nodeName.replace(/[^a-z0-9_-]/gi, '_').toLowerCase();
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                        const filename = `mcp-convo-${sanitizedName}-${timestamp}.json`;
                        saveAs(blob, filename); // External FileSaver.js function
                        this.addNotification(`Conversation exported as ${filename}.`, 'success');

                    } catch (e) {
                        console.error("Export failed:", e);
                        this.addNotification(`Failed to export conversation: ${e.message}`, 'error');
                        this.isLoading = false; // Ensure loading is off if apiFetch didn't handle it
                    }
                    // isLoading is reset by apiFetch's finally block if successful
                },

                async importConversationAPI(file) {
                    if (!file) return;
                    if (!file.type.match('application/json')) {
                        this.addNotification('Import failed: Please select a valid JSON file.', 'error');
                        return;
                    }
                    const fileInput = this.$el.querySelector('input[type="file"][accept=".json"]'); // Find the input element

                    console.log('Importing conversation via API...', file.name);
                    this.isLoadingImport = true; // Use specific loading flag
                    const formData = new FormData();
                    formData.append('file', file);

                    try {
                        // Use standard fetch for FormData upload
                        const response = await fetch(`${API_BASE_URL}/conversation/import`, {
                            method: 'POST',
                            body: formData,
                            // signal: this.stopController?.signal // Optional signal
                        });

                        if (!response.ok) {
                            let errorDetail = `Import failed (HTTP ${response.status})`;
                            try {
                                const errJson = await response.json();
                                errorDetail = errJson.detail || errorDetail;
                            } catch (e) { /* Ignore JSON parsing error on failed response */ }
                            throw new Error(errorDetail);
                        }

                        const data = await response.json(); // Get success message and new node ID
                        this.addNotification(data.message || `Conversation imported successfully.`, 'success');
                        await this.fetchConversation(); // Refresh the conversation state to show the new branch

                    } catch (error) {
                        console.error("Import failed:", error);
                        this.addNotification(`Import failed: ${error.message}`, 'error');
                    } finally {
                        this.isLoadingImport = false;
                        // Reset the file input visually
                        if (fileInput) {
                            fileInput.value = '';
                        }
                    }
                },

                // --- UTILS ---
                copyToClipboard(encodedText) {
                    try { const decodedText = JSON.parse(decodeURIComponent(atob(encodedText))); navigator.clipboard.writeText(decodedText).then(() => { /* Feedback handled by button state */ }).catch(err => { console.error('Clipboard write failed: ', err); this.addNotification('Failed to copy to clipboard.', 'error'); }); }
                    catch (e) { console.error('Failed to decode/copy text: ', e); this.addNotification('Failed to copy (decode/parse error).', 'error'); }
                },

                // --- NOTIFICATIONS ---
                addNotification(message, type = 'info', duration = 3500) {
                    const id = Date.now() + Math.random(); const maxNotifications = 5;
                    while (this.notifications.filter(n => n.visible).length >= maxNotifications) { const oldestVisibleIndex = this.notifications.findIndex(n => n.visible); if (oldestVisibleIndex !== -1) { this.notifications.splice(oldestVisibleIndex, 1); } else { break; } }
                    const notification = { id, message, type, visible: true }; this.notifications.push(notification);
                    const timer = setTimeout(() => { this.dismissNotification(id); }, duration); notification._timer = timer;
                },
                dismissNotification(id, fadeDuration = 500) {
                    const index = this.notifications.findIndex(n => n.id === id);
                    if (index !== -1 && this.notifications[index].visible) {
                        clearTimeout(this.notifications[index]._timer); this.notifications[index].visible = false;
                        setTimeout(() => { const removeIndex = this.notifications.findIndex(n => n.id === id); if (removeIndex !== -1) { this.notifications.splice(removeIndex, 1); } }, fadeDuration);
                    }
                },
                notificationIcon(type) {
                    switch (type) { case 'success': return 'fas fa-check-circle'; case 'error': return 'fas fa-exclamation-circle'; case 'warning': return 'fas fa-exclamation-triangle'; default: return 'fas fa-info-circle'; }
                } // No comma needed for the last method

            })); // End Alpine.data
        }); // End alpine:init listener

    </script>

</body>

</html>